---
title: 프론트엔드 면접 준비 노트 (JavaScript)
date: "2023-08-01T22:12:03.284Z"
description: "프론트엔드 면접 준비하기 - Javascript"
category: "interview"
tags:
  - "interview"
  - "frontend"
  - "javascript"
---

> Reference: [지금까지 받았던 신입 프론트엔드 면접 질문들 by arthur](https://velog.io/@arthur/%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80-%EB%B0%9B%EC%95%98%EB%8D%98-%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%93%A4#%EC%82%AC%EC%84%A4)

> 개인 스터디 글로, 맞지 않는 내용이 있다면 피드백은 대 환영입니다 👼✨

### 자바스크립트는 무슨 언어인가요?

자바스크립트는 본래 브라우저를 제어하는 언어였으나, **Node.js**라는 새로운 실행환경과 구글 V8엔진의 등장으로 자체 어플리케이션을 만들 수 있게 된 언어입니다.<br/>
또한 자바스크립트는 명령형, 함수형, 객체지향 프로그래밍이 모두 가능한 멀티 패러다임 언어입니다.

### 변수 선언, 초기화, 할당의 차이점에 대해 설명해주세요.

변수는 **선언 => 초기화 => 할당** 단계를 거칩니다.

변수 선언은 변수를 생성하는 것을 의미합니다. 변수명(식별자)을 등록하여 스코프가 참조할 대상을 만듭니다.<br/>
초기화는 메모리에 변수 저장을 위한 공간을 확보하는 단계입니다. 기본값으로 **undefined**가 할당됩니다.<br/>
할당은 **=** 연산자를 사용하여 값을 할당하는 단계로, **undefined**로 초기화된 변수에 실제 값을 할당해주는 단계입니다.

```js
var name;  // 변수 선언
var name;  // 변수 선언 => 초기화
console.log(name);  // undefined

name = 'hayeong';  // 변수 할당
console.log(name);  // hayeong
```

### 데이터 타입에 대해 설명해주세요.

Javascript의 타입은 **원시 타입**과 **객체 타입**으로 나뉩니다.

원시 타입은 불변값이라고도 부르며, **string**, **number**, **boolean**, **undefined**, **null**, **symbol** 총 6가지 데이터 타입이 있습니다.<br/>
객체는 원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등) 모두 객체에 해당되며, 참조형 타입이라고도 부릅니다. 

### 생성자에 대해 설명해주세요.

생성자 함수란 **new** 연산자와 함께 호출하여 객체를 생성하는 함수를 의미합니다.<br/>
생성자 함수에 의해 생성된 객체를 인스턴스라하며, 자바스크립트는 **Object** 외에도 다양한 타입의 빌트인 생성자 함수를 제공합니다.<br/>
생성자 함수는 일반 함수와 동일한 방법으로 정의하지만, 파스칼 케이스를 사용하는 관례를 따릅니다.

### this에 대해 설명해주세요.

**this** 키워드는 자신이 속한 객체를 가리키는 식별자를 참조할 수 있는 키워드입니다.<br/>
**this**는 함수가 호출되는 방식에 따라 달라집니다.<br/>

- 일반 함수 호출을 사용할 경우 기본적으로 전역 객체가 바인딩됩니다.
- 메서드 호출을 할 경우, 마침표 연산자 앞에 기술한 객체가 바인딩됩니다.
- 생성자 함수 호출을 할 경우, 미래에 생성할 인스턴스가 바인딩됩니다.
- 화살표 함수는 **this**가 없기 때문에, 선언될 시점에서의 상위 스코프가 바인딩됩니다.

#### call, apply, bind에 대해 설명해주세요.

이 세가지 메서드는 강제로 **this**를 바꿀 수 있습니다.

**call**은 커스텀 this를 지정할 수 있고, **apply**는 call과 유사하지만 인자로 배열을 받는다는 점에서 차이가 있습니다.<br/>
**bind**는 커스텀 this를 영구히 가지는 함수를 만들 수 있습니다.

### 콜백 함수에 대해 설명해주세요.

콜백 함수는 다른 함수의 인자로 넘겨지는 함수를 말합니다.<br/>
콜백 함수는 비동기 프로그래밍에 자주 사용되며, 자바스크립트에서 이벤트 정의를 위해 사용되기도 합니다.

#### 콜백 지옥을 해결하는 방법을 설명해주세요.

콜백 지옥은 비동기 처리 로직을 위해 콜백 함수를 연속으로 중첩하여 사용할 때 발생하는 문제입니다.<br/>
콜백 지옥을 해결하는 방법에는 **Promise**나 **Async**가 있습니다.<br/>

**Promise**는 비동기 연산이 종료된 이후에 결과를 알기 위해 사용하는 객체입니다.<br/>
**Promise**의 **.then**을 사용해 함수 실행 순서를 정할 수 있습니다.<br/>

ES8에서 도입된 **async**, **await**을 사용하면 비동기 함수를 마치 동기적 코드인 것처럼 동작하도록 구현이 가능합니다.<br/>
**async**함수는 **async** 함수 안에서만 동작하며, **await** 키워드를 쓰게 되면 해당 값이 반환 되기 전까지 기다리는 동안 **async** 내부 함수는 일시 중단이 됩니다.

### Promise에 대해 설명해주세요.

**Promise**는 비동기 처리를 간편하게 처리할 수 있도록 도와주는 객체로, 성공 또는 실패 상태를 가집니다.<br/>
비동기 작업이 완료되면 resolve(성공) 또는 reject(실패)로 결과를 처리할 수 있습니다. 이렇게 처리된 결과는 then과 catch 메서드를 이용하여 다음 동작을 연결할 수 있습니다.
이를 통해 비동기 코드를 더 구조적이고 유지보수하기 좋게 작성할 수 있으며, 에러 처리 등을 통해 안정적인 프로그래밍을 할 수 있습니다.

#### Promise.all()에 대해 설명해주세요.

Promise.all()은 자바스크립트의 Promise 메서드로, 여러 개의 Promise 객체를 받아 모든 Promise가 완료될 때까지 기다린 뒤, 그 결과들을 배열로 반환합니다.<br/>
모든 Promise가 성공적으로 처리되면 배열에는 각 Promise의 성공 결과 값이 순서대로 들어가며, 하나라도 실패하면 첫 번째 실패한 Promise의 에러를 반환합니다.

### Promise와 Callback을 비교 설명해주세요.

Callback은 비동기 작업 완료 후 실행되는 함수로, 가독성과 유지보수에 어려움이 있을 수 있습니다.<br/>
Promise는 ES6에서 도입된 비동기 처리 객체로, 콜백 헬을 피하고 더 편리한 비동기 작업을 가능하게 해줍니다.<br/>
성공 또는 실패 시 다른 처리를 할 수 있고, 여러 개의 비동기 작업을 체이닝하여 순차적 또는 병렬로 실행할 수 있습니다.

### Promise와 Async, Await의 차이를 설명해주세요.

Promise는 비동기 작업을 처리하는 객체로, then과 catch를 사용하여 결과를 다룹니다.<br/>
Async/Await은 Promise를 더 간결하고 직관적으로 사용하기 위한 문법으로, async 함수와 await 키워드를 사용합니다.<br/>
비동기 작업의 결과를 변수에 할당하거나 다른 함수에서 사용하기 용이하며, try-catch 문으로 예외 처리를 간편하게 할 수 있습니다.

### AJAX에 대해 설명해주세요.

AJAX는 웹 페이지에서 비동기적으로 서버와 데이터를 주고받는 기술로, 페이지 새로고침 없이 동적으로 내용을 갱신하거나 데이터를 로드할 수 있게 해주는 기술입니다.
Javascript를 사용하여 비동기 통신을 수행하며, 사용자 경험을 향상시키고 웹 페이지의 속도와 효율성을 개선합니다.


### var, let, const 차이를 설명해주세요.

**var**는 함수 스코프를 가집니다. 변수를 중복 선언해도 오류가 발생하지 않고, 똑같은 이름으로 여러번 선언되면 마지막 선언이 유효합니다.
호이스팅 현상이 발생하여 변수가 선언되기 전에도 사용할 수 있습니다.

**let**과 **const**는 중복 선언이 불가능 하며, 블록 스코프를 가집니다. <br/>
**let**은 값이 변경될 수 있는 변수를 선언할 때 사용하고, **const**는 값이 변경되지 않을 변수를 선언할 때 사용합니다.

일반적으로 let과 const를 사용하여 변수를 선언하고, var는 최신 버전의 Javascript에서는 피하는 것이 좋습니다.

#### TDZ에 대해 설명해주세요.

TDZ(Temporal Dead Zone)의 약어로, 변수가 선언되었지만 해당 변수를 사용할 수 없는 현상을 가리킵니다.
TDZ는 변수가 선언되고 초기화되기 전까지의 영역을 의미하는데, ES6의 let과 const는 변수를 블록의 상단으로 호이스팅하지만 초기화하지는 않기 때문에 이런 현상이 발생합니다.

### 함수 선언문과 함수 표현식의 차이에 대해 설명해주세요.

함수 선언문은 `function add(x, y){}`의 형태로 쓰여지며, 완료시 undefined가 출력됩니다. 이때, 이름을 생략할 수 없습니다.

함수 표현식은 `const add = function(x, y) {}`의 형태로 쓸 수 있으며, 함수 리터럴의 함수 이름을 생략할 수 있습니다.

또한 함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생하기 때문에 표현식 이전에 호출할 수 없지만, 함수 선언문으로 정의하면 함수 선언문 이전에 호출할 수 있습니다.

### 이벤트 버블링과 캡처링에 대해 설명해주세요.

이벤트 버블링과 이벤트 캡처링은 브라우저에서 이벤트가 발생했을 때 이벤트를 처리하는 방식을 나타내는 용어입니다. 이 두 가지 방식은 이벤트의 전파(Propagation) 방향에 따라 동작합니다.

이벤트 버블링은 자식 요소에 등록된 이벤트 핸들러가 먼저 실행된 후 부모 요소의 핸들러가 실행하는 것을 말합니다.

이벤트 캡쳐링은 이벤트가 발생한 부모 요소의 핸들러가 먼저 실행된 후 자식 요소에 등록된 핸들러가 실행됩니다.

이벤트 버블링과 캡쳐링은 이벤트의 전파 방향이 다르므로 이를 이용하여 이벤트를 효율적으로 처리할 수 있습니다. 만약 이벤트 전파를 중단하고 싶다면, `event.stopPropagation()` 메서드를 사용하면 됩니다.

#### 이벤트 위임에 대해서 설명해주세요.

이벤트 위임은 상위 요소에 하나의 이벤트 핸들러를 등록하여 하위 요소들의 이벤트를 한 번에 처리하는 기술입니다. 
많은 수의 하위 요소에 각각 이벤트 핸들러를 등록하는 것보다 메모리 사용을 줄이고 코드를 간결하게 만들어줍니다. 
상위 요소에서 이벤트가 발생하면 이벤트가 해당 요소의 하위 요소들까지 전파되어 처리됩니다.
이를 통해 동적으로 생성된 하위 요소들에 대해서도 하나의 핸들러로 처리할 수 있습니다.

#### 이벤트 위임의 동작 방식에 대해서 설명해주세요.

우선 상위 요소에 이벤트 핸들러를 등록합니다. 하위 요소에서 이벤트가 발생하면 이벤트는 먼저 해당 요소에서 시작하여 상위 요소로 전파됩니다. 
이벤트가 상위 요소까지 전파되면 상위 요소에 등록된 이벤트 핸들러가 이벤트를 캐치하여 처리합니다. 이때 **event.target** 속성을 사용하여 이벤트가 발생한 실제 요소를 식별할 수 있습니다.

### 호이스팅과 발생하는 이유에 대해 설명해주세요.

호이스팅은 Javascript 엔진이 코드를 실행하기 전에 변수와 함수 선언을 스코프의 상단으로 끌어올리는 현상입니다. 
호이스팅이 발생하는 이유는 Javascript 엔진이 코드를 실행하기 전에  선언된 변수와 함수의 선언부를 미리 메모리에 할당하기 때문입니다.
이렇게 선언들이 끌어올려지는 동작으로 인해 해당 변수와 함수를 선언 이전에 사용할 수 있게 되는데, 이것이 호이스팅의 원리입니다.
이러한 동작은 실행 컨텍스트(Execution Context)가 형성되는 과정에서 일어나며, 변수와 함수의 선언부를 메모리에 먼저 올려놓는 것으로 이해할 수 있습니다.

### 스코프(Scope)에 대해 설명해주세요.

스코프는 변수와 함수에 접근할 수 있는 유효한 영역을 나타냅니다. 즉, 변수와 함수가 어디에서 정의되고 어디에서 참조될 수 있는지를 결정하는 규칙입니다.<br/>
Javascript에는 전역 스코프와 지역 스코프가 있습니다. 변수와 함수가 스코프에 따라 유효한 영역이 결정되므로, 스코프의 관리는 변수의 생명주기와 충돌을 방지하는 데 중요한 역할을 합니다.

### 클로저(Closure)에 대해 설명해주세요.

클로저(Closure)는 반환된 내부 함수가 자신이 선언되었을 때의 환경(렉시컬 환경)인 스코프를 기억하여, 그 밖에서 호출되어도 해당 환경에 접근할 수 있는 함수를 의미합니다.

이를 통해 전역 변수를 사용하지 않고도 함수 밖에서 해당 변수에 접근할 수 있는 방법을 만들어 주며, 이는 반환된 함수를 제외하면 외부에서 접근할 수 없으므로 마치 private 변수처럼 사용할 수 있습니다.

클로저는 다음 예시에서 처럼 내부에 선언된 함수가 외부 함수의 지역변수를 사용해줬을 때만 클로저라고 선언됩니다.

```js
function outer() {
  let name = "hayeong";
  if (true) {
    let city = "seoul";
    console.log(city);
    console.log(name);
  }
}
```
