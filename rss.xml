<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[kirahaa blog]]></description><link>https://kirahaa.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 07 Sep 2023 08:20:15 GMT</lastBuildDate><item><title><![CDATA[웹 성능 최적화 - 브라우저는 어떻게 렌더링을 할까]]></title><description><![CDATA[…]]></description><link>https://kirahaa.github.io/web-perform-optimization/</link><guid isPermaLink="false">https://kirahaa.github.io/web-perform-optimization/</guid><pubDate>Tue, 05 Sep 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;최적화! 왠지 중요하고 챙겨야할 것 같지만 막상 설명하라고 하면 말이 안나오는 그것!
저도 어디선가 줍줍한 지식들로 대략적으로는 알고 있지만 막상 정리하려니 참 어렵게 느껴지더라고요..?!&lt;br/&gt;
사실 꼭 면접에 대비하기 위함이 아니더라도, 사용자에게 좋은 UX를 남겨주기 위해서는 웹 사이트를 사용자에게 빠르고 쾌적하게 보여주는 것이 좋겠죠?&lt;/p&gt;
&lt;p&gt;우선 웹 브라우저가 어떻게 화면을 그려내는가(=렌더링)에 대해 살펴보려고 합니다.&lt;br/&gt;
저처럼 UI 개발을 하는 분들은 사용자에게 보여질 View를 자주 다루실텐데, 항상 헷갈리는 이 개념에 대해 자세히 파헤쳐봅시다!!&lt;/p&gt;
&lt;p&gt;혹시 맞지 않는 내용이 있다면 언제든 말씀 부탁드립니다😉&lt;/p&gt;
&lt;h2&gt;브라우저: 탐색을 시작합니다&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;browse: 둘러보다[훑어보다], 대강 읽다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;웹 브라우저는 웹의 다양한 콘텐츠를 탐색할 수 있게 만들어주는 프로그램입니다. 여기에는 크롬이나 엣지 같은 익숙한 이름부터, 브레이브나 토어 같이 다소 낯선 이름들까지,
정말 다양한 브라우저가 존재합니다.&lt;/p&gt;
&lt;h3&gt;웹 브라우저 인기 랭킹 in 한국 (2023년 8월)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://gs.statcounter.com/browser-market-share/all/south-korea/#monthly-202208-202308&quot;&gt;출처: statcounter&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Chrome - 50.7%&lt;/li&gt;
&lt;li&gt;Safari - 18.15%&lt;/li&gt;
&lt;li&gt;Samsung Internet - 15.49%&lt;/li&gt;
&lt;li&gt;Whale Browser - 7.82%&lt;/li&gt;
&lt;li&gt;Edge - 5.85%&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;예상했던 대로 Chrome이 가장 많은 비중을 차지하고, Safari가 그 다음입니다. 삼성 인터넷도 꽤나 비중이 크네요!&lt;/p&gt;
&lt;p&gt;2018년까지만 해도 사용률 2위가 무려 &apos;IE&apos;입니다..! 그만큼 국내에서는 IE의 비중이 굉장히 높았습니다. 그래서 신경을 쓰지 않을 수 없었던 참 얄미운 녀석이었죠..&lt;br/&gt;
하지만 모바일 시장의 확대, 액티브엑스 탈피 등의 시장 변화와 함께 마침내 2022년 IE가 잠들면서 이전에 비하면 스트레스가 줄었다고 할 수 있겠네요.&lt;/p&gt;
&lt;h3&gt;웹 브라우저의 동작&lt;/h3&gt;
&lt;p&gt;웹 브라우저에 접속해 주소창에 도메인을 입력하면 아주 짧은 순간에 많은 일이 일어납니다. DNS를 통해 IP 주소를 획득하고, TCP를 통해 연결하고, HTTP 요청을 보내 응답을 받습니다.
이 과정에는 캐싱이 포함됩니다. 이 일련의 과정들은 다음에 더 자세히 알아보도록 하고😋 아무튼, 안전한 HTML 파일을 잘 받아왔다고 가정해봅시다😉&lt;/p&gt;
&lt;h4&gt;웹 브라우저의 구조&lt;/h4&gt;
&lt;p&gt;웹 브라우저는 다음과 같은 구조로 이루어져 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f20076b46244a8af02020cf7fd166890/b7baf/structure.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.78481012658227%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdulQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAQABBQJj/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAIOH/2gAIAQEABj8Cq//EABsQAAEEAwAAAAAAAAAAAAAAAAEAECFxMUHw/9oACAEBAAE/ISLQdLUW8N//2gAMAwEAAgADAAAAEKvP/8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQMBAT8Qh//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/EKf/xAAbEAEBAQACAwAAAAAAAAAAAAABEQBBUSEx4f/aAAgBAQABPxBJ8sJUtnNY9Gro+eXAkTOzBCG//9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;웹 브라우저 구조&quot;
        title=&quot;&quot;
        src=&quot;/static/f20076b46244a8af02020cf7fd166890/af1fa/structure.jpg&quot;
        srcset=&quot;/static/f20076b46244a8af02020cf7fd166890/ab180/structure.jpg 158w,
/static/f20076b46244a8af02020cf7fd166890/ba98e/structure.jpg 315w,
/static/f20076b46244a8af02020cf7fd166890/af1fa/structure.jpg 630w,
/static/f20076b46244a8af02020cf7fd166890/23301/structure.jpg 945w,
/static/f20076b46244a8af02020cf7fd166890/b7baf/structure.jpg 1088w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 집중해서 볼 부분은 바로 &apos;렌더링 엔진&apos;으로, 우리가 만든 마크업과 스타일을 해석해서 그려내는 역할을 합니다.&lt;br/&gt;
물론 두루두루 친해지고 싶지만 일단 여기선 렌더링에 집중해 봅시다!&lt;/p&gt;
&lt;h4&gt;렌더링 엔진의 종류&lt;/h4&gt;
&lt;p&gt;어떤 렌더링 엔진을 쓰는지는 웹 브라우저마다 조금씩 다릅니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Webkit (Safari)
&lt;ul&gt;
&lt;li&gt;Apple에서 개발, 컨커러 브라우저의 KHTML을 기반으로 만든 엔진&lt;/li&gt;
&lt;li&gt;Safari, iOS 브라우저에서 사용하며, 크롬도 Blink 탑재 전에는 해당 엔진을 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Blink (Chrome, Whale, Samsung Internet, Edge)
&lt;ul&gt;
&lt;li&gt;Google에서 개발, Webkit에서 파생된 엔진 (Chromium 28 버전부터 적용)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Trident (Internet Explorer)
&lt;ul&gt;
&lt;li&gt;Microsoft에서 개발, Internet Explorer에서 사용되었지만 웹 표준 미준수 + 각종 버그 + 보안 문제 등으로 이젠 안-녕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EdgeHTML (Edge)
&lt;ul&gt;
&lt;li&gt;Microsoft에서 개발, Trident에서 벗어나 Edge에서 사용되던 엔진이었지만, 2019년부터 Edge 브라우저를 Chromium 기반으로 재구축하면서 이젠 안-녕(2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gecko (Firefox)
&lt;ul&gt;
&lt;li&gt;Mozilla에서 개발&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;사실 웹 브라우저를 만드는 비법은 제조사마다 다르고, 각 엔진도 저마다 고유한 개성이 있어 동작 과정이 조금씩 다릅니다.&lt;/p&gt;
&lt;p&gt;그롬(그리고 아마 대부분의 최신 브라우저)의 경우 각 탭마다 별도의 렌더러 프로세스가 돌아가고 있어서, 여러 개의 탭을 열면 각가 렌더링 엔진이 동작해 해당 탭의 내용을 표시합니다.&lt;br/&gt;
그래서 하나의 탭이 죽어도 다른 탭은 멀쩡히 살아남을 수 있습니다.&lt;/p&gt;
&lt;h2&gt;웹 브라우저가 화면을 그려내는 과정&lt;/h2&gt;
&lt;p&gt;그렇다면 HTML, CSS, Javascript를 어쩜 그리 찰떡같이 해석해서 화면을 그려내는 것인가!가 이 글의 제일 궁금한 포인트이기에 그 일련의 흐름을 알아봅시다.&lt;/p&gt;
&lt;h3&gt;(1) 삐빅, HTML 읽는 중··· 🔍&lt;/h3&gt;
&lt;p&gt;HTML 문서를 받기 시작하면 우선 이를 &lt;strong&gt;파싱(Parsing)하는 작업&lt;/strong&gt;을 시작합니다.&lt;br/&gt;
파싱이란 문서를 해석하고 구조화된 데이터로 바꾸는 것으로, 말하자면 마크업을 렌더링하기 위한 형태로 바꾸는 단계입니다.&lt;/p&gt;
&lt;p&gt;렌더러 프로세스의 메인 스레드는 HTML 문서의 원시 바이트를 읽은 다음, 정해진 파일 인코딩에 맞춰 각각을 문자로 전환합니다. 그러면 아래와 같이 꺽쇄로 묶인 문자열을 읽게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
   &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;/&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
Hello
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;이나 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;는 W3C HTML5 표준에 규정된 문자열이므로 각각의 의미와 규칙을 이해할 수 있습니다. 브라우저는 이것들을 쪼개서 &apos;토큰(Token)&apos;으로 만듭니다.&lt;br/&gt;
예를 들어, &lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;을 보면 html 시작 토큰을 만들고, &lt;code&gt;&amp;#x3C;/html&gt;&lt;/code&gt;를 보면 html 종료 토큰을 만들어 냅니다. 여기에는 태그 뿐만 아니라 속성(&lt;code&gt;class&lt;/code&gt; 등)이나, 텍스트 같은 HTML 요소가 포함돼요.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ea20ce432bfadb1bbab87c587a99270d/bbbf7/htmlToToken.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVR42qWQMW/CMBCF/f9/AhILrLR0YChOooRWAXXP1I2mjRqB4uDajuTL3VV2paKqiIVPN91773R6gm9AMLP3vmmaruvatjXGXHGr6HHWnsOI2Pe91lopZaNA/2JEjMTWDZ+H45d1GDcCAPKiuFsssjRNk8C+rn8uUgQRmfAEXL6Z2WO53FX322r37hyyMFoX67WUMpEyz/NNlr1WFTMDwBjxAIyjAn6u7eQhm66e5slL+TGE8IX/LoHEw8hA7OO4MWwEBeEvVxoLIv128g0mD4+Bzf1S8AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;html to token&quot;
        title=&quot;&quot;
        src=&quot;/static/ea20ce432bfadb1bbab87c587a99270d/984b6/htmlToToken.png&quot;
        srcset=&quot;/static/ea20ce432bfadb1bbab87c587a99270d/4d6f2/htmlToToken.png 158w,
/static/ea20ce432bfadb1bbab87c587a99270d/3c1ae/htmlToToken.png 315w,
/static/ea20ce432bfadb1bbab87c587a99270d/984b6/htmlToToken.png 630w,
/static/ea20ce432bfadb1bbab87c587a99270d/e7d8e/htmlToToken.png 945w,
/static/ea20ce432bfadb1bbab87c587a99270d/58c38/htmlToToken.png 1260w,
/static/ea20ce432bfadb1bbab87c587a99270d/bbbf7/htmlToToken.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇게 문서를 토큰화했으면, 만든 토큰을 가지고 구조화시킵니다.
&lt;code&gt;&amp;#x3C;html&gt;&amp;#x3C;head&gt;&amp;#x3C;/head&gt;&amp;#x3C;/html&gt;&lt;/code&gt;에서 head 종료 토큰은 html 종료 토큰 전에 존재합니다. 따라서 head는 html의 자식이구나! 하고 판단할 수 있어요.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/7469ba2e10846111c028ab452820e128/bbbf7/htmlToNode.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 30.37974683544304%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVR42qWPPWsCQRCG73+FYJHflcJKC9MFUioq2AmCMWlSiLWNjeLH+X2eaLzLnt7e7O7MyOpVgjZ5mmFe5mF4Hb6gtU4A0Bi+DxECgAJAMszEzA6RHUFwGI+GYRA8lGm13kzceSzlNXEU8VRgfxsNdse+L1yBJ5OepiDaPVlG80roVkK3LGZFFF0rnwx3PPVW+3x9L2U/qm1P/SrrapMCIK19qPcaL9XCczH/9FPK8DJHxI4m9mJeRXohYPEH65jlbXHbi9Re7b6TbUv6X4nfxHhsP/M/OAODo1Kn/lTyewAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;html to node&quot;
        title=&quot;&quot;
        src=&quot;/static/7469ba2e10846111c028ab452820e128/984b6/htmlToNode.png&quot;
        srcset=&quot;/static/7469ba2e10846111c028ab452820e128/4d6f2/htmlToNode.png 158w,
/static/7469ba2e10846111c028ab452820e128/3c1ae/htmlToNode.png 315w,
/static/7469ba2e10846111c028ab452820e128/984b6/htmlToNode.png 630w,
/static/7469ba2e10846111c028ab452820e128/e7d8e/htmlToNode.png 945w,
/static/7469ba2e10846111c028ab452820e128/58c38/htmlToNode.png 1260w,
/static/7469ba2e10846111c028ab452820e128/bbbf7/htmlToNode.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;토큰을 파싱해 구조를 만들었으면 각 토큰은 해당하는 &apos;노드(Node)&apos;로 변환됩니다. 노드는 부모-자식이라는 계층적 관계를 통해 문서의 구조를 표현해내는 요소입니다.&lt;br/&gt;
사실 HTML 문서의 모든 것은 노드가 되어 구조를 형성합니다. 태그는 요소 노드(Element Node)가 되고, 그 안에 적은 건 텍스트 노드가 되죠. 속성은 물론, 독타입 선언이나 주석도 모두 노드가 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c1c25a24b1e0b01f3562def5cc8cd3a1/668eb/dom.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 136.70886075949366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAIAAADzvTiPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC2klEQVR42o2Uy08TURSH+c+Mj8hCl8alIVFjjAs3GBPDAiI7IwujGN1pBBGMok2U+FgAJYBRkClQwNSUR2tpOwzQedx7z0tn2kJLC3JmNnPO+e6593fPnBZpZq7rFquWz+cBoGlay4FvIhKReDze1dnZ29vb3d19q709lUrthY6CmVlEcrlcIpFIJpOWZc3MzLiuuxeqg5kZG4wI99YiIkRozGHmFiICOBADrY1SWmujtVZKG2MO8ABQgRvWFBYhprW11UxmI6ovSHIcGHS2b2nsznK8M/2ta3GsY3mi8/dUh958F/FwGBwGCE2w+mh0qO1T/+WJt9e+Dlz+MnBl9uNVnXl+NFwRC9EwloRdhF3CXWaXsRRh9P9thw+gNlxyteeDAQYghGMKVt6b3squWn/WLILdfed/YDBAwm4iPXF9dLBtbOhSbua2mE1AqeUP3zYJBeni4v2F8bvzo107qSdkthH5OHClxSi829CQpVaqo2ClVBAEKnx9z/M831OBr5TyfV9rfQQMkdNEDlOvnymHyjlNYGIOtMnmtmynxCK1RwDifHEnt+kAMUb5NTCEIqEq7GQ+F1Lv7XRMb1vROaPGAOUVJu10LLsyrLcm0JQQeR8G0MAi9vt4/8k3va1vHp7ITt8Q8iDsFxGVTo5ciD0929dzyoqdF98CEgBdUxkZtRMUp+2NuJMZN6Vf1crh+dW25WTGi+vjbuEHYYBIjYKFYwYAowEgdffGUk5jEUBqLpiv9EZms2g7JHUwIxfzW7lsnoAJmwoWbHiZt7ml/vxKHzhT1XYiQ17aGfm5+uJ76tm6+0HBNjUKxnZs+vXZVw9ahx+fLszeFPRCrUF8Tr+bv3jv5Zmewda+yXMOzAkeFIzQuHpnwbcTvj1nvPUawWDXpOzAKniWEywD6jrBqgOQACX8e0K16kcqCIEQClX9Fbg8XKmsG+jySwi0b+FtAeqwZtS8Ze8/+C8xNvmCqVWUqQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Dom&quot;
        title=&quot;&quot;
        src=&quot;/static/c1c25a24b1e0b01f3562def5cc8cd3a1/984b6/dom.png&quot;
        srcset=&quot;/static/c1c25a24b1e0b01f3562def5cc8cd3a1/4d6f2/dom.png 158w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/3c1ae/dom.png 315w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/984b6/dom.png 630w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/e7d8e/dom.png 945w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/668eb/dom.png 1008w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;주요 포인트는 &lt;strong&gt;HTML 문서를 읽어 노드로 만들고 계층 형태로 구조화한다는 것!&lt;/strong&gt;&lt;br/&gt;
이걸 트리 구조라고도 하는데 말 그대로 나무처럼 생겼어요. 뿌리가 있고 가지가 있으며 거기서 잎이 돋아난 나무를 거꾸로 배치한 것이 트리 구조입니다.&lt;br/&gt;
이렇게 구성된 노드 트리를 &lt;strong&gt;DOM(Document Object Model) 트리&lt;/strong&gt;라고도 불러요.&lt;/p&gt;
&lt;p&gt;그중에서도 처음으로 생성되는 가장 상위에 있는 노드인 &lt;code&gt;document&lt;/code&gt;를 루트(Root)라고 부릅니다. 루트 = 뿌리, 노드 = 가지라는 걸 생각하면 귀여운 이름이죠!
참고로 텍스트 노드처럼 자식을 가질 수 없는 노드는 리프(leaf)라고 부릅니다 🌿&lt;br/&gt;
개발자들은 뿌리(document node)를 진입점으로 문서 내 다른 DOM 요소들을 탐색하고 조작할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;DOM?&lt;/h4&gt;
&lt;p&gt;아까부터 DOM이라는 단어가 몇 번 언급되었는데, DOM은 말그대로, 문서(Document)를 객체(Object) 기반으로 표현한 모델(Model)입니다.&lt;/p&gt;
&lt;p&gt;이 모델은 HTML, XML 등의 문서 내 요소를 객체로 표현해 프로그래밍 언어에서 조작할 수 있게 하는 인터페이스를 제공합니다. 우리는 DOM API를 통해 DOM 객체를 조작할 수 있어요.&lt;br/&gt;
만약 span 텍스트를 바꾸고 싶다면 &lt;code&gt;document.body.getElementByTagName(&apos;span&apos;)[0].innerText = &apos;Hello&apos;&lt;/code&gt;로 접근해 조작하면 됩니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM Object
DOM에서 문서와 관련된 객체를 뜻하며, 접근하고 조작하기 위한 인터페이스를 제공합니다.&lt;br/&gt;
프로그래밍적으로 접근하고 조작할 수 있는 객체의 개념입니다.&lt;/li&gt;
&lt;li&gt;DOM Node
DOM Tree(=Node Tree)를 구성하는 온갖 노드들을 말합니다.
트리 구조를 통해 서로 간의 계층적 관계를 나타내요. 문서를 표현하는 각 콘텐츠를 지칭하는 개념입니다.&lt;/li&gt;
&lt;li&gt;DOM Element
DOM Node 중에서도 태그로 표현되는 요소들(&lt;code&gt;div&lt;/code&gt; 등)을 Element Node라고 합니다.
이들을 부르는 다른 말이 DOM Element에요.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇듯 DOM은 트리 구조로 웹 페이지를 표현하며, 이 DOM 트리를 이루는 구성요소가 바로 노드입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c184587551d3e12c11835cbc6963cfab/21062/cssom.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 18.354430379746837%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA10lEQVR42k2P607CQBBG+/5PZNQoqUoRGjAWrNDWEvAWNNGYLktnL8dsa4JfMsnMd/7MicRYnPcY67DWEeI9iHFY74/MHZk+BA7Gggi00t+hj7avn6SzjLyoUVowIrRieP/45i7LSaf3PBZrmr1grbDXUK6FeFgxuFqRjDeM0i3xsKSohWjzsiO5nTLPS5S2KKXQuuVt90U6m3OdTFgsq441zQ+Ncqxq4ezygZPzjPimYjR55vRiwfKpJRL5Uzb/lT1d73y/G9dphwTz8GVQDBN0D22/h/4XNYYvGCEiVb4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cssdom&quot;
        title=&quot;&quot;
        src=&quot;/static/c184587551d3e12c11835cbc6963cfab/984b6/cssom.png&quot;
        srcset=&quot;/static/c184587551d3e12c11835cbc6963cfab/4d6f2/cssom.png 158w,
/static/c184587551d3e12c11835cbc6963cfab/3c1ae/cssom.png 315w,
/static/c184587551d3e12c11835cbc6963cfab/984b6/cssom.png 630w,
/static/c184587551d3e12c11835cbc6963cfab/21062/cssom.png 926w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DOM은 후술할 CSSOM이라는 것과 결합해 렌더(Render) 트리를 만들며, 브라우저는 이걸 통해 화면을 그려냅니다.&lt;br/&gt;
따라서 &lt;strong&gt;DOM은 실제로 화면에 보여지는 것과 일치하지 않다&lt;/strong&gt;고 할 수 있습니다. 예를 들어, &lt;code&gt;display: none&lt;/code&gt; 처리한 요소는 화면에 보이지 않지만 DOM에는 존재하며, &lt;code&gt;:after&lt;/code&gt; 같은 가상요소는 렌더링되었지만 DOM 객체가 아니므로 자바스크립트로 조작하는 것이 불가합니다.&lt;/p&gt;
&lt;p&gt;또한, HTML 문서를 보고 만들긴 했지만 DOM이 HTML과 완전히 일치한다고 할 수도 없습니다. 브라우저는 우리가 닫는 태그를 빼먹고 썼더라도 친절하게 DOM을 구성해주니까요.&lt;/p&gt;
&lt;p&gt;한편, DOM은 자바스크립트의 영향을 받을 수 있습니다. 예를 들면 &lt;code&gt;appendChild()&lt;/code&gt; 메서드로 돔을 추가하는 것도 가능하죠! 그래서 자바스크립트에 의해 DOM 파싱은 &apos;방해받을 수&apos; 있습니다.
이에 대한 내용은 다음 글에서 좀 더 살펴보겠습니다.&lt;/p&gt;
&lt;h3&gt;(2) 삐빅, CSS 읽는 중··· 🔍&lt;/h3&gt;
&lt;p&gt;CSSOM은 이름에서 유추할 수 있듯, CSS Object Model의 약자로 CSS 문서를 객체로 나타내고 조작하기 위한 인터페이스를 제공하는 웹 표준입니다.&lt;br/&gt;
렌더링 엔진이 HTML을 쫙- 스캔할 때, 아마 대부분 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;에서 스타일시트를 만나게 될 거에요. 렌더링에 이 CSS가 필요하다고 생각되면 요청해서 스타일시트 내용을 받아오게 됩니다.&lt;br/&gt;
CSS도 파싱 과정을 거쳐서 Bytes -&gt; Characters -&gt; Tokens -&gt; Nodes -&gt; Object Model로 만들어집니다. 이걸 CSSOM이라고 부르고요. 마찬가지로 트리 형태로 구조화되어 있어요.&lt;/p&gt;
&lt;p&gt;CSS의 C는 캐스케이딩이죠. 즉, 스타일 규칙은 계단식으로 상속됩니다. 브라우저는 트리 구조를 따라 각 노드에 적용할 수 있는 가장 일반적인 규칙부터 시작해 추가적인 스타일을 적용합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;body { font-size: 16px; }
p { font-weight: bold; }
span { display: none; }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;예를 들면, &lt;code&gt;&amp;#x3C;p&gt;&lt;/code&gt;는 &lt;code&gt;&amp;#x3C;body&gt;&lt;/code&gt;의 자식이니까 &lt;code&gt;&amp;#x3C;body&gt;&lt;/code&gt;에 적용된 스타일인 &lt;code&gt;font-size: 16px;&lt;/code&gt;가 적용됩니다. 그 다음에는 자기 자신의 스타일인 &lt;code&gt;font-weight: bold;&lt;/code&gt;가 추가로 적용됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bb73360d8dd76d980020bd9ef7593cd1/bbbf7/css.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABHUlEQVR42o2QbWvCMBSF+/9/lmyDwdQPzpXZrXRSa9WZ2DTNe3LGjSAMhuxCPtyXPJxzCtyplBKmaYK1FsYYaK2gXcTuJNF0DM2OozsphJhuf4p7wBBCBlVVhbqu4azBkU1YvDM8r3ZYlD3KZoB1/wTGGKGUAmMMwzBAqQnOB0iToB05oJuUndwF0gGpk1JmoNY6KyX71APpSvujiiO3eN30WFd7rKoDum9zg3DOM4gydM5hHEe0bZv39PZni9Vmj3XV460+4yw8iu1B42G5xezlE0/LL3y0IisjgBAC3vsMpf5yuaAsy9yPo0TdaczmDR4XDeblET3zKMQU0PMIoRJ8TDAu/oKQUrJPM1JKudKOZlx69PyaqQ8RxgX8ANIpHMsSVyDUAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;css tree&quot;
        title=&quot;&quot;
        src=&quot;/static/bb73360d8dd76d980020bd9ef7593cd1/984b6/css.png&quot;
        srcset=&quot;/static/bb73360d8dd76d980020bd9ef7593cd1/4d6f2/css.png 158w,
/static/bb73360d8dd76d980020bd9ef7593cd1/3c1ae/css.png 315w,
/static/bb73360d8dd76d980020bd9ef7593cd1/984b6/css.png 630w,
/static/bb73360d8dd76d980020bd9ef7593cd1/e7d8e/css.png 945w,
/static/bb73360d8dd76d980020bd9ef7593cd1/58c38/css.png 1260w,
/static/bb73360d8dd76d980020bd9ef7593cd1/bbbf7/css.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다만 아직 위의 트리는 완전한 CSSOM 트리가 아니에요! 사실 브라우저들은 저마다 기본으로 제공하는 스타일이 있습니다. 개발자 도구를 열어보면 우리가 정의하지 않은 속성이 user agent stylesheet에서 적용된 걸 볼 수 있어요.&lt;/p&gt;
&lt;h4&gt;CSS 속독 비법: 오른쪽부터 읽기&lt;/h4&gt;
&lt;p&gt;참, 브라우저는 CSS를 빠르게 파싱하기 위해 오른쪽에서 왼쪽으로 읽는다는 사실 아셨나요?! RTL(right-to-left) 파싱 또는 상향식 파싱이라고 하며 말 그대로 셀렉터의 오른쪽(자식)부터 왼쪽(부모)으로 거슬러 올라가며 읽습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;header div h1 p span { color: red; }
header span.text { color: red; }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 두 개의 규칙이 있습니다. 스타일을 계산할 때 어느 쪽이 더 빠를까요?&lt;/p&gt;
&lt;p&gt;사실 웬만한 모던 브라우저는 CSS 선택자 매칭 최적화가 되어 있어 이 정도로 큰 차이는 없겠지만 일단 이론상으로는 후자가 좀 더 빠릅니다.&lt;/p&gt;
&lt;p&gt;전자는 span부터 시작해, p, h1 등을 거슬러 올라가 header까지 일치하는지 확인해야 합니다. 브라우저가 DOM 트리를 순회하며 요소를 확인해야 하는데, DOM 트리가 크거나 복잡한 경우 속도가 느려질 수 있어요.&lt;br/&gt;
후자는 클래스 셀렉터를 쓰고 있는데, 이렇게 하면 DOM 트리를 탐색할 필요 없이 렌더링 엔진이 알아서 빠르게 인덱싱을 하기 때문에 상대적으로 더 빠릅니다.&lt;/p&gt;
&lt;p&gt;이렇게 오른쪽부터 읽는 이유는 스타일을 계산해야 하는 요소는 하나인데 읽어야 하는 규칙은 산더미처럼 많기 때문입니다. 가장 오른쪽부터 시작해서 일치하는지 않는지 먼저 빠르게 판단하면 나머지 셀렉터는 읽지 않고 다음 판단으로 넘어갈 수 있습니다.
왼쪽부터 읽어야 한다면 DOM 트리 탐색을 위해 전체 HTML을 스캔해서 갖고 있어야 할 수도 있겠죠.&lt;/p&gt;
&lt;p&gt;또, 각 브라우저별 렌더링 엔진이 가진 최적화 기술도 RTL 파싱에 적합한 매커니즘을 갖고 있다고 합니다. 하지만 이제 모던 브라우저는 성능이 짱짱하기에 셀렉터 최적화에 너무 매달릴 필요는 없을 것 같네요.&lt;/p&gt;
&lt;h3&gt;(3) 삐빅, 렌더 트리 구성하는 중··· 🌳&lt;/h3&gt;
&lt;p&gt;HTML과 CSS를 읽어 DOM 트리와 CSSOM 트리를 구성했으면, 이제 둘을 결합시켜 렌더 트리를 만들 차례입니다. 렌더 트리는 화면에 실제로 표시되는 시각적 요소를 계층적으로 나타낸 것으로, 얘도 ROM(Render Object Model)이라 부르기도 합니다.&lt;/p&gt;
&lt;p&gt;브라우저는 아래와 같은 단계를 거쳐 렌더 트리를 구성합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM 트리의 루트(document)에서 시작해서 렌더링할 노드를 찾아냅니다.&lt;/li&gt;
&lt;li&gt;각 노드에 일치하는 CSSOM 규칙을 찾아 적용합니다.&lt;/li&gt;
&lt;li&gt;이제 콘텐츠와 스타일을 결합해 가시적인(visible) 노드를 구성합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d339153b6e64d8decde5b9606a9193b9/53c9c/tree.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.70886075949367%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvLgNgIor/xAAXEAADAQAAAAAAAAAAAAAAAAABEDEA/9oACAEBAAEFAkELjF//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAACAwEBAAAAAAAAAAAAAAAAAREhMRBB/9oACAEBAAE/IfZHaGoeEqS3zQWc/9oADAMBAAIAAwAAABAT4ID/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAgEBPxAp/8QAHxAAAgIBBAMAAAAAAAAAAAAAAREAITEQQVFxocHw/9oACAEBAAE/EDxYq+IqtjRmKEgUPnM9qooiAW4HoaeAZg60/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;dom cssom rom&quot;
        title=&quot;&quot;
        src=&quot;/static/d339153b6e64d8decde5b9606a9193b9/af1fa/tree.jpg&quot;
        srcset=&quot;/static/d339153b6e64d8decde5b9606a9193b9/ab180/tree.jpg 158w,
/static/d339153b6e64d8decde5b9606a9193b9/ba98e/tree.jpg 315w,
/static/d339153b6e64d8decde5b9606a9193b9/af1fa/tree.jpg 630w,
/static/d339153b6e64d8decde5b9606a9193b9/23301/tree.jpg 945w,
/static/d339153b6e64d8decde5b9606a9193b9/53c9c/tree.jpg 1045w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;핵심은 눈에 보이는 시각적 요소만 포함한다는 점&lt;/strong&gt;입니다. 예를 들어, &lt;code&gt;display: none&lt;/code&gt;이 적용된 DOM 요소는 화면에 렌더링되지 않으므로 렌더 트리에 포함되지 않습니다.
마찬가지로 &lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;이나 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;도 시각적인 내용이 없기 때문에 생략됩니다.&lt;br/&gt;
위 이미지에서도 &lt;code&gt;&amp;#x3C;span&gt;&lt;/code&gt;은 &lt;code&gt;display: none&lt;/code&gt;이 적용됐기에 자식인 텍스트 노드(&quot;World&quot;)는 렌더 트리에서 제외됐어요. 마찬가지로 &lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;이나 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;도 시각적인 내용이 없기 때문에 생략된 걸 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;덧붙여 &lt;code&gt;:before&lt;/code&gt; 및 &lt;code&gt;:after&lt;/code&gt;로 만든 가상 요소는 DOM 요소는 아니지만 화면에 렌더링되므로 렌더 트리에 포함됩니다.&lt;/p&gt;
&lt;h3&gt;(4) 삐빅, 설계도 만드는 중··· 📐&lt;/h3&gt;
&lt;p&gt;지금까지의 흐름을 거쳐 &apos;그려내야 할 것&apos;을 알아냈습니다. 그럼 이제 이대로 화면에 그리면 되는 걸까요? 사실··· 할 일이 더 있습니다.
구체적으로 어디에 얼마만큼 그려야 하는지 아직 모르기 때문입니다.&lt;br/&gt;
예를 들어 &lt;code&gt;width: 50%&lt;/code&gt;는 어떤 부모를 기준으로 한 건지, &lt;code&gt;font-size: 4em&lt;/code&gt;은 어디서부터 계산해야 하는지 아직은 알 수 없어요. 그래서 브라우저는 렌더 트리의 루트부터 시작해
각각의 정확한 위치와 크기를 알아내야 합니다. &quot;width: 50%는 250px이고, font-size: 4em은 22px이군&quot;하고 정확하게 파악하는 거죠.&lt;/p&gt;
&lt;p&gt;이 과정을 &lt;strong&gt;&apos;Layout(레이아웃)&apos; 또는 &apos;Reflow(리플로우)&apos;&lt;/strong&gt; 라고 부릅니다. 최종적인 설계도를 그리는 단계라 할 수 있겠네요!&lt;/p&gt;
&lt;p&gt;브라우저는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model&quot;&gt;box model&lt;/a&gt;에 따라 페이지에서 노드가 차지하는 박스를 만들고, 이를 트리 형태로 구조화합니다.
그리고 각 박스의 크기와 위치를 계산해서 페이지의 레이아웃을 구성합니다.&lt;/p&gt;
&lt;h3&gt;(5) 삐빅, 화면을 그리는 중··· 🎨&lt;/h3&gt;
&lt;p&gt;드디어 웹 페이지에 화면을 그릴 수 있습니다! (마침내!)&lt;br/&gt;
레이아웃 단계가 끝나면 &lt;strong&gt;렌더링 트리를 화면의 픽셀로 변환하는 &apos;페인트(Paint)&apos; 이벤트가 실행됩니다.&lt;/strong&gt; 여기서도 브라우저는 화면에 그려낼 요소를 트리 형태로 구조화하며, 이를 페인트 트리라고 부릅니다.&lt;/p&gt;
&lt;h4&gt;합성 단계&lt;/h4&gt;
&lt;p&gt;화면에 그려내야 하는 단계인 만큼, &apos;페인트&apos; 단계는 렌더링 엔진이 가장 바쁜 구간입니다. 특히 그림자나 그라디언트 같은 렌더링은 페인팅하는 데 시간이 걸리는 비싼 작업이죠.&lt;br/&gt;
그래서 이때 보다 &lt;strong&gt;효율적인 렌더링을 위해 &apos;합성(Composite)&apos; 이라는 과정&lt;/strong&gt;을 거칩니다.&lt;/p&gt;
&lt;p&gt;합성은 렌더링 파이프라인의 레이아웃 및 페인팅 단계 후에 발생합니다. 최종적으로 보여질 화면을 위해 웹 페이지의 여러 요소를 결합하거나 투명도 효과를 적용합니다. &lt;code&gt;z-index&lt;/code&gt;, &lt;code&gt;opacity&lt;/code&gt; 같은 값을 렌더링에 적용하는 거죠.
크롬의 경우, 컴포지터 스레드(compositor thread)라는 별도 스레드가 합성을 담당합니다.&lt;/p&gt;
&lt;h4&gt;레이어로 나누면 편하니까&lt;/h4&gt;
&lt;p&gt;이때 요소를 &lt;strong&gt;&apos;레이어&apos;로 분리하여 관리하기 위해 레이터 트리(Layer Tree)를 생성&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;p&gt;어도비 포토샵을 써보셨으면 레이어 패널에서 눈을 끄거나 켜면서 레이어를 관리한 경험이 있으실 텐데 그것과 비슷합니다!
예를 들어 사이드 네비게이션 바가 열린 화면을 그려야 하는 경우를 생각해 봅시다.
기존 메인 화면 위에 그려도 되지만, 레이어 위에 네비게이션 바를 그려서 합성하는 게 훨씬 효율적입니다.
네비게이션을 닫는다고 해도 해당 레이어에만 변화가 일어나니 전체를 다시 렌더링 할 필요도 없죠!&lt;/p&gt;
&lt;p&gt;이렇게 웹 페이지를 몇 개의 레이어로 나눈 뒤 컴포지터 스레드에서 각각을 칠하고 합성하면 빠르고 효율적으로 작업을 끝낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;레이어 분리 상황을 보고 싶다면 크롬 개발자 도구의 Layers 탭에서 확인할 수 있습니다. 세부사항을 보면 합성 원인도 확인할 수 있어요.
만약 해당 패널이 보이지 않는다면, &lt;code&gt;Cmd(Ctl)+P&lt;/code&gt;로 검색 창을 띄운 뒤 &lt;code&gt;&gt;Layers&lt;/code&gt;를 입력하세요!&lt;/p&gt;
&lt;h4&gt;하드웨어··· 가속!!!&lt;/h4&gt;
&lt;p&gt;혹시 하드웨어 가속에 대해 들어보셨나요?? 여기서는 CPU가 처리하기 어려운 복잡한 작업을 &lt;strong&gt;GPU에서 처리하도록 하여 성능 향상을 끌어내는 것&lt;/strong&gt;을 말합니다.
GPU는 그래픽 렌더링과 병렬 처리에 최적화되어 있기 때문에 복잡한 그래픽 작업을 보다 효율적으로 처리합니다.
&lt;strong&gt;CSS 속성으로 transfrom, opcity 속성을 사용하면 GPU에서 처리되어 더 부드럽게 애니메이션을 표현할 수 있습니다.&lt;/strong&gt;
그 외에 canvas나 WebGL도 하드웨어 가속으로 처리됩니다.&lt;/p&gt;
&lt;p&gt;사실 레리어도 세분화해서 나뉘어지지만, 여기서는 하드웨어 가속을 사용하여 처리하는 그래픽 레이어를 가리킵니다.
레이어가 생성되면 일반적으로 하드웨어 가속이 발생하고, GPU에서 레이어들을 합성하여 최종 이미지를 생성합니다.&lt;br/&gt;
하지만 trnasform, opacity 속성을 쓴다고 항상 레이어가 생성되어 하드웨어 가속이 발생하는 것은 아닙니다. 레이어를 관리하는 데는 비용이 들기 때문에
브라우저는 자기 마음대로(=최적화 상황에 따라) 레이어를 만들지 않거나 서로 합치기도 합니다. 하지만 대부분의 경우는 렌더링 성능을 향상시킬 수 있기에 최대한
하드웨어 가속 속성을 써서 전환 효과를 만드는 것이 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;.slide {
   will-change: transform;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 필요하다면 &lt;code&gt;will-change&lt;/code&gt;라는 속성을 써서 브라우저에게 해당 요소를 레이어로 승격시키고 하드웨어 가속을 쓰고 싶다고 말할 수도 있습니다.
하지만 이 경우에도 적용할지 여부는 브라우저 마음이라는 점!&lt;/p&gt;
&lt;h4&gt;최적화 = 일 덜 시키기&lt;/h4&gt;
&lt;p&gt;화면을 그리기 위해 렌더링 엔진은 &lt;strong&gt;Layout =&gt; Paint =&gt; Composite&lt;/strong&gt; 이라는 과정을 거친다는 것을 알았습니다.
그렇다는 건 화면에 변화가 일어났을 때 해당 영역에서 저 과정을 반복한다는 셈이죠.
그래서 &lt;strong&gt;성능 최적화를 위해서는 레이아웃이나 페인트를 발생시키는 상황을 줄이는 것이 좋습니다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이른바 리플로우/리페인트라고 부르는, &apos;다시 그리는 비용&apos;을 줄이려면 위 파이프라인에서 합성만 발생하는 것이 가장 좋고요!
즉, 렌더링 엔진에게 일을 덜 시키면 됩니다. 요 내용은 나중에 프레임 최적화를 배울 때 더 살펴보겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;요약&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;국내 브라우저 TOP3 : 1) 크롬  2) 사파리  3) 삼성 인터넷&lt;/li&gt;
&lt;li&gt;브라우저의 렌더링 엔진이 HTML과 CSS를 해석해서 화면을 그려준다.
&lt;ul&gt;
&lt;li&gt;크롬은 Blink, 사파리는 Webkit, 파이어폭스는 Gecko 엔진을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;렌더링 과정&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;① HTML 해석 후 DOM 트리 구성&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;② CSS 해석 후 CSSOM 트리 구성&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;③ DOM + CSSOM 결합하여 렌더 트리 구성&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;④ 레이아웃 계산&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;⑤ 페인트 및 레이어 합성&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3&gt;에필로그&lt;/h3&gt;
&lt;p&gt;브라우저가 웹 페이지를 표시하려면 제법 긴 과정을 거쳐야 한다는 걸 알았습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 리소스 가져오기&lt;br/&gt;
② 파싱&lt;br/&gt;
③ DOM 트리 &amp;#x26; CSSOM 트리 구성&lt;br/&gt;
④ 렌더 트리 구성&lt;br/&gt;
⑤ 레이아웃 계산&lt;br/&gt;
⑥ 페인팅 &amp;#x26; 합성&lt;br/&gt;
⑦ 렌더링&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 &lt;strong&gt;&apos;주요 렌더링 경로(CRP; Critical Rendering Path)&apos;&lt;/strong&gt; 라고도 부릅니다. 말그대로 사용자에게 꼭 필요한 화면을 렌더링하는 데 필요한 흐름입니다.&lt;/p&gt;
&lt;p&gt;그럼 이쯤 드는 생각:
&quot;브라우저가 렌더링을 하는 방법을 알았으니, 이제 어떻게 렌더링 최적화를 할 수 있을지 궁금한데...&quot;&lt;/p&gt;
&lt;p&gt;그래서 CRP를 최적화하는 것을 포함해 브라우저가 이미지, 애니메이션 등 리소스를 표현할 때 어떻게 성능 최적화를 할 수 있을지 이제부터 알아봅니다!(빠밤)&lt;br/&gt;
결국 우리의 목적은 웹 페이지를 빠르게 그려내고 상호 작용할 수 있도록 해서 유저의 체감 성능을 높이는 거니까요.😉&lt;/p&gt;
&lt;p&gt;그럼, 다음 포스팅도 기대해주세요! 끝까지 읽어주셔서 감사합니다 🙇‍♀️&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프론트엔드 면접 준비 노트 (JavaScript)]]></title><description><![CDATA[Reference: 지금까지 받았던 신입 프론트엔드 면접 질문들 by arthur 개인 스터디 글로, 맞지 않는 내용이 있다면 피드백은 대 환영입니다 👼✨ 자바스크립트는 무슨 언어인가요? 자바스크립트는 본래 브라우저를 제어하는 언어였으나, Node…]]></description><link>https://kirahaa.github.io/fe-interview-js/</link><guid isPermaLink="false">https://kirahaa.github.io/fe-interview-js/</guid><pubDate>Tue, 01 Aug 2023 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Reference: &lt;a href=&quot;https://velog.io/@arthur/%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80-%EB%B0%9B%EC%95%98%EB%8D%98-%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%93%A4#%EC%82%AC%EC%84%A4&quot;&gt;지금까지 받았던 신입 프론트엔드 면접 질문들 by arthur&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;개인 스터디 글로, 맞지 않는 내용이 있다면 피드백은 대 환영입니다 👼✨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;자바스크립트는 무슨 언어인가요?&lt;/h3&gt;
&lt;p&gt;자바스크립트는 본래 브라우저를 제어하는 언어였으나, &lt;strong&gt;Node.js&lt;/strong&gt;라는 새로운 실행환경과 구글 V8엔진의 등장으로 자체 어플리케이션을 만들 수 있게 된 언어입니다.&lt;br/&gt;
또한 자바스크립트는 명령형, 함수형, 객체지향 프로그래밍이 모두 가능한 멀티 패러다임 언어입니다.&lt;/p&gt;
&lt;h3&gt;변수 선언, 초기화, 할당의 차이점에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;변수는 &lt;strong&gt;선언 =&gt; 초기화 =&gt; 할당&lt;/strong&gt; 단계를 거칩니다.&lt;/p&gt;
&lt;p&gt;변수 선언은 변수를 생성하는 것을 의미합니다. 변수명(식별자)을 등록하여 스코프가 참조할 대상을 만듭니다.&lt;br/&gt;
초기화는 메모리에 변수 저장을 위한 공간을 확보하는 단계입니다. 기본값으로 &lt;strong&gt;undefined&lt;/strong&gt;가 할당됩니다.&lt;br/&gt;
할당은 &lt;strong&gt;=&lt;/strong&gt; 연산자를 사용하여 값을 할당하는 단계로, &lt;strong&gt;undefined&lt;/strong&gt;로 초기화된 변수에 실제 값을 할당해주는 단계입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var name;  // 변수 선언
var name;  // 변수 선언 =&amp;gt; 초기화
console.log(name);  // undefined

name = &amp;#39;hayeong&amp;#39;;  // 변수 할당
console.log(name);  // hayeong&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;데이터 타입에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;Javascript의 타입은 &lt;strong&gt;원시 타입&lt;/strong&gt;과 &lt;strong&gt;객체 타입&lt;/strong&gt;으로 나뉩니다.&lt;/p&gt;
&lt;p&gt;원시 타입은 불변값이라고도 부르며, &lt;strong&gt;string&lt;/strong&gt;, &lt;strong&gt;number&lt;/strong&gt;, &lt;strong&gt;boolean&lt;/strong&gt;, &lt;strong&gt;undefined&lt;/strong&gt;, &lt;strong&gt;null&lt;/strong&gt;, &lt;strong&gt;symbol&lt;/strong&gt; 총 6가지 데이터 타입이 있습니다.&lt;br/&gt;
객체는 원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등) 모두 객체에 해당되며, 참조형 타입이라고도 부릅니다.&lt;/p&gt;
&lt;h3&gt;생성자에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;생성자 함수란 &lt;strong&gt;new&lt;/strong&gt; 연산자와 함께 호출하여 객체를 생성하는 함수를 의미합니다.&lt;br/&gt;
생성자 함수에 의해 생성된 객체를 인스턴스라하며, 자바스크립트는 &lt;strong&gt;Object&lt;/strong&gt; 외에도 다양한 타입의 빌트인 생성자 함수를 제공합니다.&lt;br/&gt;
생성자 함수는 일반 함수와 동일한 방법으로 정의하지만, 파스칼 케이스를 사용하는 관례를 따릅니다.&lt;/p&gt;
&lt;h3&gt;this에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt; 키워드는 자신이 속한 객체를 가리키는 식별자를 참조할 수 있는 키워드입니다.&lt;br/&gt;
&lt;strong&gt;this&lt;/strong&gt;는 함수가 호출되는 방식에 따라 달라집니다.&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반 함수 호출을 사용할 경우 기본적으로 전역 객체가 바인딩됩니다.&lt;/li&gt;
&lt;li&gt;메서드 호출을 할 경우, 마침표 연산자 앞에 기술한 객체가 바인딩됩니다.&lt;/li&gt;
&lt;li&gt;생성자 함수 호출을 할 경우, 미래에 생성할 인스턴스가 바인딩됩니다.&lt;/li&gt;
&lt;li&gt;화살표 함수는 &lt;strong&gt;this&lt;/strong&gt;가 없기 때문에, 선언될 시점에서의 상위 스코프가 바인딩됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;call, apply, bind에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;이 세가지 메서드는 강제로 &lt;strong&gt;this&lt;/strong&gt;를 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;call&lt;/strong&gt;은 커스텀 this를 지정할 수 있고, &lt;strong&gt;apply&lt;/strong&gt;는 call과 유사하지만 인자로 배열을 받는다는 점에서 차이가 있습니다.&lt;br/&gt;
&lt;strong&gt;bind&lt;/strong&gt;는 커스텀 this를 영구히 가지는 함수를 만들 수 있습니다.&lt;/p&gt;
&lt;h3&gt;콜백 함수에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;콜백 함수는 다른 함수의 인자로 넘겨지는 함수를 말합니다.&lt;br/&gt;
콜백 함수는 일반적으로 비동기적인 상황에서 사용되며, 어떤 작업이 완료되거나 특정 이벤트가 발생했을 때 호출됩니다.&lt;/p&gt;
&lt;h4&gt;콜백 지옥을 해결하는 방법을 설명해주세요.&lt;/h4&gt;
&lt;p&gt;콜백 지옥은 비동기 처리 로직을 위해 콜백 함수를 연속으로 중첩하여 사용할 때 발생하는 문제입니다.&lt;br/&gt;
콜백 지옥을 해결하는 방법에는 &lt;strong&gt;Promise&lt;/strong&gt;나 &lt;strong&gt;Async&lt;/strong&gt;가 있습니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;는 비동기 연산이 종료된 이후에 결과를 알기 위해 사용하는 객체입니다.&lt;br/&gt;
&lt;strong&gt;Promise&lt;/strong&gt;의 &lt;strong&gt;.then&lt;/strong&gt;을 사용해 함수 실행 순서를 정할 수 있습니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;ES8에서 도입된 &lt;strong&gt;async&lt;/strong&gt;, &lt;strong&gt;await&lt;/strong&gt;을 사용하면 비동기 함수를 마치 동기적 코드인 것처럼 동작하도록 구현이 가능합니다.&lt;br/&gt;
&lt;strong&gt;async&lt;/strong&gt;함수는 &lt;strong&gt;async&lt;/strong&gt; 함수 안에서만 동작하며, &lt;strong&gt;await&lt;/strong&gt; 키워드를 쓰게 되면 해당 값이 반환 되기 전까지 기다리는 동안 &lt;strong&gt;async&lt;/strong&gt; 내부 함수는 일시 중단이 됩니다.&lt;/p&gt;
&lt;h3&gt;Promise에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;는 비동기 처리를 간편하게 처리할 수 있도록 도와주는 객체로, 성공 또는 실패 상태를 가집니다.&lt;br/&gt;
비동기 작업이 완료되면 &lt;strong&gt;resolve(성공)&lt;/strong&gt; 또는 &lt;strong&gt;reject(실패)&lt;/strong&gt; 로 결과를 처리할 수 있습니다. 이렇게 처리된 결과는 &lt;strong&gt;then&lt;/strong&gt;과 &lt;strong&gt;catch&lt;/strong&gt; 메서드를 이용하여 다음 동작을 연결할 수 있습니다.
이를 통해 비동기 코드를 더 구조적이고 유지보수하기 좋게 작성할 수 있으며, 에러 처리 등을 통해 안정적인 프로그래밍을 할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;Promise.all()에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;Promise.all()은 자바스크립트의 Promise 메서드로, 여러 개의 Promise 객체를 받아 모든 Promise가 완료될 때까지 기다린 뒤, 그 결과들을 배열로 반환합니다.&lt;br/&gt;
모든 Promise가 성공적으로 처리되면 배열에는 각 Promise의 성공 결과 값이 순서대로 들어가며, 하나라도 실패하면 첫 번째 실패한 Promise의 에러를 반환합니다.&lt;/p&gt;
&lt;h3&gt;Promise와 Callback을 비교 설명해주세요.&lt;/h3&gt;
&lt;p&gt;Callback은 비동기 작업 완료 후 실행되는 함수로, 가독성과 유지보수에 어려움이 있을 수 있습니다.&lt;br/&gt;
Promise는 ES6에서 도입된 비동기 처리 객체로, 콜백 지옥을 피하고 더 편리한 비동기 작업을 가능하게 해줍니다.&lt;br/&gt;
성공 또는 실패 시 다른 처리를 할 수 있고, 여러 개의 비동기 작업을 체이닝하여 순차적 또는 병렬로 실행할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;Promise와 Async, Await의 차이를 설명해주세요.&lt;/h3&gt;
&lt;p&gt;Promise는 비동기 작업을 처리하는 객체로, then과 catch를 사용하여 결과를 다룹니다.&lt;br/&gt;
Async/Await은 Promise를 더 간결하고 직관적으로 사용하기 위한 문법으로, async 함수와 await 키워드를 사용합니다.&lt;br/&gt;
비동기 작업의 결과를 변수에 할당하거나 다른 함수에서 사용하기 용이하며, try-catch 문으로 예외 처리를 간편하게 할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;AJAX에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;AJAX는 웹 페이지에서 비동기적으로 서버와 데이터를 주고받는 기술로, 페이지 새로고침 없이 동적으로 내용을 갱신하거나 데이터를 로드할 수 있게 해주는 기술입니다.
Javascript를 사용하여 비동기 통신을 수행하며, 사용자 경험을 향상시키고 웹 페이지의 속도와 효율성을 개선합니다.&lt;/p&gt;
&lt;h3&gt;var, let, const 차이를 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;var&lt;/strong&gt;는 함수 스코프를 가집니다. 변수를 중복 선언해도 오류가 발생하지 않고, 똑같은 이름으로 여러번 선언되면 마지막 선언이 유효합니다.
호이스팅 현상이 발생하여 변수가 선언되기 전에도 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;let&lt;/strong&gt;과 &lt;strong&gt;const&lt;/strong&gt;는 중복 선언이 불가능 하며, 블록 스코프를 가집니다. &lt;br/&gt;
&lt;strong&gt;let&lt;/strong&gt;은 값이 변경될 수 있는 변수를 선언할 때 사용하고, &lt;strong&gt;const&lt;/strong&gt;는 값이 변경되지 않을 변수를 선언할 때 사용합니다.&lt;/p&gt;
&lt;p&gt;일반적으로 let과 const를 사용하여 변수를 선언하고, var는 최신 버전의 Javascript에서는 피하는 것이 좋습니다.&lt;/p&gt;
&lt;h4&gt;TDZ에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;TDZ(Temporal Dead Zone)의 약어로, 변수가 선언되었지만 해당 변수를 사용할 수 없는 현상을 가리킵니다.
TDZ는 변수가 선언되고 초기화되기 전까지의 영역을 의미하는데, ES6의 let과 const는 변수를 블록의 상단으로 호이스팅하지만 초기화하지는 않기 때문에 이런 현상이 발생합니다.&lt;/p&gt;
&lt;h3&gt;함수 선언문과 함수 표현식의 차이에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;함수 선언문은 &lt;code&gt;function add(x, y){}&lt;/code&gt;의 형태로 쓰여지며, 완료시 undefined가 출력됩니다. 이때, 이름을 생략할 수 없습니다.&lt;/p&gt;
&lt;p&gt;함수 표현식은 &lt;code&gt;const add = function(x, y) {}&lt;/code&gt;의 형태로 쓸 수 있으며, 함수 리터럴의 함수 이름을 생략할 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생하기 때문에 표현식 이전에 호출할 수 없지만, 함수 선언문으로 정의하면 함수 선언문 이전에 호출할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;이벤트 버블링과 캡처링에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;이벤트 버블링과 이벤트 캡처링은 브라우저에서 이벤트가 발생했을 때 이벤트가 어떻게 전달되는지를 설명하는 개념입니다.&lt;/p&gt;
&lt;p&gt;이벤트 버블링은 자식 요소에 등록된 이벤트 핸들러가 먼저 실행된 후 부모 요소의 핸들러가 실행하는 것을 말합니다. 가장 일반적으로 사용됩니다.&lt;/p&gt;
&lt;p&gt;이벤트 캡쳐링은 이벤트가 발생한 부모 요소의 핸들러가 먼저 실행된 후 자식 요소에 등록된 핸들러가 실행됩니다.&lt;/p&gt;
&lt;p&gt;이벤트 버블링과 캡쳐링은 이벤트의 전파 방향이 다르므로 이를 이용하여 이벤트를 효율적으로 처리할 수 있습니다. 만약 이벤트 전파를 중단하고 싶다면, &lt;code&gt;event.stopPropagation()&lt;/code&gt; 메서드를 사용하면 됩니다.&lt;/p&gt;
&lt;h4&gt;이벤트 위임에 대해서 설명해주세요.&lt;/h4&gt;
&lt;p&gt;이벤트 위임은 상위 요소에 하나의 이벤트 핸들러를 등록하여 하위 요소들의 이벤트를 한 번에 처리하는 기술입니다.
많은 수의 하위 요소에 각각 이벤트 핸들러를 등록하는 것보다 메모리 사용을 줄이고 코드를 간결하게 만들어줍니다.
상위 요소에서 이벤트가 발생하면 이벤트가 해당 요소의 하위 요소들까지 전파되어 처리됩니다.
이를 통해 동적으로 생성된 하위 요소들에 대해서도 하나의 핸들러로 처리할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;이벤트 위임의 동작 방식에 대해서 설명해주세요.&lt;/h4&gt;
&lt;p&gt;우선 상위 요소에 이벤트 핸들러를 등록합니다. 하위 요소에서 이벤트가 발생하면 이벤트는 먼저 해당 요소에서 시작하여 상위 요소로 전파됩니다.
이벤트가 상위 요소까지 전파되면 상위 요소에 등록된 이벤트 핸들러가 이벤트를 캐치하여 처리합니다. 이때 &lt;strong&gt;event.target&lt;/strong&gt; 속성을 사용하여 이벤트가 발생한 실제 요소를 식별할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;호이스팅과 발생하는 이유에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;호이스팅은 Javascript 엔진이 코드를 실행하기 전에 변수와 함수 선언을 스코프의 상단으로 끌어올리는 현상입니다.
호이스팅이 발생하는 이유는 Javascript 엔진이 코드를 실행하기 전에  선언된 변수와 함수의 선언부를 미리 메모리에 할당하기 때문입니다.
이렇게 선언들이 끌어올려지는 동작으로 인해 해당 변수와 함수를 선언 이전에 사용할 수 있게 되는데, 이것이 호이스팅의 원리입니다.
이러한 동작은 실행 컨텍스트(Execution Context)가 형성되는 과정에서 일어나며, 변수와 함수의 선언부를 메모리에 먼저 올려놓는 것으로 이해할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;스코프(Scope)에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;스코프는 변수와 함수에 접근할 수 있는 유효한 영역을 나타냅니다. 즉, 변수와 함수가 어디에서 정의되고 어디에서 참조될 수 있는지를 결정하는 규칙입니다.&lt;br/&gt;
Javascript에는 전역 스코프와 지역 스코프가 있습니다. 변수와 함수가 스코프에 따라 유효한 영역이 결정되므로, 스코프의 관리는 변수의 생명주기와 충돌을 방지하는 데 중요한 역할을 합니다.&lt;/p&gt;
&lt;h3&gt;클로저(Closure)에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;클로저(Closure)는 반환된 내부 함수가 자신이 선언되었을 때의 환경(렉시컬 환경)인 스코프를 기억하여, 그 밖에서 호출되어도 해당 환경에 접근할 수 있는 함수를 의미합니다.&lt;/p&gt;
&lt;p&gt;이를 통해 전역 변수를 사용하지 않고도 함수 밖에서 해당 변수에 접근할 수 있는 방법을 만들어 주며, 이는 반환된 함수를 제외하면 외부에서 접근할 수 없으므로 마치 private 변수처럼 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;클로저는 다음 예시에서 처럼 내부에 선언된 함수가 외부 함수의 지역변수를 사용해줬을 때만 클로저라고 선언됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function outer() {
  let name = &amp;quot;hayeong&amp;quot;;
  if (true) {
    let city = &amp;quot;seoul&amp;quot;;
    console.log(city);
    console.log(name);
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const btn = document.querySelector(&amp;#39;button&amp;#39;)

btn.addEventListener(&amp;#39;click&amp;#39;, handleClick())

function handleClick() {
  let count = 0;
  return function() {
    count++
    return count
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;실행 컨텍스트에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 말합니다. 자바스크립트 엔진이 코드를 실행할 때, 실행 컨텍스트를 생성하여 코드를 평가하고 실행합니다.
실행 컨텍스트는 코드 실행에 필요한 여러 정보들을 담고 있으며, 함수 실행, 변수 및 함수 선언, 스코프 체인 등을 관리하는데 사용됩니다.&lt;/p&gt;
&lt;h4&gt;렉시컬 환경(Lexical Environment)에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;렉시컬 환경은 자바스크립트의 변수와 함수의 이름을 관리하는 공간이라고 생각하면 됩니다.
렉시컬 환경은 &lt;strong&gt;환경 레코드&lt;/strong&gt;와 &lt;strong&gt;외부 렉시컬 환경&lt;/strong&gt;으로 구성되어 있습니다.&lt;/p&gt;
&lt;p&gt;환경 레코드는 모든 지역변수를 프로퍼티로 저장하고 있는 객체입니다. this, 함수일 경우 매개변수도 포함됩니다.
외부 렉시컬 환경은 현재 렉시컬 환경보다 더 상위의 렉시컬 환경입니다.
현재 렉시컬 환경에서 원하는 변수를 찾지 못하면 현재 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 검색 범위를 확장하며, 이는 전역 렉시컬 환경까지 반복됩니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트에서 일어나는 데이터 형변환에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환되며, 이를 형 변환이라고 합니다.&lt;/p&gt;
&lt;p&gt;이는 원시값이 아닌 객체간에도 동작하는데, &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;를 사용하면 객체를 모든 종류로 형변환할 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 &lt;code&gt;toString()&lt;/code&gt;이나 &lt;code&gt;valueof()&lt;/code&gt;를 사용해서도 객체를 정해진 몇몇 타입으로 변환할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트가 동적 언어인 이유는 무엇인가요?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;여기서 동적 언어란 실행 중에 변수의 데이터 타입을 명시적으로 선언하지 않고도 변수의 타입이 자동으로 결정되며, 변수의 타입이 실행 도중에도 동적으로 변경될 수 있는 언어를 말합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자바스크립트는 &lt;strong&gt;런타임 시 변수의 타입이 결정&lt;/strong&gt;됩니다.&lt;/p&gt;
&lt;p&gt;즉, 소스가 빌드될 때 자료형이 결정되는 것이 아닌 실행 시 결정됩니다. 이를 통해 런타임까지 타입에 대한 결정을 끌고 갈 수 있지만,
실행 도중 변수에 예상치 못한 타입이 들어와 TypeError가 발생할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;프로토타입에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;자바스크립트의 모든 객체들은 메서드와 속성들을 상속받기 위한 템플릿으로써 프로토타입 객체를 갖습니다.
정확히 말하자면 상속되는 속성과 메서드들은 각 객체가 아니라 객체의 생성자의 &lt;strong&gt;prototype&lt;/strong&gt;이라는 속성에 정의되어 있습니다.
자바스크립트에서는 객체 인스턴스와 프로토타입간에 연결이 구성되며, 이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메서드를 탐색합니다.&lt;/p&gt;
&lt;h3&gt;깊은 복사와 얕은 복사에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;깊은 복사와 얕은 복사는 자바스크립트에서 객체를 복사할 때 발생하는 두 가지 다른 복사 방법을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;깊은 복사&lt;/strong&gt;는 원본 객체의 내용을 완전히 새로운 객체에 복사하는 것을 말합니다.
원본 객체와 복사된 객체가 완전히 분리되어 있어, 한쪽을 수정해도 다른 쪽에 영향을 주지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;얕은 복사&lt;/strong&gt;는 원본객체의 참조를 복사하는 것을 의미합니다. 원본 객체와 복사된 객체가 같은 객체를 참조하게 될 수 있으므로 한쪽을 수정하면
다른 쪽에도 영향을 줄 수 있습니다.&lt;/p&gt;
&lt;h3&gt;불변성을 유지하려면 어떻게 해야하나요?&lt;/h3&gt;
&lt;p&gt;불변성을 유지하기 위해서는 기존의 데이터를 변경하지 않고 새로운 데이터를 생성하고 조작해야 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spread 문법 사용: Spread 문법(...)을 활용하여 배열이나 객체를 새로운 배열이나 객체로 복사하고 수정합니다.&lt;/li&gt;
&lt;li&gt;Object.assign() 사용: &lt;code&gt;Object.assign()&lt;/code&gt; 함수를 사용하여 객체를 복사하고 수정합니다.&lt;/li&gt;
&lt;li&gt;JSON.parse(JSON.stringify(obj)) 사용: JSON.stringify는 객체를 json 문자열로 변환하는데, 이 과정에서 원본 객체와의 참조가 모두 끊어지기 때문에 깊은 복사가 가능해집니다. 이후 JSON.parse()를 통해 다시 자바스크립트 객체로 만들어주면 복사가 완료됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Blocking과 Non-Blocking에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Blocking&lt;/strong&gt; : 블로킹은 어떤 작업이 실행 중일 때, 다른 작업이 대기해야 하는 상황을 의미합니다. 즉, 하나의 작업이 끝날 때까지 다른 작업들은 대기해야 합니다.
일반적으로 동기적인 코드 실행 방식에서 블로킹이 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-Blocking&lt;/strong&gt; : 논블로킹은 어떤 작업이 실행 중일 때, 다른 작업들이 기다리지 않고 독립적으로 실행될 수 있는 상황을 의미합니다.
다른 작업들이 블로킹되지 않고 계속 진행될 수 있기 때문에 시스템의 응답성과 처리량이 향상될 수 있습니다. 일반적으로 비동기적인 코드 실행 방식에서 논블로킹이 나타납니다.&lt;/p&gt;
&lt;h3&gt;동기와 비동기에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;동기 작업&lt;/strong&gt;은 순차적으로 실행되며, 하나의 작업이 끝날 때까지 다음 작업이 실행되지 않습니다.
&lt;strong&gt;비동기 작업&lt;/strong&gt;은 작업이 완료되지 않아도 다음 작업을 실행하며, 작업의 완료는 콜백 함수나 프로미스 등을 통해 처리합니다.
여러 작업들이 동시에 실행될 수 있어 응답성이 향상되고 복잡한 작업을 처리할 때 유용합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트에서는 비동기적이고 논블로킹된 코드를 사용하여 여러 작업을 효율적으로 처리하고, 응답성을 향상시키는 것이 중요합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;블로킹 vs 논 블로킹&quot;과 &quot;동기 vs 비동기&quot;의 차이점은?&lt;/p&gt;
&lt;p&gt;비동기와 동기는 간단하게 &apos;&lt;strong&gt;코드의 순서랑 실행 순서가 일치하느냐&lt;/strong&gt;&apos;로 볼 수 있습니다.
블로킹과 논블로킹은 &apos;&lt;strong&gt;코드의 실행이 다른 코드의 실행을 막느냐&lt;/strong&gt;&apos;로 볼 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;ES6에서 새로 생긴 기능을 아는대로 말씀해주세요.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;블록 스코프, let, const&lt;/li&gt;
&lt;li&gt;클래스&lt;/li&gt;
&lt;li&gt;모듈&lt;/li&gt;
&lt;li&gt;화살표 함수&lt;/li&gt;
&lt;li&gt;매개변수 기본값&lt;/li&gt;
&lt;li&gt;템플릿 리터럴&lt;/li&gt;
&lt;li&gt;구조분해 할당(디스트럭처링)&lt;/li&gt;
&lt;li&gt;스프레드 연산자&lt;/li&gt;
&lt;li&gt;프로미스&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;undefined, null, undeclared를 비교해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;undefined&lt;/strong&gt;는 값이 할당되지 않았음을 의미합니다. 변수가 초기화 단계를 거치면 &lt;strong&gt;undefined&lt;/strong&gt;로 남아있게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;undeclared&lt;/strong&gt;는 변수 선언조차 되어있지 않은 상태를 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null&lt;/strong&gt;은 의도적으로 &lt;strong&gt;null&lt;/strong&gt;이라는 빈 값을 할당한 경우를 의미합니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트를 멀티 스레드처럼 사용하는 방법이 뭔가요? / 자바스크립트에서 비동기 로직이 어떻게 동작하는지 설명해주세요. (이벤트 루프)&lt;/h3&gt;
&lt;p&gt;Web API, Callback Queue, Event Loop 등을 통해 멀티 스레드처럼 보이게 하는 방법을 사용합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트는 싱글 스레드로 동작하며, 모든 작업이 하나의 메인 스레드에서 처리됩니다. 그러나 네트워크 요청, 파일 입출력, 타이머와 같은 작업은 시간이 걸리는 경우가 많습니다.
이를 위해 비동기 로직이 필요한데, 이를 통해 시간이 걸리는 작업을 백그라운드에서 처리하고, 동시에 다른 작업을 수행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;자바스크립트 엔진 내부에는 콜스택과 메모리힙이 잇고 그 외부에 브라우저일때 사용하는 webapi와 이벤트 루프, 콜백 큐가 추가되어 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;코드가 콜스택에 쌓이고 실행되면, 자바스크립트의 엔진은 비동기 작업을 webapi에 위임합니다.&lt;/li&gt;
&lt;li&gt;webapi는 해당 작업을 수행하고 콜백 함수를 이벤트 루프를 통해 태스크 큐에게 넘겨줍니다.&lt;/li&gt;
&lt;li&gt;이벤트 루프는 콜스택에 쌓인 함수가 없을 때, 태스크 큐에 대기하던 콜백 함수를 콜스택으로 넘겨줍니다.&lt;/li&gt;
&lt;li&gt;콜스택에 쌓인 콜백함수를 실행하고 콜스택에서 제거합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;만약 promise를 사용한다면, 마이크로태스크 큐를 사용합니다. 마이크로 태스크 큐는 태스크 큐보다 우선순위가 높은 큐로, 태스크 큐에 대기중인 함수가 있더라도,
마이크로 태스크 큐가 비어있지 않다면, 마이크로 태스크 큐에 대기중인 함수부터 콜스택으로 전달합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9060ff03638b21ebada26e9d108f9854/3e3fe/async.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 66.45569620253164%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC0UlEQVR42l2S347bVBDG8xo8QivEBRdVr5CoxJ9KRSpFRUgsV0hQCQlueYrecAPXPACttIu6JdnuJtk0yTaCpYm79rETO7bj/Fk5ceLYJ+vYPxTvkhZG+o7mjOZ8Z2a+KSTmr8TlD5HPP0fWPrvCPeTxp7m/evE1q9Y3rFoPkI0dZO3u65w385/fJ4tcCon2kGj3LeKn7xDvX2NVusFF5Tby6ANk6Sby2XvI6ifI47vIyh3k4S3iw1tEh+8T/fEuyyfXWT65xnL/bdKwRyFb+WRhl3RpQmjj+3/S8w8g8liHFlnYIwvNSywtssiG2Aa5gQWRCbF56WcJBbaWQQpm2OMg+P0qkvGm/XvzL8CRIPwVDcPnbBLl9zCBgjtwMQwdwxD0ugZ6V0O3VSzTRAgNx+nn8cVisaX9ubPm/tOEH+sJP1QTvq8m3NtPKDkZBcdxGI1HmLqFrgl0Xcf3fUzTRFE6jIYj7FEftf8KbzlgTcAvCnxZWvNdNeXb8poHlZQviinFDeFwNER9pdI0y5zLGcPhmKOjQ6bTKfPFHKfvUlaKNCbPqAb7dOMX/PQSPtpb89VByk4pY6eU8vFeyp6VUfA8D0PTMVOT1csTwuGI+snJdm5BEHB2phLMgm3LrUnGIzOj6Kbs9pcUHfjNzOjNNxV6HkIXrJwQNJX5+Yh6s/k/wjNmweySLnstlD/3aAS7V9+k+ZlXKAyduGOjzDJGiyWNWo1gPs+FGAwGqKqK70/zh+t0TXql91ROOZ4V/7MLOaGqaaTJBW0fxrOQ42oFsRFICDrtNpoQWJaVixVFEUmS5L4QOobazTsYDodIKS8JNU1DxjL/IQxDKpUKhq7n2BBuFD89PeXxo8d4kY3oq5z+9XdO1G63883YjMZ1XQq2bdNqtWg06tSbJzSaTWq1GpVyeQtFUTAMA6WjcB6OsVwTfVOdYSCEoNfrMR6PmUwm/ANtzp+cozrmLAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;비동기로직&quot;
        title=&quot;&quot;
        src=&quot;/static/9060ff03638b21ebada26e9d108f9854/984b6/async.png&quot;
        srcset=&quot;/static/9060ff03638b21ebada26e9d108f9854/4d6f2/async.png 158w,
/static/9060ff03638b21ebada26e9d108f9854/3c1ae/async.png 315w,
/static/9060ff03638b21ebada26e9d108f9854/984b6/async.png 630w,
/static/9060ff03638b21ebada26e9d108f9854/3e3fe/async.png 860w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;태스크 큐(Task Queue)와 마이크로태스크 큐(Microtask Queue)는 자바스크립트의 비동기 처리 매커니즘에서 중요한 개념입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;태스크 큐&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;태스크 큐는 자바스크립트 엔진이 비동기 작업의 콜백 함수들을 기다리는 대기열입니다.&lt;/li&gt;
&lt;li&gt;비동기 작업의 콜백 함수나 이벤트 핸들러가 실행되어야 할 때, 해당 작업은 태스크 큐에 추가됩니다.&lt;/li&gt;
&lt;li&gt;이벤트 루프는 메인 스레드의 작업이 끝날 때마다 태스크 큐에서 콜백 함수를 꺼내와 실행시킵니다.&lt;/li&gt;
&lt;li&gt;대표적으로 &lt;strong&gt;setTimeout&lt;/strong&gt;, &lt;strong&gt;이벤트 핸들러&lt;/strong&gt;, &lt;strong&gt;AJAX 요청&lt;/strong&gt; 등이 태스크 큐에 추가됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;마이크로태스크 큐&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;마이크로태스크 큐는 태스크 큐와 유사하지만, 태스크 큐보다 우선순위가 높은 작업을 처리하는 대기열입니다.&lt;/li&gt;
&lt;li&gt;Promise의 &lt;strong&gt;then, catch, finally, await&lt;/strong&gt; 등과 같이 비동기 작업이 끝나면 가장 먼저 실행되어야 하는 작업들이 여기에 추가됩니다.&lt;/li&gt;
&lt;li&gt;마이크로태스크 큐의 작업이 모두 실행된 후에야 태스크 큐의 작업이 실행됩니다.&lt;/li&gt;
&lt;li&gt;이는 이벤트 루프에서 마이크로태스크 큐의 작업을 우선적으로 처리하는 원리입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;requestAnimationFrame에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;requestAnimationFrame은 브라우저 환경에서 사용되는 비동기적 웹 애니메이션을 실행하기 위한 메서드입니다.
이를 사용하면 브라우저의 리플로우와 리페인트 사이클에 맞게 애니메이션을 실행할 수 있어 부드럽고 성능 좋은 애니메이션을 구현할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;map, forEach, reduce에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt; 메서드는 배열의 각 요소를 변환하여 새로운 배열을 반환합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reduce&lt;/strong&gt; 메서드는 배열의 각 요소를 순회하면서 주어진 함수를 적용하여 하나의 결과값을 반환합니다. 초기값을 설정하여 특정 인덱스부터 실행할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;forEach&lt;/strong&gt; 메서드는 배열의 각 요소에 주어진 함수를 실행하고 반환값은 없습니다. 주로 반복문을 대체하는 용도로 사용되며, 배열을 순회하면서 각 요소에 대한 작업을 수행할 때 유용합니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트의 메모리 관리에 대해 아는 대로 설명해주세요.&lt;/h3&gt;
&lt;p&gt;자바스크립트는 &lt;strong&gt;가비지 컬렉션&lt;/strong&gt;이라는 메모리 관리 방법을 사용합니다.
대표적인 가비지 컬렉션 알고리즘으로 Mark and sweep 알고리즘이 있으며, 현재 모든 최신 엔진은 이 알고리즘을 사용한 가비지 컬렉션을 제공합니다.&lt;/p&gt;
&lt;p&gt;이 알고리즘은 더 이상 필요 없는 오브젝트를 닿을 수 없는 오브젝트로 정의합니다.&lt;/p&gt;
&lt;p&gt;이 알고리즘은 &lt;code&gt;roots&lt;/code&gt;라는 오브젝트의 집합을 가지고 있으며, 주기적으로 가비지 컬렉터는 &lt;strong&gt;roots&lt;/strong&gt;부터 시작하여, &lt;strong&gt;roots&lt;/strong&gt;가 참조하는 오브젝트들, &lt;strong&gt;roots&lt;/strong&gt;가 참조하는 오브젝트가 참조하는 오브젝트들을 찾습니다.&lt;/p&gt;
&lt;p&gt;이를 통해 모든 닿을 수 있는 오브젝트를 찾고 닿을 수 없는 모든 오브젝트들의 메모리를 해제합니다.&lt;/p&gt;
&lt;p&gt;이 가비지 컬렉션은 수동으로 조작할 수 없습니다.&lt;/p&gt;
&lt;h3&gt;클래스에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 클래스는 함수의 한 종류입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class는 new 연산자 없이 호출이 불가능 합니다.&lt;/li&gt;
&lt;li&gt;class는 extends와 super 키워드를 제공하여 상속이 가능합니다.
extends는 상속과 관련된 키워드이고, super는 수퍼클래스의 constructor 호출과 수퍼클래스의 메서드 호출을 가능하게 하는 키워드입니다.&lt;/li&gt;
&lt;li&gt;class에 정의된 메서드는 열거할 수 없으며, 항상 strict mode로 실행됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;즉시 실행 함수(IIFE)에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;즉시 실행함수는 정의되자마자 즉시 실행되는 함수를 말하며, 소괄호로 함수를 감싸서 실행하는 문법을 말합니다.
이를 통해 필요없는 전역 변수의 생성을 줄일 수 있고, 자체적인 스코프를 가지게 되기 때문에 private한 변수를 만들 수 있습니다.&lt;/p&gt;
&lt;h3&gt;엄격 모드에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;엄격 모드는 &apos;use strict&apos;를 스크립트 최상단에 작성하여 사용합니다.
이는 ES5에서 기존 스펙을 변경하며 하위 호환성 문제가 발생했기 때문에 도입된 문법으로, 엄격 모드를 활성화 했을 때에만 변경사항이 활성화되도록 해두었습니다.
또한 코드를 클래스와 모듈을 사용해 구성한다면 use strict를 사용하지 않아도 자동으로 엄격모드가 활성화됩니다.&lt;/p&gt;
&lt;h3&gt;콜 스택(Call Stack)과 힙(Heap)에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;콜 스택은 코드가 실행되면서 생성되는 실행 컨텍스트를 저장하는 자료구조입니다 이를 통해 변수 식별자, 스코프 체인 및 this 관리, 코드 실행 순서 관리 등을 수행하게 됩니다.
또한 콜 스택은 원시 타입의 값과 참조 타입의 메모리 힙 주소값이 저장되는 공간입니다.
메모리 힙은 원시 타입이 아닌 타입의 데이터가 저장되는 공간으로, 메모리 할당이 일어나게 됩니다.&lt;/p&gt;
&lt;h3&gt;Rest 연산자와 Spread 연산자에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;Spread 연산자를 사용하면 객체 혹은 배열을 개별 요소로 분리할 수 있습니다. 이를 통해 객체의 프로퍼티들을 기존 객체를 건드리지 않으면서 객체 혹은 배열을 복사할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Rest 연산자는 객체, 배열, 그리고 함수의 파라미터에서 사용이 가능합니다.
객체나 배열에서 Rest 연산자를 사용하면 디스트럭처링 된 값들을 다시 객체나 배열로 묶을 수 있습니다.
함수의 파라미터에서는 파라미터가 몇개가 될지 모르는 상황에서 이 파라미터들을 배열로 묶어주는 역할을 수행합니다.&lt;/p&gt;
&lt;h3&gt;제너레이터에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;제너레이터는 &lt;code&gt;function*&lt;/code&gt;로 만들어지는 제너레이터 함수를 통해 만들 수 있으며, 해당 함수는 본문을 실행하지 않고 제너레이터 객체를 반환합니다.&lt;/p&gt;
&lt;p&gt;그 후, &lt;code&gt;next()&lt;/code&gt;를 수행할 때마다, 함수에서 &lt;code&gt;yield&lt;/code&gt;한 값들을 하나씩 반환합니다.
&lt;code&gt;next()&lt;/code&gt;를 사용할 수 있는 것으로 짐작할 수 있듯, 제너레이터 객체는 이터레이터이자 이터러블입니다.&lt;/p&gt;
&lt;p&gt;따라서 제너레이터에서도 &lt;code&gt;for ... of&lt;/code&gt;이나 Spread 문법, 배열 디스트럭쳐링과 같은 기능을 사용할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;이터러블과 이터레이터 프로토콜에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위해 ES6에서 도입된 규칙입니다.
이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 &lt;code&gt;Symbol.iterator&lt;/code&gt; 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환합니다.&lt;/p&gt;
&lt;p&gt;이러한 규약을 이터러블 프로토콜이라 하며, 이터러블 프로토콜을 준수한 객체를 이터러블이라 합니다.&lt;/p&gt;
&lt;p&gt;이터러블의 &lt;code&gt;Symbol.iterator&lt;/code&gt; 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환합니다. 이터레이터는 &lt;code&gt;next&lt;/code&gt; 메서드를 소유하며 &lt;code&gt;next&lt;/code&gt; 메서드를 호출하면 이터러블을 순회하며
&lt;code&gt;value&lt;/code&gt;와 &lt;code&gt;done&lt;/code&gt; 프로퍼티를 갖는 이터레이터 리절트 객체를 반환합니다.&lt;/p&gt;
&lt;p&gt;이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Typescript - type과 interface 차이]]></title><description><![CDATA[typescript를 공부해보셨다면 type과 interface의 차이점에 대해 궁금증을 가져보셨을 텐데요!
이번 기회에 확실히 정리해 봅시다! 🙌 📌 상속 받는 법 interface는 extends를 type…]]></description><link>https://kirahaa.github.io/ts-type-interface/</link><guid isPermaLink="false">https://kirahaa.github.io/ts-type-interface/</guid><pubDate>Sat, 22 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;typescript&lt;/strong&gt;를 공부해보셨다면 &lt;code&gt;type&lt;/code&gt;과 &lt;code&gt;interface&lt;/code&gt;의 차이점에 대해 궁금증을 가져보셨을 텐데요!&lt;br/&gt;
이번 기회에 확실히 정리해 봅시다! 🙌&lt;/p&gt;
&lt;h3&gt;📌 상속 받는 법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;interface&lt;/strong&gt;는 &lt;code&gt;extends&lt;/code&gt;를 &lt;strong&gt;type&lt;/strong&gt;은 &lt;code&gt;&amp;#x26;&lt;/code&gt;를 이용해 상속을 통한 확장을 진행합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ✅ interface
interface IString1 {
  a: string;
}

interface IString2 extends IString2 {
  b: string;
}

const interfaceConst: interface2 = {
  a: &amp;#39;a&amp;#39;,
  b: &amp;#39;b&amp;#39;
}

// ✅ type
type type1 = {
  a: string;
}

type type2 = type1 &amp;amp; {
  b: string;
}

const typeConst: type2 = {
  a: &amp;#39;a&amp;#39;,
  b: &amp;#39;b&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;📌 선언적 확장 / 자동 확장&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;interface&lt;/strong&gt;는 같은 이름의 객체를 다시 한번 선언하면 자동으로 확장이 됩니다. 하지만 &lt;strong&gt;type&lt;/strong&gt;은 불가능 합니다.&lt;br/&gt;
따라서 외부에 공개되어야 하는 library 같은 경우에는 타입 객체의 확장성을 위해 &lt;strong&gt;interface&lt;/strong&gt;를 사용하는 것을 추천한다고 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ✅
interface interface1 {
  a: string;
}

interface interface1 {
  b: string;
}

const interfaceConst: interface1 = {
  a: &amp;#39;a&amp;#39;,
  b: &amp;#39;b&amp;#39;
}


// ❌ Duplicate identifier &amp;#39;type1&amp;#39;.
type type1 = {
  a: string;
}

type type1 = {
  b: string;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;📌 computed property name&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;computed property name은 &lt;strong&gt;표현식(변수, 함수 등)을 이용해 객체의 key 값을 지정하는 문법&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;의 경우, computed property name을 사용한 타입 선언이 가능하지만, &lt;strong&gt;interface&lt;/strong&gt;의 경우는 불가능합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type keyType = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39;

type type1 = {
  [key in keyType]: string
}

const typeA: type1 = { a: &amp;#39;a&amp;#39;, b: &amp;#39;b&amp;#39; }

interface interface1 {
  // ❌ error
  [key in keyType]: string
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;📌 원시 타입이나 튜플, 유니온 타입의 타입 선언의 경우에는 type 사용, interface는 객체의 타입 정의에 사용&lt;/h3&gt;
&lt;h4&gt;원시 타입(Primitive Types)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type CustomType = string;
const str: CustomType = &amp;#39;&amp;#39;;

// ❌ 
interface CustomInterface = string;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;유니온 타입(Union Types)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;유니온 타입이란 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Fruit = &amp;#39;apple&amp;#39; | &amp;#39;lemon&amp;#39;
type Vegetable = &amp;#39;patato&amp;#39; | &amp;#39;tomato&amp;#39;

type Food = Fruit | Vegetable

const apple: Food = &amp;#39;apple&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;튜플 타입(Tuple Types)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;tuple은 자바스크립트에서는 지원하지 않는 데이터 타입이지만, 타입스크립트에서는 &lt;strong&gt;배열 타입을 보다 특수한 형태로 사용할 수 있는 타입&lt;/strong&gt;입니다.
tuple에 명시적으로 지정된 형식에 따라 아이템 순서를 설정해야 되고, 추가되는 아이템 또한 tuple에 명시된 타입만 사용 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Animal = [name: string, age: number];

const cat: Animal = [&amp;#39;kitty&amp;#39;, 1];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;hr&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;공식문서에서는 특별한 경우를 제외하고는 &lt;strong&gt;type보단 interface를 사용하는 것이 더 좋다&lt;/strong&gt;고 하네요!&lt;br/&gt;
프로젝트를 설계하기 전에 type을 쓸지 interface를 쓸지 통일을 하면 좋을 것 같습니다!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론적으로는 팀 내 컨벤션이 있다면 그에 따르고, type과 interface의 쓰임새에 맞게 사용해주는게 좋다고 생각합니다. 😉&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NestJS를 배워보자]]></title><description><![CDATA[NestJS란? NestJS는 Node.js를 기반으로 한 서버 어플리케이션을 개발하기 위한 프레임워크 입니다. Node.js의 표준 웹서버 프레임워크로 불리는 Express 대신 왜 NestJS를 선택해야 할까요? 최근 몇 년 동안 Node.js…]]></description><link>https://kirahaa.github.io/starting-nest-js/</link><guid isPermaLink="false">https://kirahaa.github.io/starting-nest-js/</guid><pubDate>Thu, 20 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;h2&gt;NestJS란?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://nestjs.com/&quot;&gt;NestJS&lt;/a&gt;는 Node.js를 기반으로 한 서버 어플리케이션을 개발하기 위한 프레임워크 입니다.&lt;/p&gt;
&lt;p&gt;Node.js의 표준 웹서버 프레임워크로 불리는 Express 대신 왜 NestJS를 선택해야 할까요?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최근 몇 년 동안 Node.js 덕분에 자바스크립트는 백엔드, 프론트엔드 애플리케이션 모두의 웹 공통 언어가 되었습니다.&lt;br/&gt;
이로 인해 Angular, React, Vue가 나오게 되었으며, 해당 프로젝트를 통해 생산성을 향상하고 빠르게 만들 수 있으며, 테스트 가능하고 확장성이 있는 프론트엔드 애플리케이션을 만들 수 있게 되었습니다.
그러나 서버 측 Node.js에서는 뛰어난 라이브러리, 툴이 존재하지만 아키텍처, 즉 프로젝트 구조에 있어서 주요 문제를 효과적으로 해결하는 것은 없었습니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Nest는 개발자와 팀이 테스트 가능하고 확장이 가능하며, 느슨한 결합과 유지보수성이 뛰어난 애플리케이션을 만들 수 있도록 아키텍처를 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, &lt;strong&gt;NestJS는 서버 측 애플리케이션 개발에 있어 아키텍처의 문제를 해결하기 위해 등장&lt;/strong&gt;한 것입니다.&lt;/p&gt;
&lt;p&gt;기존의 Express는 사용하기도 쉽고 성능도 뛰어나지만 아키텍처에 관한 정의나 기능을 제공해주고 있진 않습니다.&lt;br/&gt;
실제로 팀 또는 사람마다 아키텍처가 다르면 이를 이해하기 위한 비용 또는 개발 전에 아키텍처를 선정하는 커뮤니케이션 비용이 증가합니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;NestJS는 아키텍처에 대한 정의를 제공하기 때문에 동일한 아키텍처에서 다른 개발자가 작성한 코드를 쉽게 이해할 수 있다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;그럼 NestJS를 설치해보면서 같이 시작해 봅시다! 🤗&lt;/p&gt;
&lt;h2&gt;NestJS CLI 설치&lt;/h2&gt;
&lt;p&gt;NestJS는 개발자가 좀 더 편리하게 NestJS 프로젝트를 개발하고 설정할 수 있도록 강력한 CLI(명령줄 인터페이스) 도구를 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;터미널을 열고 다음 명령어를 실행하여 NestJS CLI 도구를 전역(global)에 설치해 봅시다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm i -g @nestjs/cli
added 251 packages, and audited 252 packages in 11s

41 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 터미널에서 &lt;code&gt;nest&lt;/code&gt;라는 명령어를 사용할 수 있습니다.
단순히 &lt;code&gt;nest&lt;/code&gt; 명령어를 실행해보면 간단한 설명서를 확인할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ nest
nest
Usage: nest &amp;lt;command&amp;gt; [options]

Options:
  -v, --version                                   Output the current version.
  -h, --help                                      Output usage information.

Commands:
  new|n [options] [name]                          Generate Nest application.
  build [options] [app]                           Build Nest application.
  start [options] [app]                           Run Nest application.
  info|i                                          Display Nest project details.
  add [options] &amp;lt;library&amp;gt;                         Adds support for an external library to your project.
  generate|g [options] &amp;lt;schematic&amp;gt; [name] [path]  Generate a Nest element.
    Schematics available on @nestjs/schematics collection:
      ┌───────────────┬─────────────┬──────────────────────────────────────────────┐
      │ name          │ alias       │ description                                  │
      │ application   │ application │ Generate a new application workspace         │
      │ class         │ cl          │ Generate a new class                         │
      │ configuration │ config      │ Generate a CLI configuration file            │
      │ controller    │ co          │ Generate a controller declaration            │
      │ decorator     │ d           │ Generate a custom decorator                  │
      │ filter        │ f           │ Generate a filter declaration                │
      │ gateway       │ ga          │ Generate a gateway declaration               │
      │ guard         │ gu          │ Generate a guard declaration                 │
      │ interceptor   │ itc         │ Generate an interceptor declaration          │
      │ interface     │ itf         │ Generate an interface                        │
      │ middleware    │ mi          │ Generate a middleware declaration            │
      │ module        │ mo          │ Generate a module declaration                │
      │ pipe          │ pi          │ Generate a pipe declaration                  │
      │ provider      │ pr          │ Generate a provider declaration              │
      │ resolver      │ r           │ Generate a GraphQL resolver declaration      │
      │ service       │ s           │ Generate a service declaration               │
      │ library       │ lib         │ Generate a new library within a monorepo     │
      │ sub-app       │ app         │ Generate a new application within a monorepo │
      │ resource      │ res         │ Generate a new CRUD resource                 │
      └───────────────┴─────────────┴──────────────────────────────────────────────┘&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;NestJS 프로젝트 구성&lt;/h2&gt;
&lt;p&gt;다음으로 NestJS CLI를 이용해서 새로운 NestJS 프로젝트를 구성해 봅시다!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nest new&lt;/code&gt; 명령어 뒤에 프로젝트 명을 작성하면 해당 이름의 디렉토리가 생기고 그 안에 NestJS 프로젝트가 자동으로 구성이 될 것입니다.&lt;br/&gt;
저는 &lt;code&gt;nest-app&lt;/code&gt;을 프로젝트 이름으로 사용하였습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ nest new nest-app
⚡  We will scaffold your app in a few seconds..

✔ Installation in progress... ☕

🚀  Successfully created project our-nestjs
👉  Get started with the following commands:

$ cd nest-app
$ npm run start&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;npm run start&lt;/code&gt;로 NestJS 애플리케이션을 구동한 후, &lt;code&gt;http://localhost:3000&lt;/code&gt;에 접속해보면 Hello World!가 응답되는 것을 확인할 수 있을 것입니다.&lt;/p&gt;
&lt;h2&gt;main.ts&lt;/h2&gt;
&lt;p&gt;자동으로 생성된 파일 중에서 제일 먼저 살펴볼 파일은 &lt;code&gt;src&lt;/code&gt; 디렉토리 안에 있는 &lt;code&gt;main.ts&lt;/code&gt; 파일입니다.&lt;br/&gt;
이 파일은 NestJS 애플리케이션이 시작되는 진입 지점(entry point)이 되는데요. 파일을 열어보면 매우 짧은 코드가 들어있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { NestFactory } from &amp;quot;@nestjs/core&amp;quot;;
import { AppModule } from &amp;quot;./app.module&amp;quot;;

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;코드의 마지막 줄에는 &lt;code&gt;bootstrap()&lt;/code&gt;이라는 함수를 호출하고 있는데요.
&lt;code&gt;bootstrap()&lt;/code&gt; 함수 안에서는 &lt;code&gt;app.module&lt;/code&gt; 파일로부터 &lt;code&gt;AppModule&lt;/code&gt;을 불러와서 &lt;code&gt;NestFactory&lt;/code&gt;가 애플리케이션 객체를 생성하고 3000 포트로 HTTP 요청을 받고 있습니다.&lt;/p&gt;
&lt;h2&gt;모듈(Module)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;main.ts&lt;/code&gt; 파일에서 불러오고 있는 &lt;code&gt;app.module.ts&lt;/code&gt; 파일을 열어보면 &lt;code&gt;AppModule&lt;/code&gt; 클래스를 찾을 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { Module } from &amp;quot;@nestjs/common&amp;quot;;
import { AppController } from &amp;quot;./app.controller&amp;quot;;
import { AppService } from &amp;quot;./app.service&amp;quot;;

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 클래스 위에는 &lt;code&gt;@Module()&lt;/code&gt;이라는 데코리이터(decorator)가 호출되고 있습니다.&lt;/p&gt;
&lt;p&gt;NestJS에서 데코레이터는 일반적으로 클래스나 메서드에 어떤 정보를 추가해줄 때 활용이 됩니다.&lt;br/&gt;
&lt;code&gt;@Module()&lt;/code&gt; 데코레이터는 &lt;code&gt;imports&lt;/code&gt;, &lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;providers&lt;/code&gt; 속성으로 이루어진 객체를 인자로 받는데요.
&lt;code&gt;controllers&lt;/code&gt; 속성에는 HTTP 요청을 받아서 응답을 보내는 컨트롤러 클래스를 나열해줄 수 있고, &lt;code&gt;providers&lt;/code&gt; 속성에는 컨트롤러가 사용하는
다양한 일반 클래스(주로 서비스 클래스)를 나열해줄 수 있습니다. 여기서 비어있는 &lt;code&gt;imports&lt;/code&gt; 속성에는 해당 모듈이 의존하고 있는 다른 모듈을 나열해줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;모듈(module)은 NestJS에 매우 중요한 개념이라서 잘 이해하고 있어야 하는데요. 하나의 NestJS 애플리케이션은 보통 여러 개의 모듈로 이루어지는데
기능 단위로 애플리케이션을 쪼개 놓은 단위라고 생각할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여기서 중요한 것은 모듈은 서로 의존할 수 있다는 것인데요. 바로 &lt;code&gt;Module()&lt;/code&gt; 데코리에터에 인자로 넘기는 객체의 &lt;code&gt;imports&lt;/code&gt; 속성을 통해서 이 의존 관계를 명시하도록 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nestjs new&lt;/code&gt; 명령어로 NestJS 프로젝트를 생성하면 기본적으로 최상위 모듈인 &lt;code&gt;AppModule&lt;/code&gt; 하나 밖에 없지만, 프로젝트 규모가 점점 커지게 되면
다른 모듈을 작성한 후 &lt;code&gt;AppModule&lt;/code&gt;이 불러올 수 있도록 &lt;code&gt;@Module()&lt;/code&gt; 데코레이터를 호출할 때 &lt;code&gt;imports&lt;/code&gt; 속성을 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;정리하면 NestJS는 일종의 IoC(Inversion of Control) 컨테이너의 역할을 하면서 여러 모듈을 DI(의존성 주입)을 통해서 엮어준다고 보시면 됩니다.
어떻게 엮어야 하는지는 개발자가 각 모듈에 &lt;code&gt;@Module()&lt;/code&gt; 데코레이터의 &lt;code&gt;imports&lt;/code&gt; 속성으로 NestJS에 알려줘야 하고요.&lt;/p&gt;
&lt;h2&gt;컨트롤러(Controller)&lt;/h2&gt;
&lt;p&gt;다음으로 NestJS에서 하나의 축을 담당하고 있는 컨트롤러에 대해서 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;컨트롤러는 HTTP 요청을 받아서 처리하고 응답을 해주는 역할을 담당하고 있는 클래스입니다.&lt;br/&gt;
&lt;code&gt;src&lt;/code&gt; 디렉토리 안에 있는 &lt;code&gt;app.controller.ts&lt;/code&gt; 파일을 열어서 컨트롤러가 어떻게 생겼는지 확인해 보겠습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// src/app.controller.ts

import {Controller, Get} from &amp;quot;@nestjs/common&amp;quot;;
import {AppServie} from &amp;quot;./app.service&amp;quot;;

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
  
  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같이 클래스 위에다가 &lt;code&gt;@Controller()&lt;/code&gt; 데코레이터를 호출해주면 NestJS가 해당 클래스는 컨트롤러로 인식을 하게 되는데요.
클래스 내의 각 메서드에는 &lt;code&gt;@Get()&lt;/code&gt;, &lt;code&gt;@Post()&lt;/code&gt;, &lt;code&gt;@Delete()&lt;/code&gt;와 같은 HTTP 방식(method)에 해당하는 데코레이터를 붙여주게 됩니다.&lt;/p&gt;
&lt;p&gt;또한 이러한 데코레이터들은 URL 경로를 나타내는 문자열을 인자로 받는데요. NestJS는 데코레이터로 명시된 HTTP 방식과 URL 경로를 기준으로 부합하는 클래스의 메서드를 호출해줍니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;@Controller(&quot;aaa&quot;)&lt;/code&gt;가 붙어있는 클래스의 &lt;code&gt;@Post(&quot;bbb&quot;)&lt;/code&gt;가 붙어있는 메서드가 있었다면, POST 방식으로 &lt;code&gt;http://localhost:3000/aaa/bbb&lt;/code&gt; 에 요청했을 때 해당 메서드가 호출되었을 것입니다.&lt;/p&gt;
&lt;p&gt;이를 통해 아까 전에 위에서 &lt;code&gt;http://localhost:3000&lt;/code&gt;에 요청했을 때, &lt;code&gt;AppController&lt;/code&gt; 클래스의 &lt;code&gt;getHello()&lt;/code&gt; 함수가 이를 받아서 &lt;code&gt;Hello World!&lt;/code&gt;라는 응답을 해줬다는 것을 알 수 있습니다.&lt;/p&gt;
&lt;h2&gt;서비스(Service)&lt;/h2&gt;
&lt;p&gt;마지막으로 살펴볼 서비스 클래스는 일반적으로 비즈니스 로직을 수행하는 역할을 담당합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt; 디렉토리 안에 있는 &lt;code&gt;app.service.ts&lt;/code&gt;를 열어보면 &lt;code&gt;AppController&lt;/code&gt; 클래스가 사용하고 있던 &lt;code&gt;AppService&lt;/code&gt; 클래스를 확인할 수 있는데요.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// src/app.service.ts

import { Injectable } from &amp;quot;@nestjs/common&amp;quot;;

@Injectable()
export class AppService {
  getHello(): string {
    return &amp;quot;Hello World!&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 클래스 위에는 &lt;code&gt;@Injectable()&lt;/code&gt; 데코레이터가 사용되고 있죠? &lt;code&gt;@Injectable()&lt;/code&gt; 데코레이터가 붙어있는 클래스는 NestJS가 인스턴스를 생성하여 다른 클래스에 생성자를 통해서 주입을 해줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AppModule&lt;/code&gt;에서 &lt;code&gt;@Module()&lt;/code&gt; 데코레이터를 호출할 때 &lt;code&gt;providers&lt;/code&gt; 속성에 &lt;code&gt;AppService&lt;/code&gt; 클래스를 명시해줬었죠? 그렇기 때문에 &lt;code&gt;AppController&lt;/code&gt; 클래스의 생성자의 인자로 &lt;code&gt;AppService&lt;/code&gt; 클래스의 인스턴스가 주입이 되었고, &lt;code&gt;AppController&lt;/code&gt; 클래스의 &lt;code&gt;getHello&lt;/code&gt; 메서드 내에서 &lt;code&gt;AppService&lt;/code&gt; 클래스의 &lt;code&gt;getHello&lt;/code&gt; 메서드를 호출할 수 있었던 것입니다.&lt;/p&gt;
&lt;p&gt;이렇게 컨트롤러의 역할과 서비스의 역할을 분리함으로써 좀 더 유지보수가 용이한 애플리케이션을 개발할 수가 있는 것입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS 프리티어 EC2와 Github 연동하기]]></title><description><![CDATA[AWS는 Amazon Web Service의 약어로 대표적인 클라우드 플랫폼입니다.
AWS는 계정 생성 후 1년 동안 일정 무료 사용량을 제공하는 프리티어 서비스를 제공합니다. 시작하기 1) AWS 계정 생성, region…]]></description><link>https://kirahaa.github.io/aws-ec2-hosting/</link><guid isPermaLink="false">https://kirahaa.github.io/aws-ec2-hosting/</guid><pubDate>Sat, 15 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 310px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b518440d99795355f7c39bb20e35c2bc/56e1b/aws_0.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 52.53164556962025%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABT0lEQVR42oWS7UsCQRDG/Vv7WF8krD4kQYkRYkUkVGgkimUmHWqYb2glpiRhlGVRaF5iih1Cp0nt7EycpRTc1cMyMMNvmdl9Rkc/hIgMgDEGAJxzxpQISgUYACLSb+lIQzgQaUs3RIlIljseX2DHHzxK58oVMRxLirV66iQrhKLuXUHuvg1Jlcuvspw+zZssqwvLa06P32Cc3/Ls2ewuo2kxkjgGAPXOAJyIIvGUZWV9xrwUOIjpp+Y23b6R0cnC5XX9uTE+bc7k8kTEOVfvXK01nd6gEAw/VsVwNHn/UBZCUUmSQodxl3e/9SKpj03UL7Wv6L32lQxOn4UeVbaptKHx230Guw0sWHlmAm8cXExg84w/JfHOjflZXrTjrWtIaliFSK1zurBSRk/pMcoaqGijdolYjz46f/uMhFzDd/79tP+WBIkzQlCmUCJoLcknZU5hkc74J8IAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws&quot;
        title=&quot;&quot;
        src=&quot;/static/b518440d99795355f7c39bb20e35c2bc/56e1b/aws_0.png&quot;
        srcset=&quot;/static/b518440d99795355f7c39bb20e35c2bc/4d6f2/aws_0.png 158w,
/static/b518440d99795355f7c39bb20e35c2bc/56e1b/aws_0.png 310w&quot;
        sizes=&quot;(max-width: 310px) 100vw, 310px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AWS&lt;/strong&gt;는 &lt;strong&gt;Amazon Web Service&lt;/strong&gt;의 약어로 대표적인 클라우드 플랫폼입니다.&lt;br/&gt;
AWS는 계정 생성 후 1년 동안 일정 무료 사용량을 제공하는 프리티어 서비스를 제공합니다.&lt;/p&gt;
&lt;h2&gt;시작하기&lt;/h2&gt;
&lt;h3&gt;1) AWS 계정 생성, region 설정&lt;/h3&gt;
&lt;p&gt;개인정보와 결제 카드 등을 등록해서 AWS 가입을 해줍니다.
상단 메뉴에서 지역은 &lt;strong&gt;아시아 태평양 (서울) ap-northeast-2&lt;/strong&gt;로 설정해 줍니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 337px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b7c4232f19be0eb7e91a3fee082c4828/f5074/aws_region.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 137.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAECAwUE/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAcwlGp7i0HOSSaggf//EABwQAAAGAwAAAAAAAAAAAAAAAAACAwQQMhEzQf/aAAgBAQABBQKEUynKOtqQ2pmG2v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARAAcSJB4f/aAAgBAQAGPwJZDc6jbNs3P//EABsQAAIDAQEBAAAAAAAAAAAAAAABEWHwMSFB/9oACAEBAAE/IUkN+j65GodE3Az0y0hTHT70y0hVJNNI/9oADAMBAAIAAwAAABDMGU3/xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EK1D/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EFYr/8QAIRAAAgEDBAMBAAAAAAAAAAAAAREAITFxQVFhoZGx0fD/2gAIAQEAAT8QSBdciWIJ1dBrDXDAEGKIbZiiotsELuLOHud9q4bslz8lWbfsTuoEASeT9jgkq/JhMvKH/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws region&quot;
        title=&quot;&quot;
        src=&quot;/static/b7c4232f19be0eb7e91a3fee082c4828/f5074/aws_region.jpg&quot;
        srcset=&quot;/static/b7c4232f19be0eb7e91a3fee082c4828/ab180/aws_region.jpg 158w,
/static/b7c4232f19be0eb7e91a3fee082c4828/ba98e/aws_region.jpg 315w,
/static/b7c4232f19be0eb7e91a3fee082c4828/f5074/aws_region.jpg 337w&quot;
        sizes=&quot;(max-width: 337px) 100vw, 337px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2) 인스턴스 시작&lt;/h3&gt;
&lt;p&gt;메인 화면에서 EC2 서비스를 클릭하거나, 상단 검색 메뉴에서 EC2를 검색하면 다음과 같은 대시보드를 확인 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5f6f4d81571d4b7416443adc95fcc368/bbbf7/aws_1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABsUlEQVR42m1Sy24bMQzc/7/WiWOndlyn6D/02ENv7a23okARBAG8Xe1KIvVaSTuFaMNIHwQGlAiRHHLUrfcfsH77HqvtAbf3D7jZHrDZP+Jud8Rqsxesd0esd4+4vT/+gdXmgDd3D+Ibbrbv0NUcUaJDs5QSYozIOeO1LcuC/1l713Kan+cZpRZ0zAzvnSRpo6GNxUlNMMaCiEDEGCcDSw61FJQLQpqR5nyN1VrhQ0DnfEApVTpaa6HJg0JptC7MFmhO8CmjLhWlnqE5/hNzIaIjS4jeXQsa9pilwaXgsiDN5dr0Om6pqH+too3fMTtYSxIgslA24FkxThNjsB69ZvQTQVknd4FxAnU5/9IM7RJcTOjazqZRvWIYcDIBvfaYOGGkiImjeMHlrK4IQmLkBOsCurZ078OZIRNO/YCnpxewZTATmmgNTf0QAvq+h1JKlGViTNpgUArDoETErgVzTmeGHGC+fcb46QHmy0cMwyiP226azTnLerQxcm/fxLgJHC0oGoQU0DWp2TkRwRLDvvwEff8K+/wDxA7OOfkWi4gzw3sv7Fosl4w5J5SSpXib4jdmmvKyOGE+TAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws instance&quot;
        title=&quot;&quot;
        src=&quot;/static/5f6f4d81571d4b7416443adc95fcc368/984b6/aws_1.png&quot;
        srcset=&quot;/static/5f6f4d81571d4b7416443adc95fcc368/4d6f2/aws_1.png 158w,
/static/5f6f4d81571d4b7416443adc95fcc368/3c1ae/aws_1.png 315w,
/static/5f6f4d81571d4b7416443adc95fcc368/984b6/aws_1.png 630w,
/static/5f6f4d81571d4b7416443adc95fcc368/e7d8e/aws_1.png 945w,
/static/5f6f4d81571d4b7416443adc95fcc368/58c38/aws_1.png 1260w,
/static/5f6f4d81571d4b7416443adc95fcc368/bbbf7/aws_1.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;인스턴스 시작 버튼을 누르면 클라우드 서버 구축을 시작하는 것입니다.&lt;/p&gt;
&lt;h3&gt;3) AMI 선택(어떤 종류의 서버 컴퓨터를 돌릴 것인지)&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/918190bc8ed757b9100da25a0247f348/90377/aws_ami.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 69.62025316455697%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACLklEQVR42m2TXXKcMBCEuf8tcoTcIM95TVXih8Re73ptAwsI/UsIvtRof1MVqroYDainZ9RqBjXTjYp+nOhPJ5TWGGv/A3OLtbEoNRNTJKV0g/ee5qNt+f3nmZfdjv3xg0Epxmm6QDFc4umSH8bpTKoNzkeWpdwQY6IZxpG26+j6nrbvb2RCMD2QP66tc2QhyIWlrKzrGaKykUpt2zIqTcqZnO8tSFyR7pC8dZ7PceatG5m0JabMukFeMo3In2dd5T7Kv6IUwVqVFNkFuBCYjMfGjE+Fsp3zOWcaa12tWBUtyxmidFmq4qtaExIupqrC+sBoPCEXHp9KKAr3+wPPzy/sDwd2u1de9/saHw5vdKcR5xzOWay159h7OmWZXfyHUAQ08lHmKCc6qfn2Fhhjsd4TQsSHUFuNMWJ95Dh5jsNMN3s67Tm5hA6JRrwTxUMh4H2os5QiEstphhBYrqO4jENa/9SBp92Rp9d3fv555X2c0SHThBjrhhQjgwkYn4CNbbvj/GyX/IoNiTEUWh3oBGFl2kCLbYRwsJEPdTarMaaqksMSpaJSOoh5QVnPum34GAl5IZeNvELcf8P8+ILvn4Qw0SrD+6DqHITAao3zmmAMqu/R0npaqlWWdeXa1bqW2oE/fmf89ZU4vdDI7MScXb3LQ/35Nq+USTFVH4pi8etSSi2qjbkjFkwG7YIoDPWyn4ax4nr55YR9iNUKZS2kC7mshXDW+k6oFXoe0XrmLxHqOGaemtRAAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws ami&quot;
        title=&quot;&quot;
        src=&quot;/static/918190bc8ed757b9100da25a0247f348/984b6/aws_ami.png&quot;
        srcset=&quot;/static/918190bc8ed757b9100da25a0247f348/4d6f2/aws_ami.png 158w,
/static/918190bc8ed757b9100da25a0247f348/3c1ae/aws_ami.png 315w,
/static/918190bc8ed757b9100da25a0247f348/984b6/aws_ami.png 630w,
/static/918190bc8ed757b9100da25a0247f348/e7d8e/aws_ami.png 945w,
/static/918190bc8ed757b9100da25a0247f348/90377/aws_ami.png 1231w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저는 &lt;strong&gt;Amazon Linux&lt;/strong&gt;를 선택하였습니다. 이 중 프리티어 사용가능이 아닌 OS도 있으니 잘 보고 선택해야 합니다.&lt;/p&gt;
&lt;h3&gt;4) 인스턴스 유형 선택&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5b5f8928b88db5e65f6566f1014e3575/912c7/aws_instance.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 70.25316455696203%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACA0lEQVR42o1T2YoUQRDs//8Hv8JP8FlQcfEAhZWd2ZnZ7q47s67ukMyZbh0FsSCog6rIjMisIRGhlIrWGmqtirLNpWJZFvw5Ykow1iLnjFLKDmLGQEwIISLGhFwKUkr6gDOjt46zP+LrywNqL0q2YkVihvcekRit9R1COggr5wxmRu/Xw5QIkjlW4GB/4MPhLaiSbNGXRe+X2pFrR+uLqhCIsiHECOe9SnAhatob1I5c0et62yc9EwXn2ePpMmN2AVwa+gq1bVA/jME0TSDOGkkyFWxruaj727mQ2kgIXEG1oy+r2rETzsaojNrqzeCqnoifAjkPMekdGRLYBAKVdlcsJRTJxjoY5zHNRtfjbGCdV0hA8SblCs9VPRPiFxvhIt8R1o1wHEccn58xG7d7dIf4a06yJsbREg6Tw8URzjZhjFkDDiJpnCZcLi+wPighEWnVt+JIC+nMjMyMyBnnkPHl8YjPj0c8fHvE02jhc716KNgLooW4h3gjUktfsa4rKBfMLD3KigstMAvgt7bZGvuaRf4L0pcxEVy89qfeqw1Fgq0AP71BeP8KdP54zXAcJ5xOZ/iY9u/3O1q7fs1Ssv4QIWy9YelNM+bTO8yfXiPP3zGIX14ypKw99j9DMvYh3ODhc0NogKeMQSRMxsJYr6ZLD0rUfxIS6e/aSb2FdzO8d/gJ8d4/EP+3o9sAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws instance&quot;
        title=&quot;&quot;
        src=&quot;/static/5b5f8928b88db5e65f6566f1014e3575/984b6/aws_instance.png&quot;
        srcset=&quot;/static/5b5f8928b88db5e65f6566f1014e3575/4d6f2/aws_instance.png 158w,
/static/5b5f8928b88db5e65f6566f1014e3575/3c1ae/aws_instance.png 315w,
/static/5b5f8928b88db5e65f6566f1014e3575/984b6/aws_instance.png 630w,
/static/5b5f8928b88db5e65f6566f1014e3575/e7d8e/aws_instance.png 945w,
/static/5b5f8928b88db5e65f6566f1014e3575/912c7/aws_instance.png 1228w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;프리티어를 마음 편하게 사용하려면 메모리 1GB의 &lt;strong&gt;t2.micro&lt;/strong&gt; 밖에 선택사항이 없습니다.. 😂&lt;/p&gt;
&lt;h3&gt;5) 인스턴스 세부 정보 변경&lt;/h3&gt;
&lt;p&gt;바로 [검토 및 시작] 버튼을 눌러도 잘 생성되지만, [인스턴스 세부 정보 변경] 버튼을 눌러 세부사항을 입맛에 맞게 변경할 수 있습니다.&lt;br/&gt;
저는 따로 변경하지 않고 진행하였습니다.&lt;/p&gt;
&lt;h3&gt;6) 키 페어 설정&lt;/h3&gt;
&lt;p&gt;새 키 페어 생성 버튼을 누르면 키 페어 이름을 입력해주고, 다운로드 된 키페어 파일을 로컬 컴퓨터에 잘 저장해 놓아야 합니다. 이름은 뭐든 괜찮습니다.&lt;br/&gt;
키 페어 다운로드 버튼을 누르면 &lt;code&gt;.pem&lt;/code&gt; 파일이 다운로드 됩니다.&lt;/p&gt;
&lt;h3&gt;7) 보안 그룹 설정&lt;/h3&gt;
&lt;p&gt;보안 그룹은 EC2 인스턴스에 접근할 수 있는 그룹입니다.&lt;br/&gt;
보안이 중요하다면 접근 가능한 포트와 IP를 지정하는 것이 좋습니다.&lt;br/&gt;
저는 일단 기본으로 진행했습니다.&lt;/p&gt;
&lt;p&gt;이제 인스턴스 시작 버튼을 누르면 EC2 인스턴스 생성이 완료됩니다.&lt;br/&gt;
터미널에서 인스턴스에 접근해서 서버 코드를 올리고 서버를 구동할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/026b03f3f90df2fca59187a83075175f/a2afc/aws_connect.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.835443037974684%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABpklEQVR42k2R227TQBCG/ea8BeIZuOGCCwSt2oQ2JyA8AkpLc3DsOI7jPc3u+kO7JFV/6deMZ8b/HLYYTX7yMF3w7faOz19uuLl/YDT+zuNkxnzxi+mF88WS2WLJ/MdvHqczRvcfGI1vGU+WTEZfmX58x92n9xQ+BIYYqTtFfTa02tJpi/EeI4ITn2m94LzPlBAIMWJF8CHmfBwC3bmjMFrhvWe9r3kpK9b7A6tdzfNuz2qz5WlTZv/PZsNqvWW1Lvm7q9gdWl7Kmk3VsK4O7Nue521JoZVCRGhPJ45tS9M01FWF6nu8OJxYvBe8CCIuW+8ckpjyzmYmvyxLCqU14j1N23JoT/RaY4zFZQGPtS7bdJoY4yvTVskOw5BtQlVVFNZaYoh0XZd/9j7koitO/QllDD6+hrL4oWlz49TMOUccoDm2FL3qc6Dv+0uB5O80QYIxBq01qXHKkSYahvwYyU/Nh8uEaaiiTzf0Hm1MvmESHS6FCUpptPv/mtdYWvGkDMoKEgZceCOolMoFkm8mr/e4wjjhbAPmzc4xDhyVzYIhXqaFvNk/TYCwBNoz580AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws connect&quot;
        title=&quot;&quot;
        src=&quot;/static/026b03f3f90df2fca59187a83075175f/984b6/aws_connect.png&quot;
        srcset=&quot;/static/026b03f3f90df2fca59187a83075175f/4d6f2/aws_connect.png 158w,
/static/026b03f3f90df2fca59187a83075175f/3c1ae/aws_connect.png 315w,
/static/026b03f3f90df2fca59187a83075175f/984b6/aws_connect.png 630w,
/static/026b03f3f90df2fca59187a83075175f/e7d8e/aws_connect.png 945w,
/static/026b03f3f90df2fca59187a83075175f/58c38/aws_connect.png 1260w,
/static/026b03f3f90df2fca59187a83075175f/a2afc/aws_connect.png 1914w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제 인스턴스가 잘 생성되었습니다. 연결 버튼을 눌러 터미널을 열어줍니다.&lt;/p&gt;
&lt;p&gt;이제 하단 명령어를 통해 제가 만든 서비스를 설치해 줍니다.
저는 git을 설치해서 해당 레포지토리를 클론한 뒤 서버를 실행시키는 방법을 사용하였습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ pwd
/home/ec2-user 뜨면 잘 연결된 겁니다🎉

$ sudo yum update y   // yum update를 해줍니다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;git을 설치해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ sudo yum install git -y

$ git --version
git version 2.34.1.windows.1  // git 버전이 잘 뜨면 성공🎉&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 git 레포지토리를 클론하여 가져옵니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;git clone https://github.com/본인깃허브아이디/레포지토리.git&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그럼 다음과 같이, username과 password를 입력합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;Username for &amp;#39;https://github.com&amp;#39;: 깃허브아이디
Password for &amp;#39;https://kirahaa@gmail.com&amp;#39;: &lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;패스워드는 &lt;strong&gt;github 로그인 &gt; Settings &gt; Developer settings &gt; Personal access tokens &gt; Generate New Token &gt; 필요항목 입력(repository만 체크) 후 Generate Token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;생성된 토큰을 &lt;strong&gt;Ctrl + shift + v&lt;/strong&gt; 해서 붙여넣기 해줍니다.&lt;/p&gt;
&lt;p&gt;이제 생성된 디렉토리를 확인해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ ls 
// 생성된 레포 뜸 ex) auth-with-jwt&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 디렉토리로 들어갑니다.&lt;/p&gt;
&lt;p&gt;자 이제, &lt;code&gt;npm install&lt;/code&gt;을 해서 패키지들을 설치해 주어야 하는데,&lt;br/&gt;
npm을 입력하면 &lt;code&gt;-bash: npm: command not found&lt;/code&gt;라고 뜰 것입니다.&lt;br/&gt;
그럼 다음 명령어들을 순서대로 쳐줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash

$ . ~/.nvm/nvm.sh

$ nvm install node&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 node를 설치해야 하는데, &lt;code&gt;nvm install node&lt;/code&gt;하면 에러가 뜰 것입니다.&lt;br/&gt;
버전 문제 때문에 다음과 같이 16버전을 다운받아 주어야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;nvm install 16&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;node가 잘 설치되었나 버전 확인을 해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;node -v&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 &lt;code&gt;package.json&lt;/code&gt; 내 패키지들을 설치해 줍니다.&lt;/p&gt;
&lt;p&gt;여기서 잠깐! git에는 mongodb 정보가 담겨있는 &lt;code&gt;config.js&lt;/code&gt;파일이 제외되어 있어서, 새로 만들어줘야 했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ cat &amp;gt; config.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 명령어를 통해 파일 생성이 되면 내용을 바로 입력할 수 있습니다.
(참고: &lt;a href=&quot;https://heytech.tistory.com/33&quot;&gt;https://heytech.tistory.com/33&lt;/a&gt;)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  &amp;#39;secret&amp;#39;: &amp;#39;SeCrEtKeYfOrHaShInG&amp;#39;,
  &amp;#39;mongodbUri&amp;#39;: &amp;#39;mongodb+srv://&amp;lt;본인 아이디&amp;gt;:&amp;lt;패스워드&amp;gt;@mycluster.likcia7.mongodb.net/?retryWrites=true&amp;amp;w=majority&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 저장 및 종료
키보드 control과 z 버튼 동시에 눌러주기.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;괄호가 잘 안닫혔는지, &lt;code&gt;node app.js&lt;/code&gt; 명령어를 실행해 주었더니, 오류가 떴습니다.😥&lt;br/&gt;
그래서 다시 &lt;code&gt;config.js&lt;/code&gt; 파일 수정해주기!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 편집 및 저장
// 편집 명령어
$ vi 파일명.확장자명&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;명령어 입력 후 엔터를 눌러주면 기존에 저장한 내용이 나옵니다.&lt;br/&gt;
확인해보니 역시 닫는 괄호가 잘 안 닫혀있어, 파일을 수정해 줍니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;편집을 모두 마쳤다면, 키보드 &lt;code&gt;ESC&lt;/code&gt;를 눌러 편집 기능을 비 활성화 해줍니다.&lt;br/&gt;
이제 마지막으로 &lt;code&gt;:wq&lt;/code&gt;를 입력하고 &lt;code&gt;Enter&lt;/code&gt;를 눌러주면 파일이 저장되고 터미널로 화면이 전환됩니다.&lt;br/&gt;
이제 다시 &lt;code&gt;node app.js&lt;/code&gt; 명령어를 통해 서버를 실행해 줍니다!🎉&lt;/p&gt;
&lt;h2&gt;8) 인바운드 규칙 추가&lt;/h2&gt;
&lt;p&gt;이제 마지막 단계입니다!&lt;/p&gt;
&lt;p&gt;퍼블릭 IPv4 주소인 &lt;strong&gt;13.209.42.233&lt;/strong&gt;으로 접속했더니 잘 되지 않습니다.&lt;br/&gt;
그건 저희가 포트 3000번에 열었기 때문인데요, 그래서 &lt;strong&gt;13.209.42.233:3000&lt;/strong&gt;으로 접속해 줍니다.
그래도 아마 접속이 안될 것입니다ㅠㅠ&lt;/p&gt;
&lt;p&gt;자 이제 다시 aws 인스턴스 페이지로 돌아가서 왼쪽 메뉴에서 &lt;strong&gt;네트워크 및 보안 &gt; 보안 그룹&lt;/strong&gt;에 들어갑니다.&lt;/p&gt;
&lt;p&gt;해당 인스턴스 이름을 클릭한 뒤, 하단에 보이는 &lt;strong&gt;인바운드 규칙 &gt; 인바운드 규칙 편집&lt;/strong&gt;을 눌러 포트를 새로 추가해 줍니다.&lt;/p&gt;
&lt;p&gt;현재 제 인바운드 리스트에는 세가지가 있는데요.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;유형&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;프로토콜&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;포트 범위&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;소스&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;SSH&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;22&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0.0.0.0/0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;HTTP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;80&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0.0.0.0/0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;사용자 지정 TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3000&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0.0.0.0/0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;이렇게 추가해 주시면 됩니다.&lt;/p&gt;
&lt;p&gt;그럼 이제 주소창에 &lt;strong&gt;13.209.42.233:3000&lt;/strong&gt;을 입력하면&lt;/p&gt;
&lt;p&gt;aws 서버 만들기 완료입니다!!🎉🎉🎉&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a7fe00ef919ef6004ae0107993311ff7/f6862/aws_complete.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.46835443037975%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAWklEQVR42uWQOw6AMAxDc/8zZupCp5aFKJ/BqFQdEVDYGN5mP1kmVcXAzODuU4S3roKWnMHMSCmhlDIt7ARIZEOtK0TkpaxDx9yI00C7YVxyW3iJPVz4JT8U7hDDwWrRLt6/AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws complete&quot;
        title=&quot;&quot;
        src=&quot;/static/a7fe00ef919ef6004ae0107993311ff7/984b6/aws_complete.png&quot;
        srcset=&quot;/static/a7fe00ef919ef6004ae0107993311ff7/4d6f2/aws_complete.png 158w,
/static/a7fe00ef919ef6004ae0107993311ff7/3c1ae/aws_complete.png 315w,
/static/a7fe00ef919ef6004ae0107993311ff7/984b6/aws_complete.png 630w,
/static/a7fe00ef919ef6004ae0107993311ff7/e7d8e/aws_complete.png 945w,
/static/a7fe00ef919ef6004ae0107993311ff7/58c38/aws_complete.png 1260w,
/static/a7fe00ef919ef6004ae0107993311ff7/f6862/aws_complete.png 1917w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;➕ 이후 찾은 문제점&lt;br/&gt;&lt;/h3&gt;
&lt;p&gt;위 과정으로 aws 인스턴스가 잘 만들어졌다고 생각했는데, 서버가 자꾸 끊기는 문제가 발생했습니다.&lt;br/&gt;
아직 정확한 문제를 찾지는 못했으나, ec2의 t2.micro의 작은 메모리이다 보니, 끊기는 것은 어쩔 수 없는 문제인가 봅니다..&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;에필로그&lt;/h3&gt;
&lt;p&gt;여기까지 node.js의 express를 활용한 jwt 인증 구현을 해보았는데요, 사실 이번에는 튜토리얼 영상을 보며 코드를 따라친 느낌이라 그냥 찍먹한 느낌입니다..ㅎㅎ&lt;/p&gt;
&lt;p&gt;그래도 데이터베이스도 직접 만져보고, aws 인스턴스도 만들어보고 찍먹러로써는 정말 좋은 경험이었습니다! &lt;br/&gt;
하나의 프로젝트의 처음부터 끝까지 경험해보고 싶다면 추천합니다! 👍&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;참고 자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=_bu6etIS_bo&quot;&gt;https://www.youtube.com/watch?v=_bu6etIS_bo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://makethree.tistory.com/4&quot;&gt;https://makethree.tistory.com/4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Node.js + Express + JWT 인증 시스템 구현하기(feat. MongoDB)]]></title><description><![CDATA[Node.js와 Express, Mongodb를 이용한 JWT 토큰 기반 인증 시스템을 구현 한 뒤, AWS ec2를 통해 배포한 내용을 정리하였습니다. 1. 프로젝트 생성 및 설정하기 새로운 디렉토리를 만든 후, package.json…]]></description><link>https://kirahaa.github.io/node-express-jwt-auth/</link><guid isPermaLink="false">https://kirahaa.github.io/node-express-jwt-auth/</guid><pubDate>Fri, 14 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Node.js와 Express, Mongodb를 이용한 JWT 토큰 기반 인증 시스템을 구현 한 뒤, AWS ec2를 통해 배포한 내용을 정리하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;1. 프로젝트 생성 및 설정하기&lt;/h2&gt;
&lt;p&gt;새로운 디렉토리를 만든 후, package.json 파일을 다음과 같이 설정해주고, &lt;code&gt;npm install&lt;/code&gt; 명령어를 통해 프로젝트에 필요한 모듈을 설치해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  &amp;quot;name&amp;quot;: &amp;quot;express-jwt-auth&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;auth with express jwt&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;bcrypt&amp;quot;: &amp;quot;^5.0.0&amp;quot;,
    &amp;quot;cookie-parser&amp;quot;: &amp;quot;^1.4.5&amp;quot;,
    &amp;quot;ejs&amp;quot;: &amp;quot;^3.1.3&amp;quot;,
    &amp;quot;express&amp;quot;: &amp;quot;^4.17.1&amp;quot;,
    &amp;quot;jsonwebtoken&amp;quot;: &amp;quot;^8.5.1&amp;quot;,
    &amp;quot;mongoose&amp;quot;: &amp;quot;^5.9.23&amp;quot;,
    &amp;quot;validator&amp;quot;: &amp;quot;^13.1.1&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node app.js&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;auth&amp;quot;,
    &amp;quot;express&amp;quot;,
    &amp;quot;jwt&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;hayeong&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;디렉토리 구조&lt;/h3&gt;
&lt;p&gt;프로젝트에서 사용할 디렉토리 구조는 다음과 같습니다.
페이지 템플릿은 &lt;code&gt;ejs&lt;/code&gt;를 사용하였습니다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;├─ .gitignore
├─ README.md
├─ app.js
├─ config.example.js
├─ controllers
│  └─ authController.js
├─ middleware
│  └─ authMiddleware.js
├─ models
│  └─ User.js
├─ package.json
├─ public
│  └─ style.css
├─ routes
│  └─ authRoutes.js
└─ views
   ├─ detail.ejs
   ├─ home.ejs
   ├─ login.ejs
   ├─ partials
   │  ├─ footer.ejs
   │  └─ header.ejs
   └─ signup.ejs&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;©generated by &lt;a href=&quot;https://woochanleee.github.io/project-tree-generator&quot;&gt;Project Tree Generator&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;app.js 세팅하기&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js
const express = require(&amp;#39;express&amp;#39;);
const mongoose = require(&amp;#39;mongoose&amp;#39;);

const config = require(&amp;#39;./config&amp;#39;)

const app = express();

// middleware
app.use(express.static(&amp;#39;public&amp;#39;));

// view engine
app.set(&amp;#39;view engine&amp;#39;, &amp;#39;ejs&amp;#39;);

mongoose.connect(config.mongodbUri)
const db = mongoose.connection
db.on(&amp;#39;error&amp;#39;, console.error)
db.once(&amp;#39;open&amp;#39;, ()=&amp;gt;{
    console.log(&amp;#39;connected to mongodb server&amp;#39;)
    app.listen(3000)
})

// routes
app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; res.render(&amp;#39;home&amp;#39;));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;config.js&lt;/code&gt; 파일은 프로젝트에서 사용할 MongoDB 서버의 정보와, JWT 토큰을 만들 때 사용될 &lt;code&gt;secret&lt;/code&gt; 키의 정보를 지니고 있습니다.&lt;/p&gt;
&lt;p&gt;보안에 관련된 정보는 따로 파일에 분리하여 관리하는 것이 좋습니다.
github 저장소에도 &lt;code&gt;config.js&lt;/code&gt; 파일은 &lt;code&gt;.gitignore&lt;/code&gt;에 추가해서 커밋이 되지 않도록 설정합니다.
예제 정보가 적혀있는 &lt;code&gt;config.example.js&lt;/code&gt; 파일의 이름을 &lt;code&gt;config.js&lt;/code&gt;로 수정하고 사용합니다.
설정 파일을 작성하기 전에, MongoDB 서버를 만들어 봅시다.&lt;/p&gt;
&lt;h2&gt;2. MongoDB 준비&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB 홈페이지&lt;/a&gt;에 들어가서 회원가입을 해 줍니다.&lt;br/&gt;
새로운 프로젝트를 만들고 새로운 클러스터를 만듭니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f2c905606f20f08dad165fad974c1fa9/9caaa/mongodb_1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.202531645569614%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVR42oWS3W4VIRSF5/2fxBfwAbzyRi+MNyYmtqYxaU87TGf42xvYfAZOzrGapi6yMgOEzbeAZYuemDJpuAheEiqClkKzRv9P01rIRUkiiCrL/e54OnZa7/zcPD/czmlPBMlkVXrvbxvOto41Y/m+3nPrHatEnD9w3vPod9wgL8JbGgWHbtcH3n36wMebbyynzXHkSLVGbUapDVWdkYdHjOFa65XqgjWohn49r7z/+pkvdzcsj84RUqJZRWsnqhEl4WO8+jzf/qZ70QyjtI4ZLA/bOgn/XfBSpVZ8zPiQiClhZvRX4lvvI/JGzGlGfk3NDCmVI1V8UkSU1ux6fn+Iz0WXk3Nsxz4pQjpHjHncsHCEMPuicnbRSXh4jw+BmIUjpvkd64eXp23jOQZqq/MtjfMahUJO+BTn/9jgstEYv4xFUXxWguh8j7U1fgN2Yb6VbYCypwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;make new cluster in mongodb&quot;
        title=&quot;&quot;
        src=&quot;/static/f2c905606f20f08dad165fad974c1fa9/984b6/mongodb_1.png&quot;
        srcset=&quot;/static/f2c905606f20f08dad165fad974c1fa9/4d6f2/mongodb_1.png 158w,
/static/f2c905606f20f08dad165fad974c1fa9/3c1ae/mongodb_1.png 315w,
/static/f2c905606f20f08dad165fad974c1fa9/984b6/mongodb_1.png 630w,
/static/f2c905606f20f08dad165fad974c1fa9/e7d8e/mongodb_1.png 945w,
/static/f2c905606f20f08dad165fad974c1fa9/58c38/mongodb_1.png 1260w,
/static/f2c905606f20f08dad165fad974c1fa9/9caaa/mongodb_1.png 2874w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저는 &lt;code&gt;Project 0&lt;/code&gt;의 &lt;code&gt;myCluster&lt;/code&gt;란 이름의 클러스터를 만들어 주었습니다.&lt;/p&gt;
&lt;h3&gt;데이터 베이스 만들기&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Browse Collections &gt; add my own data&lt;/strong&gt;에서 새로운 데이터 베이스를 생성합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0fce7eaf88640a4114d10bcb5b96e403/f621c/mongodb_2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 48.10126582278481%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACAUlEQVR42n2SS2sTURiG8y8FE5smk3vakHYyk7lP0napuFaKUSuohbSQpRsX7rSCWkttWkQkVVDT2NDQC9M88p20RUU8cJgzw5z3e28xzfTQDI9s3UfOGdMnVw/IWyEFu/HfLf9kzYBsPSBj+JS9RWJp3aVgNZg2fOK6S9oISNcCNMMnL8B2qC7KkH8NKl48s6bPjAAmdBvN9NWe0h1Shk9yzuH28gPe7+zy6u0mr99tsfmhS/fjJ27eaZHSHYpOU7ETZqJQq3mU3UViSd1RYDJdZBecBlNVi0drHUZHI/r9A06Oj4mic2S1VteIVwxKTvOKtex0zVXfYpmaR74eKu9S8w5azeVGxWRlrcPXwYjewZDh2ZgfRyecKcB1pqp1Sm7zSnbG8EhWLYp2c+LhBFDCcZVHcuFhu0OvP2Tvy3f6o1MOTyMiYPlJm+szNXLK1/CCaaiIzHhLxLQLhmnTI2cHlL0FJXml3eFwOORzb5+DwYAoipTke0/bJGYNFUbODIhXTRJzFtNzNiVngVh63lUTLtMruQuKoXgo63w8hjF8+zng5f4u91fXiSvAJnkz4NqsTqJqkTXDScoCKAwv/RAJkqKkvNXd483WNpvbO7zY2ODx82fcuttSbC57WLKbE7b1YCJZaMvL36WVskodpBZSj4IVUvGWlJo/yv1byYXhLw/sDdyHZaEEAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;make database in mongodb&quot;
        title=&quot;&quot;
        src=&quot;/static/0fce7eaf88640a4114d10bcb5b96e403/984b6/mongodb_2.png&quot;
        srcset=&quot;/static/0fce7eaf88640a4114d10bcb5b96e403/4d6f2/mongodb_2.png 158w,
/static/0fce7eaf88640a4114d10bcb5b96e403/3c1ae/mongodb_2.png 315w,
/static/0fce7eaf88640a4114d10bcb5b96e403/984b6/mongodb_2.png 630w,
/static/0fce7eaf88640a4114d10bcb5b96e403/e7d8e/mongodb_2.png 945w,
/static/0fce7eaf88640a4114d10bcb5b96e403/58c38/mongodb_2.png 1260w,
/static/0fce7eaf88640a4114d10bcb5b96e403/f621c/mongodb_2.png 2878w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저는 데이터 베이스 이름을 &lt;code&gt;node-auth&lt;/code&gt;로 설정하고, collection 이름을 &lt;code&gt;users&lt;/code&gt;로 설정하였습니다.&lt;br/&gt;
설정이 끝나면 &lt;strong&gt;Connect &gt; Connect to your application &gt; Drivers&lt;/strong&gt; 해당 데이터 베이스에 연결하면 하단에 &lt;strong&gt;application code&lt;/strong&gt;가 나옵니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a76ab49290854c5fad78ba9fdfb20274/a58ca/mongodb_3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.89873417721519%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGUlEQVR42mWSyW4TQRRF+/tYsWCD2KCwQMSZbHe7J/fk+HdYAd6Q4HbyIYgkKHFit93ueTyoKyRE4klPqnoqnbr36Uq6YWCYJrZtM5CHfJ3NuH9YcXV1za+ra5bLe7abDZtgQ7Bei16vVkRRxGw2Q1U1LNvGMAwc10EaqCMUXcPxPD70DjnzF3R1F2+Iy5y2bYnrgrDMxLy7Z2UpzovFAk3TmEwmTFyP6ekU6WikcKJraLbFwfERc98nTBJ+3txwfXtHsA3Jq5K0yKmbhqZpSPNcAH3fxzQMjpQhr/fe8bF/iKSoKrpp4noesqww9xckaS5s3y0fiKKYsiyFsqfqoE8KDV1nZOq8P9xnoKlII1UTO3Rdl+PBkPP5gqZtyfOcXZxQlBV1U1PV9TPoJVBVVRzXZWw5nHaWZXX0qND12O/1+H52xnYX8fv2ll0cU1YVnbjO7pPKl0BZlrEsG8uy8CYekjzqLI/xPI9Xb9/w+dsX8XgbJ2RFSdm0VE0rVFed0qamqMrnHWqajuN6jC0bbzJBGsgKqhi6fDrocT73SUtYBhHrMGEdpgRhQpbl/+3wx9znpC9jjC3M8ViAJU3XheUOOBgMWVxckBUF62BDGEXESUKapsRpSl4UwnpVV3+Bc2RFETnsLE+nU6Qu2KY1xnYc+v0+F5eXFG3Dchuw3e2Is4wwT0iyTHT3WZT9y6GuP+ZQ0w329g/4A2A1hlEen3jlAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Connect to cluster in mongodb&quot;
        title=&quot;&quot;
        src=&quot;/static/a76ab49290854c5fad78ba9fdfb20274/984b6/mongodb_3.png&quot;
        srcset=&quot;/static/a76ab49290854c5fad78ba9fdfb20274/4d6f2/mongodb_3.png 158w,
/static/a76ab49290854c5fad78ba9fdfb20274/3c1ae/mongodb_3.png 315w,
/static/a76ab49290854c5fad78ba9fdfb20274/984b6/mongodb_3.png 630w,
/static/a76ab49290854c5fad78ba9fdfb20274/e7d8e/mongodb_3.png 945w,
/static/a76ab49290854c5fad78ba9fdfb20274/58c38/mongodb_3.png 1260w,
/static/a76ab49290854c5fad78ba9fdfb20274/a58ca/mongodb_3.png 2876w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;application code 예시&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mongodb+srv://&amp;#x3C;본인 아이디&gt;:&amp;#x3C;패스워드&gt;@mycluster.likcia7.mongodb.net/?retryWrites=true&amp;#x26;w=majority&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3. MongoDB 연결하기&lt;/h2&gt;
&lt;h3&gt;config.js 세팅하기&lt;/h3&gt;
&lt;p&gt;위에서 생성한 &lt;strong&gt;application code&lt;/strong&gt;를 복사 붙여넣기 해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  &amp;#39;secret&amp;#39;: &amp;#39;SeCrEtKeYfOrHaShInG&amp;#39;,
  &amp;#39;mongodbUri&amp;#39;: &amp;#39;mongodb+srv://&amp;lt;본인 아이디&amp;gt;:&amp;lt;패스워드&amp;gt;@mycluster.likcia7.mongodb.net/?retryWrites=true&amp;amp;w=majority&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;secret&lt;/code&gt; 키는 이후에 JWT 토큰을 검증하는 서명 부분에 사용할 비밀 키입니다. 보안에 연관된 정보들은 config.js 파일에 보관해 줍니다.&lt;/p&gt;
&lt;p&gt;여기까지 코드작성이 완료되었다면, 터미널에서 &lt;code&gt;node app.js&lt;/code&gt;를 입력하여 서버를 실행할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;gt; node app.js

connected to mongodb server // 이렇게 뜨면 성공! 🎉&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;4. 본격 API 만들기&lt;/h2&gt;
&lt;h3&gt;Auth Routes&lt;/h3&gt;
&lt;p&gt;인증에 관련된 라우터를 구성해 줍니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;route&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;request&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/signup&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;sign up page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/login&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;login page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/signup&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;POST&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;create a new user in db&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/login&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;POST&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;authenticate a current user&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/logout&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;logout page&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;authRoutes.js&lt;/code&gt; 파일을 생성한 후, 다음과 같이 라우터를 설정해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// routes/authRoutes.js
const { Router } = require(&amp;#39;express&amp;#39;);

const router = Router();

router.get(&amp;#39;/signup&amp;#39;, () =&amp;gt; {});
router.post(&amp;#39;/signup&amp;#39;, () =&amp;gt; {});
router.get(&amp;#39;/login&amp;#39;, () =&amp;gt; {});
router.post(&amp;#39;/login&amp;#39;, () =&amp;gt; {});
router.get(&amp;#39;/logout&amp;#39;, () =&amp;gt; {})

module.exports = router;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;컨트롤러&lt;/h3&gt;
&lt;p&gt;이제 각각의 기능을 구현할 컨트롤러를 만들어 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// controllers/authController.js

module.exports.signup_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;signup&amp;#39;)
}

module.exports.login_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;login&amp;#39;)
}

module.exports.signup_post = (req, res) =&amp;gt; {
	res.send(&amp;#39;new signup&amp;#39;)
}

module.exports.login_post = (req, res) =&amp;gt; {
	res.send(&amp;#39;user login&amp;#39;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;구성한 컨트롤러를 router에 연결합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// routes/authRoutes.js

const {Router} = require(&amp;#39;express&amp;#39;);
const authController = require(&amp;#39;../controllers/authController&amp;#39;);

const router = Router();

router.get(&amp;#39;/signup&amp;#39;, authController.signup_get);
router.post(&amp;#39;/signup&amp;#39;, authController.signup_post);
router.get(&amp;#39;/login&amp;#39;, () =&amp;gt; authController.login_get);
router.post(&amp;#39;/login&amp;#39;, () =&amp;gt; authController.login_post);


module.exports = router;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;에도 이 라우터들을 연결해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...
const authRoutes = require(&amp;#39;./routes/authRoutes&amp;#39;);
...

app.use(authRoutes);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;5. Postman을 이용한 API 테스트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.postman.com/&quot;&gt;Postman&lt;/a&gt;은 프론트엔드가 구현되기 전에 서버에 대한 요청을 시뮬레이션할 수 있는 플랫폼입니다.&lt;br/&gt;
이를 통해 개발한 API를 테스트하고, 테스트 결과를 공유하여 API 개발의 생산성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f6d933c1ad2dcad32db2f3e6bacb358e/f9c26/postman.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABf0lEQVR42pVSy47UMBDMT3BjFL8dP5I4yTjZeIEs3JA48zH8fKF2dqJBggOHkl3q7nJ1t5uUEuZpgrUW3ntM0wTnHJRSEFJCKgVjDKYxYh4itJLgQoC3N7D0BjkWpGgRNENnDRrvA3xM6Pu+ClXhECofhqFyEpdSQGtV7yc0JLvBGQkTZ4hPPyHDjCbnjLTcsb1s2LYN5DgNA8K76DiO9YGu6y6QY601lLbVsYwZH3/8AusLmnleEKJDKTuO4w3DOMIaDWsN2rYFY6yijkCIi9OdRBnjYO0N+vYBirdoKNE4i7yu2PcdMUZwzmsBnQ/8jVPtyQWEpAclGrLfeYdlWTDPc22Jkh5OCM9CFYzwHmP8yqezClpncc+5OiTR4B1c19WFUPxcirwEafNSK0ianz5/AsXJdaOVge80XtYVpZTqNHhfN26svURpXs/tPsDFyS9BFz1CirjvGeX1Feu61qLnhfyz9Sc8FtXcvxWs3z+jPzK+fD1wHMcfbv4HJPgbj0Mjf3elS8EAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Postman&quot;
        title=&quot;&quot;
        src=&quot;/static/f6d933c1ad2dcad32db2f3e6bacb358e/984b6/postman.png&quot;
        srcset=&quot;/static/f6d933c1ad2dcad32db2f3e6bacb358e/4d6f2/postman.png 158w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/3c1ae/postman.png 315w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/984b6/postman.png 630w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/e7d8e/postman.png 945w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/58c38/postman.png 1260w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/f9c26/postman.png 2880w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Postman을 통해 생성한 api 주소로 각 요청을 보내 연결이 잘 되는지 확인할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;6. model&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mongoose&lt;/code&gt;를 통해 유저 정보를 MongoDB에 넣을때, 스키마를 만들어야 합니다.&lt;br/&gt;
스키마란 기본적으로 데이터베이스에서 사용자 데이터나 기록이 어떻게 표시되어야 하는지를 정의합니다.&lt;br/&gt;
해당 파트에서 유효성 문구 등을 직접 설정할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// models/User.js

const mongoose = require(&amp;#39;mongoose&amp;#39;);
const { isEmail } = require(&amp;#39;validator&amp;#39;);

const userSchema = new mongoose.Schema({
	email: {
		type: String,
		required: [true, &amp;#39;Please enter an email&amp;#39;],
		unique: true,
		lowercase: true,
		validate: [isEmail, &amp;#39;Please enter a valid email&amp;#39;]
	},
	password: {
		type: String,
		required: [true, &amp;#39;Please enter a password&amp;#39;],
		minlength: [6, &amp;#39;Minimum password length is 6 characters&amp;#39;]
	},
});

const User = mongoose.model(&amp;#39;user&amp;#39;, userSchema);

module.exports = User;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다시 컨트롤러로 돌아가서 유저 모델을 연결해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// controllers/authController.js
const User = require(&amp;#39;../models/User&amp;#39;);

// handle errors
const handleErrors = (err) =&amp;gt; {
	console.log(err.message, err.code);
	let error = { email: &amp;#39;&amp;#39;, password: &amp;#39;&amp;#39;};

	// duplicate error code
	if (err.code === 11000) {
		errors.email = &amp;#39;that email is aleady registered&amp;#39;;
		return errors;
	}

	// validation errors
	if (err.message.includes(&amp;#39;user validation failed&amp;#39;)) {
		Object.values(err.errors).forEach(({properties}) =&amp;gt; {
			error[properties.path] = properties.message;
		})
	}

	return errors;
}

module.exports.signup_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;signup&amp;#39;)
}

module.exports.login_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;login&amp;#39;)
}

module.exports.signup_post = async (req, res) =&amp;gt; {
	const {email, password} = req.body;

	try {
		const user = await User.create({ email, password }); // 유저 생성
		res.status(201).json(user);
	}
	catch (err) {
		const errors = handleErrors(err);
		res.status(400).json({errors})
	}
}

module.exports.login_post = async (req, res) =&amp;gt; {
	const {email, password} = req.body;

	console.log(email, password);
	res.send(&amp;#39;user login&amp;#39;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;비밀번호 해시처리&lt;/h3&gt;
&lt;p&gt;현재 유저정보가 DB에 잘 쌓이고 있는데, 비밀번호가 그대로 드러나고 있습니다.&lt;br/&gt;
이를 방지하기 위해, &lt;code&gt;bcrypt&lt;/code&gt; 라이브러리를 사용하여 비밀번호를 암호화 시켜줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// User.js

const mongoose = require(&amp;#39;mongoose&amp;#39;);
const { isEmail } = require(&amp;#39;validator&amp;#39;);
const bcrypt = require(&amp;#39;bcrypt&amp;#39;);

const userSchema = new mongoose.Schema({
	email: {
		type: String,
		required: [true, &amp;#39;Please enter an email&amp;#39;],
		unique: true,
		lowercase: true,
		validate: [isEmail, &amp;#39;Please enter a valid email&amp;#39;]
	},
	password: {
		type: String,
		required: [true, &amp;#39;Please enter a password&amp;#39;],
		minlength: [6, &amp;#39;Minimum password length is 6 characters&amp;#39;]
	},
});

// fire a function before doc saved to db
userSchema.pre(&amp;#39;save&amp;#39;, async function (next) {
	const salt = await bcrypt.genSalt();
	this.password = await bcrypt.hash(this.password, salt);
	
	next();
})

const User = mongoose.model(&amp;#39;user&amp;#39;, userSchema);

module.exports = User;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;데이터가 저장되기 전에(&lt;code&gt;pre&lt;/code&gt;) 비밀번호를 해시 처리해서 암호화 시켜줍니다.&lt;/p&gt;
&lt;h3&gt;Cookies&lt;/h3&gt;
&lt;p&gt;쿠키는 클라이언트 개개인의 상태 정보를 담고 있는 데이터입니다.&lt;br/&gt;
다음과 같은 방법으로 브라우저에 쿠키를 생성할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js

// cookies
app.get(&amp;#39;/set-cookies&amp;#39;, (req, res) =&amp;gt; {
	res.setHeader(&amp;#39;Set-Cookie&amp;#39;, &amp;#39;newUser=true&amp;#39;);
	// 또는
	res.cookie(&amp;#39;newUser&amp;#39;, false);
	
	res.send(&amp;#39;you got the cookies!&amp;#39;);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 여기서 주의할 점!&lt;/p&gt;
&lt;p&gt;쿠키는 javascript의 document.cookie를 통해 접근할 수 있기 때문에, 해킹 당할 위험이 있다.
이를 보호하기 위해 HttOnly나 Secure 속성을 설정할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;res.cookie(&amp;#39;test&amp;#39;, true, { httpOnly: true })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 httpOnly 옵션을 추가하면, 클라이언트의 환경(웹 브라우저)에서 스크립트(javascript 등)로 쿠키에 접근하는 것을 차단할 수 있다. 이 설정을 함으로써 XSS(Cross Site Script) 공격에 대응이 가능하다.&lt;/p&gt;
&lt;p&gt;추가로, 쿠키의 만료날짜를 설정할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const maxAge = 60 * 60 * 24 * 2;  // 60초 * 60분 * 24시간 * 2일

res.cookie(&amp;#39;jwt&amp;#39;, token, { httpOnly: true, maxAge: maxAge * 1000 })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;7. JSON Web Tokens&lt;/h2&gt;
&lt;p&gt;JWT(JSON Web Token)란 &lt;strong&gt;인증에 필요한 정보들을 암호화시킨 JSON 토큰&lt;/strong&gt;을 의미합니다.&lt;br/&gt;
그리고 JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식입니다.&lt;br/&gt;
JWT는 .을 구분자로 나누어지는 세 가지 문자열의 조합입니다.&lt;br/&gt;
.을 기준으로 &lt;code&gt;Header&lt;/code&gt;, &lt;code&gt;Payload&lt;/code&gt;, &lt;code&gt;Signature&lt;/code&gt;로 구성되어 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a688b3536a0be435f268132ae32083a2/7e08f/jsonwebtoken.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7ElEQVR42mWS204bMRBA+RhYjz2+7C3XTUIpIoQgQi5tIpUi9f9/4lTetISqD2dn5ZGPPeO5KsTxlxtxXIv9FM9c8vlfKaynsHrm0/7MVf6YP4KRSfwsOnZmzFsxZS1jHsKOlT+c0T3taku7OzE8vNFujkhquCnkX+H5RlmsrM2Qb2bC1owZ2Mg0PLAOJ+7Dhqne4b8uqQ+/KDcn0tOeQgPXxlyEWWZFiaJ4sSSjVOJJ4vHGEiUxkI5GRpSmxZuKpBOitERpiFITpMaI58ZYrnKppSRe3TObnnXPzr2wtU/Mxs9MZyduZ2/cdj/ouiOL6Yl5ZrRnMT3SDXdYCX2Pzz3UQOUbWh1QaoMLFdaXJD+mSh0xjZBYUsRA4T2mTEg7PFM3mOAR9eeSjVV8LJlpw522jLQiphrrPcM440taMYm3eF8SywoNJWEwo75/JU3v8NUAmx2hJLt6ofORoSQ6qZhIiQuR4GpGuqDVjrkuGegcq0pcrKhf3ilXR8L8kbBYYasRLlYXodXAoIjMTEljAoXmB6p58Fse/Z5teKeyY4wV3HBBevxOXB5IywNh8YQJNdaFi1B9xKjnRn0fNaS+xHyQ04TT2Pcol5Vvktetj30UI1iXq0yXOcwTb/7D9RR/+FgX95E74z9yeWx+AxitWTHNxlT2AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;jsonwebtoken&quot;
        title=&quot;&quot;
        src=&quot;/static/a688b3536a0be435f268132ae32083a2/984b6/jsonwebtoken.png&quot;
        srcset=&quot;/static/a688b3536a0be435f268132ae32083a2/4d6f2/jsonwebtoken.png 158w,
/static/a688b3536a0be435f268132ae32083a2/3c1ae/jsonwebtoken.png 315w,
/static/a688b3536a0be435f268132ae32083a2/984b6/jsonwebtoken.png 630w,
/static/a688b3536a0be435f268132ae32083a2/e7d8e/jsonwebtoken.png 945w,
/static/a688b3536a0be435f268132ae32083a2/7e08f/jsonwebtoken.png 1186w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Header&lt;/code&gt; 에는 JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있으며, &lt;code&gt;Payload&lt;/code&gt; 는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있습니다. &lt;code&gt;Signature&lt;/code&gt;에는 Header, Payload 를 Base64 URL-safe Encode를 한 이후 Header에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// controllers/authController.js
...
const jwt = require(&amp;#39;jsonwebtoken&amp;#39;);
...

const maxAge = 3 * 24 * 60 * 60;  // three days
const createToken = (id) =&amp;gt; {
	return jwt.sign({ id }, config.secret, {
		expiresIn: maxAge
	});
} 

...

module.exports.signup_post = async (req, res) =&amp;gt; {
	const {email, password} = req.body;

	try {
		const user = await User.create({ email, password });
		const token = createToken(user._id);
		res.cookie(&amp;#39;jwt&amp;#39;, token, { httpOnly: true, maxAge: maxAge * 1000 })
		res.status(201).json({ user: user._id });
	}
	catch (err) {
		const errors = handleErrors(err);
		res.status(400).json({errors})
	}
}
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;JWT를 이용한 인증 과정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.&lt;/li&gt;
&lt;li&gt;서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다.Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장할 수도 있음)API를 서버에 요청할때 &lt;strong&gt;Authorization header에 Access Token을 담아&lt;/strong&gt;서 보낸다.&lt;/li&gt;
&lt;li&gt;서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.&lt;/li&gt;
&lt;li&gt;클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용해서&lt;/li&gt;
&lt;li&gt;서버로부터 새로운 엑세스 토큰을 발급 받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;라우트 보호하기&lt;/h3&gt;
&lt;p&gt;요청에 jwt가 있는지 확인하고, jwt가 문제가 없는지 확인하는 과정입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// middleware/authMiddleware.js

const jwt = require(&amp;#39;jsonwebtoken&amp;#39;);

const config = require(&amp;#39;../config.js&amp;#39;);

const requireAuth = (req, res, next) =&amp;gt; {
	const token = req.cookies.jwt;
	
	// check json web token exists &amp;amp; is verified
	if (token) {
		jwt.verify(token, config.secret, (err, decodedToken) =&amp;gt; {
			if (err) {
				console.log(err.message);
				res.redirect(&amp;#39;/login&amp;#39;);
			} else {
				console.log(decodedToken);
				next();
			}
		})
	} else {
		res.redirect(&amp;#39;/login&amp;#39;);
	}
}

module.exports = { requireAuth }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;jwt 토큰이 없거나, 유효하지 않은 경우 login 페이지로 넘어가도록 리다이렉트 해 줍니다.&lt;/p&gt;
&lt;p&gt;유효한 토큰이 있는 경우에만 접근할 수 있는 페이지에 해당 middleware를 추가합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js

app.get(&amp;#39;/home&amp;#39;, requireAuth, (req, res) =&amp;gt; res.render(&amp;#39;home&amp;#39;));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;8. 로그아웃&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// AuthController.js

module.exports.logout_get = (req, res) =&amp;gt; {
	res.cookie(&amp;#39;jwt&amp;#39;, &amp;#39;&amp;#39;, { maxAge: 1 });
	res.redirect(&amp;#39;/&amp;#39;);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;로그아웃은 controller에서 jwt라는 키를 가진 쿠키를 지워줍니다.&lt;/p&gt;
&lt;h3&gt;현재 유저 확인&lt;/h3&gt;
&lt;p&gt;ejs는 서버로부터 받은 데이터를 가공하여 클라이언트에서 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이를 위해 변수를 초기화하는 미들웨어를 작성합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// authMiddleware.js

...

//check current user
const checkUser = (req, res, next) =&amp;gt; {
	const token = req.cookies.jwt;
	
	if (token) {
		jwt.verify(token, config.secret, async (err, decodedToken) =&amp;gt; {
			if (err) {
				console.log(err.message);
				res.locals.user = null;
				next();
			} else {
				console.log(decodedToken);
				let user = await User.findById(decodedToken.id);
				res.locals.user = user;
				next();
			}
		})
	} else {
		res.locals.user = null;
		next();
	}
}

module.exports = {requireAuth, checkUser};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;res.locals.[variable]&lt;/code&gt; 을 통해 클라이언트에 변수를 전달할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js
const { requireAuth, checkUser } = require(&amp;#39;./middleware/authMiddleware&amp;#39;);

...
app.get(&amp;#39;*&amp;#39;, checkUser); // every single get request
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;app.js에 checkUser를 가져와 모든(&lt;code&gt;*&lt;/code&gt;) get request에서 현재 유저를 확인하는 코드를 추가합니다.&lt;/p&gt;
&lt;p&gt;여기서 생긴 궁금증!&lt;/p&gt;
&lt;h3&gt;middleware란 무엇인가?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;middleware의 사전적 정의&lt;/p&gt;
&lt;p&gt;미들웨어는 양 쪽을 연결하여 데이터를 주고 받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어, 네트워크를 통해서 연결된 여러 개의 컴퓨터에 있는 많은 프로세스들에게 어떤 서비스를 사용할 수 있도록 연결해 주는 소프트웨어를 말한다. 3계층 클라이언트/서버 구조에서 미들웨어가 존재한다. 웹 브라우저에서 데이터베이스로부터 데이터를 저장하거나 읽어올 수 있게 중간에 미들웨어가 존재하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;광범위한 설명이지만 다음 2개의 키워드가 미들웨어의 역할이라고 생각합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;양쪽을 연결&lt;/li&gt;
&lt;li&gt;중간에서의 매개 역할&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;큰 범위로 보면 매개체 간 연결해주는 레이어로써, 매개체는 클라이언트(사용자) - 서버, 서버 - 서버 간의 통신이 될 수도 있습니다.&lt;br/&gt;
통상적으로 기업에서 말하는 미들웨어 환경은 웹/어플리케이션 서버를 의미합니다.&lt;/p&gt;
&lt;p&gt;ejs 템플릿을 사용한 프론트 단은 따로 내용에 작성하지 않았습니다.&lt;/p&gt;
&lt;p&gt;모든 코드는 &lt;a href=&quot;https://github.com/kirahaa/auth-with-jwt&quot;&gt;github 레포지토리&lt;/a&gt; 참고 부탁드립니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;여기까지, JWT 인증 시스템 구현이 끝났습니다!&lt;br/&gt;
JWT 인증은 해도 해도 어려운 것 같아요😥 다음에는 REACT 환경에서 JWT 인증을 구현해 보는 것도 도전해 보기로!&lt;/p&gt;
&lt;p&gt;다음 포스팅에서는 AWS 프리티어를 이용해서 웹 호스팅 서버를 만드는 과정을 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;가보자고~!💨&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;참고 자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=SnoAwLP1a-0&amp;#x26;list=PL4cUxeGkcC9iqqESP8335DA5cRFp8loyp&quot;&gt;https://www.youtube.com/watch?v=SnoAwLP1a-0&amp;#x26;list=PL4cUxeGkcC9iqqESP8335DA5cRFp8loyp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://velopert.com/2448&quot;&gt;https://velopert.com/2448&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC&quot;&gt;https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daleseo.com/js-jwt/&quot;&gt;https://www.daleseo.com/js-jwt/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Gatsby 블로그 꾸미기]]></title><description><![CDATA[…]]></description><link>https://kirahaa.github.io/custom-gatsby-blog/</link><guid isPermaLink="false">https://kirahaa.github.io/custom-gatsby-blog/</guid><pubDate>Sat, 01 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;자, 이제 본격적으로 나만의 블로그를 예쁘게 꾸며볼 시간입니다!😆&lt;/p&gt;
&lt;p&gt;개츠비에는 워낙 다양한 플러그인들이 많아서 잘 활용해서 사용하면 많은 것들을 할 수 있습니다!&lt;br/&gt;
여러 테크 블로그들을 돌아다니면서 블로그 구조, 폰트, 코드 블록 등 다양한 디자인들을 참고해서 나에게 맞는 기능들만 쏙쏙 골라서 꾸며봅시다!✨&lt;/p&gt;
&lt;h2&gt;1. 코드 블록&lt;/h2&gt;
&lt;p&gt;다양한 테마의 코드 블록들 중에서 저는 iOS UI의 vsCode를 고대로 옮겨놓은 듯한 코드 블록들이 눈길이 가더라구요!&lt;/p&gt;
&lt;h3&gt;설치하기&lt;/h3&gt;
&lt;p&gt;가장 간단한 방법은 &lt;a href=&quot;https://docs.deckdeckgo.com/?path=/docs/components-highlight-code--highlight-code&quot;&gt;해당 페이지&lt;/a&gt;를 참고하면 손쉽게 예쁜 코드 블록을 불러올 수 있습니다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install @deckdeckgo/highlight-code&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;적용하기&lt;/h3&gt;
&lt;p&gt;이제 &lt;code&gt;layout.js&lt;/code&gt;에서 해당 패키지를 불러오면 됩니다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { defineCustomElements as deckDeckGoHighlightElement } from &amp;quot;@deckdeckgo/highlight-code/dist/loader&amp;quot;

// ... 생략

deckDeckGoHighlightElement()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;2. 폰트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/plugins/gatsby-omni-font-loader/&quot;&gt;gatsby-omni-font-loader&lt;/a&gt; 플러그인을 통해 웹폰트나 커스텀 폰트를 적용할 수 있습니다!&lt;/p&gt;
&lt;h3&gt;설치하기&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install gatsby-omni-font-loader react-helmet&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;적용하기&lt;/h3&gt;
&lt;p&gt;잘 설치가 되었다면, &lt;code&gt;gatsby-config.js&lt;/code&gt; 파일에 사용하고 싶은 폰트들을 가져오면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;plugins: [
    {
      resolve: `gatsby-omni-font-loader`,
      options:{
        enableListener: true,
        preconnect: [`https://fonts.googleapis.com`, `https://fonts.gstatic.com`],
        web: [
          {
            name: `Inter`,
            file: `https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800&amp;amp;display=swap`,
          },
          {
            name: `Pretendard`,
            file: `https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard-dynamic-subset.css`,
          },
        ]
      }
    },
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;저는 &lt;strong&gt;Inter&lt;/strong&gt;, &lt;strong&gt;Pretendard&lt;/strong&gt; 폰트를 불러왔는데요, 적용해본 결과 &lt;strong&gt;Pretendard&lt;/strong&gt; 폰트가 더 깔끔하니 마음에 들어서 해당 폰트를 추가해 주었습니다!&lt;/p&gt;
&lt;p&gt;이제 css 파일로 가서, 해당 폰트를 적용해 주면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;--fontFamily-pretendard: Pretendard, -apple-system, BlinkMacSystemFont, &amp;quot;Noto Sans&amp;quot;, ...;
--font-body: var(--fontFamily-pretendard);

body {
    font-family: var(--font-body);
    font-size: var(--fontSize-1);
    color: var(--color-text);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[Gatsby로 Github 블로그 만들기]]></title><description><![CDATA[안녕하세요! 드디어 저의 깃허브 블로그 첫 포스팅입니다✨ 개발을 하면서 가장 중요하게 해 나가야 할 것 중 하나가 기록이 아닐까 싶은데요!
저는 그동안 이런저런 블로그(velog, notion…]]></description><link>https://kirahaa.github.io/make-gatsby-blog/</link><guid isPermaLink="false">https://kirahaa.github.io/make-gatsby-blog/</guid><pubDate>Thu, 29 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;안녕하세요! 드디어 저의 깃허브 블로그 첫 포스팅입니다✨&lt;/p&gt;
&lt;p&gt;개발을 하면서 가장 중요하게 해 나가야 할 것 중 하나가 &lt;strong&gt;기록&lt;/strong&gt;이 아닐까 싶은데요!&lt;br/&gt;
저는 그동안 이런저런 블로그(velog, notion 등..)들을 전전하면서 항상 구조, 테마 등의 아쉬움이 있었습니다.&lt;/p&gt;
&lt;p&gt;그러다가 직접 나만의 블로그를 만들어보자! 해서 여기까지 왔습니다ㅎㅎㅎ&lt;br/&gt;
(심지어 깃허브를 통해 배포하는 거라, 제 잔디까지 심고 일석이조?😆)&lt;/p&gt;
&lt;h2&gt;What&apos;s Gatsby?&lt;/h2&gt;
&lt;p&gt;우선! Gatsby가 무엇일까요?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 Gatsby는 프론트엔드 라이브러리 React를 기반으로 하는 JAM Stack 기반의 정적 사이트 생성 프레임워크 입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;JAM Stack?&lt;/h2&gt;
&lt;p&gt;JAM Stack의 JAM은 &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Api&lt;/code&gt;, &lt;code&gt;Markup&lt;/code&gt;의 약자입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/07739e60560cbfb946628208f160ff99/451a4/jamstack.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.202531645569614%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHdi4LGB//EABgQAAIDAAAAAAAAAAAAAAAAAAEyAhAx/9oACAEBAAEFAgwyC3//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAAREgMf/aAAgBAQAGPwJjNmn/xAAZEAEAAwEBAAAAAAAAAAAAAAABABEhEEH/2gAIAQEAAT8hV6RVovuxjhUy3pP/2gAMAwEAAgADAAAAEDMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAAICAgMAAAAAAAAAAAAAAQARIUEQYTFx8f/aAAgBAQABPxAQCaxWhPsuLSXIY6IBLKpRV7rjU8H3P//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;JAM Stack&quot;
        title=&quot;&quot;
        src=&quot;/static/07739e60560cbfb946628208f160ff99/af1fa/jamstack.jpg&quot;
        srcset=&quot;/static/07739e60560cbfb946628208f160ff99/ab180/jamstack.jpg 158w,
/static/07739e60560cbfb946628208f160ff99/ba98e/jamstack.jpg 315w,
/static/07739e60560cbfb946628208f160ff99/af1fa/jamstack.jpg 630w,
/static/07739e60560cbfb946628208f160ff99/23301/jamstack.jpg 945w,
/static/07739e60560cbfb946628208f160ff99/78e18/jamstack.jpg 1260w,
/static/07739e60560cbfb946628208f160ff99/451a4/jamstack.jpg 2000w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;즉, Javascript &amp;#x26; Markup으로 정적 페이지를 표시하고, 필요 시에 API를 통해 데이터를 호출하는 것입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전통적 웹 사이트: 서버에 요청하면 SSR을 통해 HTML을 만들어 제공&lt;/li&gt;
&lt;li&gt;SPA: 처음 요청받은 페이지만 SSR로 제공하고 나머지는 CSR로 제공&lt;/li&gt;
&lt;li&gt;JAM Stack: 각 페이지를 HTML로 Pre-Render하여 캐싱 후 CDN에서 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h4&gt;Javascript&lt;/h4&gt;
&lt;p&gt;Client의 모든 처리는 Javascript에 맞긴다.&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;p&gt;모든 기능 및 비즈니스 로직은 재사용 가능한 API로 추상화한다.&lt;/p&gt;
&lt;h4&gt;Markup&lt;/h4&gt;
&lt;p&gt;SSG (Static Site Generator)나 Template Engine(Webpack 등)을 이용하여 Markup을 미리 생성한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 제일 중요한 부분이 &lt;code&gt;Markup&lt;/code&gt;입니다.&lt;/p&gt;
&lt;h3&gt;Markup&lt;/h3&gt;
&lt;p&gt;Markup을 만들 수 있는 방법은 매우 다양한데,&lt;/p&gt;
&lt;p&gt;HTML을 직접 작성하거나, &lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_web_template_engines&quot;&gt;Template Engine&lt;/a&gt; 같은 툴을 이용하거나,
&lt;code&gt;Jekyll (ruby)&lt;/code&gt;, &lt;code&gt;Hugo (go)&lt;/code&gt;, &lt;code&gt;Nuxt (vue)&lt;/code&gt;, &lt;code&gt;Next (react)&lt;/code&gt;, &lt;code&gt;Gatsby&lt;/code&gt; 같은 &lt;strong&gt;정적 사이트 생성기 (Static Site Generator, SSG)&lt;/strong&gt; 를 이용해서,
&lt;strong&gt;Static HTML&lt;/strong&gt;을 생성할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;그리고 미리 작성된 &lt;strong&gt;Static HTML&lt;/strong&gt;은 웹서버의 리소스를 쓸 필요 없이, 사용자에게 HTML만을 전달해주면 됩니다.&lt;/p&gt;
&lt;p&gt;이는 매우 큰 장점을 가져오게 되는데, Static HTML을 CDN을 통해 Cache하고 배포하여, 빠른 속도를 유지합니다.&lt;/p&gt;
&lt;p&gt;따로 동적으로 HTML을 생성하지 않기 때문에, 따로 웹서버가 필요 없어 서버 비용이 높지 않습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자 그럼, 마크업은 뭘로 하는게 좋을까? 고민하신다면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원페이지, 위키, 블로그 등 정적 콘텐츠가 대부분이고 볼륨이 가볍다 ? =&gt; &lt;code&gt;Gatsby&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;동적 데이터 활용도가 많고 컨텐츠 양이 점점 많아질 것으로 예상된다 ? =&gt; &lt;code&gt;Next.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;저는 이러한 이유로 개츠비를 선택하게 되었습니다. 🙌&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;다뤄보기&lt;/h2&gt;
&lt;h3&gt;프로젝트 생성&lt;/h3&gt;
&lt;p&gt;요구조건: &lt;code&gt;Node.js 18.0.0+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;node 버전은 18 이상이어야 합니다. 저는 회사에서 버전 16을 사용하고 있었기 때문에, 버전을 변경해주어야 했습니다.
&lt;code&gt;nvm&lt;/code&gt;을 이용하면 노드 버전을 스위칭하여 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nvm(node version manager): 여러개의 노드 버전을 사용할 수있는 도구&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ nvm list  # 사용가능한 node 버전 리스트 확인

    18.16.0
    18.15.0 
    16.18.1
  * 16.17.1 (Currently using 64-bit executable)
    14.16.0

# 원하는 버전이 없다면 설치
$ nvm install {원하는 버전}

# 원하는 버전으로 변경
$ nvm use {원하는 버전}

# 변경된 노드 버전 확인
$ node -v 
v18.15.0&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자 이제 노드 버전을 변경해 줬으니, 본격적으로 개츠비를 설치해봅시다!&lt;/p&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install -g gatsby-cli&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;테마 선택하기&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/starters/&quot;&gt;Gatsby Starter&lt;/a&gt; 사이트에 다양한 테마들이 있는데요!
저는 &lt;a href=&quot;https://www.gatsbyjs.com/starters/gatsbyjs/gatsby-starter-blog/&quot;&gt;gatsby-starter-blog&lt;/a&gt; 테마를 선택했습니다.&lt;br/&gt;
gatsby 명령어를 사용하여 blog라는 디렉토리에 블로그의 소스코드를 가져옵니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ gatsby new blog https://github.com/gatsbyjs/gatsby-starter-blog&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;설치가 완료되면 현재 위치에 blog라는 디렉토리가 생성되고, 이 안에 각종 파일이 생성됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ cd blog # 생성된 디렉토리로 들어가서,

$ npm develop # 로컬 서버를 띄워준다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 브라우저(chrome)을 열고 주소창에 localhost:8000으로 접속해보세요.&lt;br/&gt;
아래와 같은 화면이 뜨면 성공입니다! 🎉&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b1e503ec15caf002fdb3423f4a6a855a/efd2f/gatsby-starter-blog.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 114.55696202531647%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe3qU0CaAD//xAAXEAEAAwAAAAAAAAAAAAAAAAABABEw/9oACAEBAAEFAqgYf//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABcQAQADAAAAAAAAAAAAAAAAACAxQaH/2gAIAQEABj8CnRZ//8QAGxAAAQQDAAAAAAAAAAAAAAAAAQAQITERQYH/2gAIAQEAAT8hMiggNnpbbsTT/wD/2gAMAwEAAgADAAAAEDPIAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB4QAQACAgEFAAAAAAAAAAAAAAEAESFBEDFRcYGx/9oACAEBAAE/ELMwVwD+S1WWVlYXuN386uY7wdN+4ESC3fP/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;gatsby-starter-blog&quot;
        title=&quot;&quot;
        src=&quot;/static/b1e503ec15caf002fdb3423f4a6a855a/af1fa/gatsby-starter-blog.jpg&quot;
        srcset=&quot;/static/b1e503ec15caf002fdb3423f4a6a855a/ab180/gatsby-starter-blog.jpg 158w,
/static/b1e503ec15caf002fdb3423f4a6a855a/ba98e/gatsby-starter-blog.jpg 315w,
/static/b1e503ec15caf002fdb3423f4a6a855a/af1fa/gatsby-starter-blog.jpg 630w,
/static/b1e503ec15caf002fdb3423f4a6a855a/efd2f/gatsby-starter-blog.jpg 757w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Gatsby Blog 기본 세팅하기&lt;/h3&gt;
&lt;p&gt;이제 복사해온 사이트의 정보를 저의 정보로 수정해 봅시다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gatsby-config.js&lt;/code&gt; - 블로그와 관련된 설정을 하는 파일&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
    siteMetadata: {
        title: `Kirahaa`,
        author: {
            name: `Hayeong Kim`,
            summary: `I believe the importance of experience`,
        },
        description: `kirahaa blog`,
        siteUrl: `https://kirahaa.github.io/`,
    },
// ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; - 프로젝트 정보 수정&lt;/p&gt;
&lt;p&gt;package.json 파일 내에 기본 정보들을 수정해주고,
&quot;scripts&quot; 내에 &lt;strong&gt;deploy&lt;/strong&gt; 명령어를 추가해서 다음과 같이 적어주세요.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;kirahaa-blog&amp;quot;,
  &amp;quot;private&amp;quot;: false,
  &amp;quot;description&amp;quot;: &amp;quot;kirahaa blog&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;Hayeong Kim &amp;lt;khy4018@gmail.com&amp;gt;&amp;quot;,
  &amp;quot;bugs&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;https://github.com/kirahaa/kirahaa.github.io/issues&amp;quot;
  },
  // ...
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;deploy&amp;quot;: &amp;quot;gatsby build &amp;amp;&amp;amp; gh-pages -d public -b master&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;앞으로 포스팅 작성을 완료하고, 로컬에서 잘 확인했으면 &lt;code&gt;npm run deploy&lt;/code&gt; 명령어로 배포합니다.&lt;/p&gt;
&lt;p&gt;이때 소스코드 빌드 후의 public 폴더를 github master 브랜치에 push한다는 뜻이고, 이 소스 코드로 &lt;a href=&quot;https://kirahaa.github.io/&quot;&gt;https://kirahaa.github.io/&lt;/a&gt;에 배포됩니다.&lt;/p&gt;
&lt;h3&gt;github.io repo 만들기&lt;/h3&gt;
&lt;p&gt;이제 자신의 github에 소스코드를 올리면 됩니다!&lt;/p&gt;
&lt;p&gt;github에 접속해서 새로운 repository(이하 repo)를 만들어주세요. 그런데 repo 이름에 유의하셔야 합니다!&lt;br/&gt;
github의 &lt;strong&gt;usename&lt;/strong&gt; 뒤에 &lt;strong&gt;.github.io&lt;/strong&gt;을 붙여서 만들어주세요. 제 &lt;strong&gt;github username&lt;/strong&gt;은 kirahaa이기 때문에
&lt;code&gt;kirahaa.github.io&lt;/code&gt;로 만들었습니다. &lt;br/&gt;
공개범위는 &lt;strong&gt;Public&lt;/strong&gt;으로 만들어주세요😉&lt;/p&gt;
&lt;h3&gt;배포하기&lt;/h3&gt;
&lt;p&gt;먼저, 저희는 &lt;code&gt;gh-pages&lt;/code&gt;로 배포할 것이기 때문에 gh-pages package를 설치해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install gh-pages --save-dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 로컬에 있는 블로그 소스코드를 github에 올려봅시다!&lt;/p&gt;
&lt;p&gt;블로그 root에서 git을 세팅합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git init
$ git remote add origin https://github.com/kirahaa/kirahaa.github.io.git&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음 명령어로 origin 주소가 잘 연결되었는지 확인해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git remote -v&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;푸시를 해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git add .
$ git commit -m &amp;quot;first commit&amp;quot;
$ git push origin master&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;github에서 소스코드가 잘 올라갔는지 확인해 주세요.&lt;/p&gt;
&lt;p&gt;잘 됐으면 배포 명령어를 실행합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm run deploy&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;정상적으로 배포가 되었다면, github 사이트의 블로그 repo에 가서 master에 올라온 소스코드를 확인해 주세요.&lt;br/&gt;
저희가 원래 받았던 소스코드와 구조가 완전히 다르죠?! 여기서 놀라지 마시구,, 😁&lt;/p&gt;
&lt;p&gt;해당 소스는 포스팅을 작성하고 커스터마이징 할 수 있는 개발 소스가 아니라 블로그 사이트에 배포될 수 있도록 .md 파일이 모두 html, js로 바뀐 빌드된 파일입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm run deploy&lt;/code&gt; 명령어가 알아서 build도 해주고, git의 master 브랜치에 push도 해주고 배포도 해준 것입니다.&lt;/p&gt;
&lt;p&gt;앞으로 항상 deploy만 해줘도 되지만, 다른 컴퓨터에서 포스팅을 작성할 경우를 대비하여 개발코드도 저장해주도록 합시다!&lt;br/&gt;
develop이라는 브랜치를 따로 만들어서 여기에다만 올리도록 하겠습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git branch develop  # develop 브랜치 생성

$ git checkout develop  # develop 브랜치로 체크아웃&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;동일하게 소스코드를 git에 push해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git add .
$ git commit -m &amp;quot;blog posting~&amp;quot;
$ git push -u origin develop&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;내 github의 develop repo에 들어가서 소스코드가 모두 잘 올라갔는지 확인해 주세요.&lt;/p&gt;
&lt;p&gt;잘 올라갔다면 github default 브랜치를 develop으로 바꾸겠습니다.&lt;br/&gt;
어차피 빌드 결과물인 master 브랜치의 빌드 파일들을 파악할 필요도 없으니까요.&lt;br/&gt;
github의 해당 블로그 repo에 들어가서 &lt;strong&gt;Setting &gt; Branches&lt;/strong&gt; 메뉴에서 Default branch를 devleop으로 바꾸고 update 버튼을 눌러주세요!&lt;/p&gt;
&lt;p&gt;이제 각자의 &lt;strong&gt;username.github.io&lt;/strong&gt;에 들어가서 배포된 블로그를 확인해 보세요!&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;여기까지, 가장 기본적인 블로그 세팅이 끝났습니다!&lt;br/&gt;
다음 포스팅에서는 &lt;strong&gt;개츠비 플러그인을 사용해 블로그 커스텀하는 법&lt;/strong&gt;을 더 자세히 살펴보겠습니다!&lt;/p&gt;
&lt;p&gt;다음 포스팅도 기대해주세욧 😉✨&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h4&gt;참고 자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://anneslab.tistory.com/116&quot;&gt;https://anneslab.tistory.com/116&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yeri-kim.github.io/posts/how-to-install-gatsby/&quot;&gt;https://yeri-kim.github.io/posts/how-to-install-gatsby/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://uzzam.dev/6&quot;&gt;https://uzzam.dev/6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7&quot;&gt;https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>