<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[kirahaa blog]]></description><link>https://kirahaa.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 30 Jan 2024 08:45:30 GMT</lastBuildDate><item><title><![CDATA[노개북 - 클린코드 Assignment 04]]></title><description><![CDATA[📌 1주차 - Assignment #04 📚 TIL (2024.01.29) -…]]></description><link>https://kirahaa.github.io/clean-code-04/</link><guid isPermaLink="false">https://kirahaa.github.io/clean-code-04/</guid><pubDate>Mon, 29 Jan 2024 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;📌 &lt;strong&gt;1주차 - Assignment #04&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;📚 TIL (2024.01.29) - 3장. 함수&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3&gt;🎈 책에서 기억하고 싶은 내용을 써보세요.&lt;/h3&gt;
&lt;h4&gt;함수를 잘 만드는 법&lt;/h4&gt;
&lt;h5&gt;작게 만들어라!&lt;/h5&gt;
&lt;p&gt;함수를 만드는 첫째 규칙은 &apos;작게!&apos;다.
함수를 만드는 둘째 규칙은 &apos;더 작게!&apos;다.&lt;br/&gt;
함수는 일반적으로 2 ~ 4줄 정도로 짧게하는 것이 좋다.
중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다.&lt;br/&gt;
그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.
당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다.&lt;/p&gt;
&lt;h5&gt;한 가지만 해라!&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;&quot;함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.&quot;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
어쨌거나 우리가 함수를 만드는 이유는 큰 개념을 (다시 말해, 함수 이름을) 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서가 아니던가.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;함수가 &apos;한 가지&apos;만 하는지 판단하는 방법&lt;/strong&gt; - 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.&lt;/p&gt;
&lt;h5&gt;Switch 문&lt;/h5&gt;
&lt;p&gt;switch 문은 작게 만들기 어렵다!
다형적 객체를 생성하는 코드 안에서만 꽁꽁 숨겨서 사용하자. - 그렇다고 모든 상황에서 이렇게만 쓰일 수는 없다.&lt;/p&gt;
&lt;h5&gt;서술적인 이름을 사용하라!&lt;/h5&gt;
&lt;p&gt;함수의 좋은 이름: 함수가 하는 일을 잘 표현하는 이름&lt;/p&gt;
&lt;p&gt;&quot;코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라고 불러도 되겠다.&quot;&lt;/p&gt;
&lt;p&gt;길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.&lt;/p&gt;
&lt;p&gt;모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.&lt;/p&gt;
&lt;h5&gt;함수 인수&lt;/h5&gt;
&lt;p&gt;함수에서 이상적인 인수 개수는 0개. 다음은 1개, 2개이다. 3개는 가능한 피하는 편이 좋고 4개 이상은 사용하지 않는게 좋다.&lt;/p&gt;
&lt;h6&gt;- 함수에 인수를 1개 넘기는 이유&lt;/h6&gt;
&lt;h6&gt;1. 인수에 질문을 던지는 경우&lt;/h6&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;boolean fileExists(&amp;quot;MyFile&amp;quot;)   // String 형식으로 받은 파일 이름이 존재하는지 확인하는 함수&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h6&gt;2. 인수를 뭔가로 변환해 결과를 반환하는 경우&lt;/h6&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;InputStream fileOpen(&amp;quot;MyFile&amp;quot;)  // String 형식의 파일 이름을 InputStream으로 리턴받는다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h6&gt;3. 이벤트- 드물게 사용하지만 아주 유용한 함수 형식이다.&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;입력인수만 있으며 출력인수는 없다.&lt;/li&gt;
&lt;li&gt;이벤트 함수는 해당 함수가 이벤트라는 사실이 코드에 명확히 드러나야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;passwordAttemptFailedNtimes(int attempts)  // 비밀번호를 몇 번 틀렸는지 알려주는 함수다&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h5&gt;부수효과를 일으키지 마라!&lt;/h5&gt;
&lt;p&gt;함수에서 하기로 했던 행위 이외의 행위, 즉 부수효과를 일으키지 마라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수명에서 드러나지 않는 행위를 하는 위험에 처한다.&lt;/li&gt;
&lt;li&gt;시간적인 결합 즉, 특정상황에서만 해당 함수를 호출할 수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;명령과 조회를 구분하라&lt;/h5&gt;
&lt;p&gt;함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 혼란을 초래한다.&lt;/p&gt;
&lt;h5&gt;오류 코드보다 예외를 사용하라!&lt;/h5&gt;
&lt;p&gt;명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.
자칫하면 if 문에서 명령을 표현식으로 사용하기 쉬운 탓이다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;if (deletePage(page) == E_OK)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 코드는 동사/형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기한다.
오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다.&lt;/p&gt;
&lt;h5&gt;Try/Catch 블록 뽑아내기&lt;/h5&gt;
&lt;p&gt;try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.&lt;/p&gt;
&lt;h5&gt;반복하지 마라!&lt;/h5&gt;
&lt;p&gt;중복은 소프트웨어의 모든 악의 근원이다.&lt;/p&gt;
&lt;h5&gt;구조적 프로그래밍&lt;/h5&gt;
&lt;p&gt;모든 함수와 함수 내 모든 블록에 입구(entry)와 출구(exit)가 하나만 존재해야 한다.
즉, 함수는 return 문이 하나여야 한다. 루프 안에서 break나 continue는 절대로 안된다.&lt;/p&gt;
&lt;h5&gt;결론 - 함수를 어떻게 짜죠?&lt;/h5&gt;
&lt;p&gt;소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다.
논문이나 기사를 작성할 때는 먼저 생각을 기록한 후 읽기 좋게 다듬는다.
초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장를 고치고 정리한다.&lt;/p&gt;
&lt;p&gt;함수를 짤 때도 마찬가지다. 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다.
이름은 즉흥적이고 코드는 중복된다. 하지만 나는 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다.&lt;/p&gt;
&lt;p&gt;그런 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다.
누구도 처음부터 탁 짜내지 않는다.&lt;/p&gt;
&lt;p&gt;진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심해야 한다. 우리가 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아떨어져야 이야기를 풀어가기가 쉬워진다는 사실을 기억해야 한다.&lt;/p&gt;
&lt;h3&gt;🎈 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.&lt;/h3&gt;
&lt;p&gt;이론적으로는 알고 있던 내용들이었는데, 사실 실무에서는 짧고 간단한 이름을 주로 사용했던 것 같다.&lt;br/&gt;
작게 만들기, 한 가지만 하기, 서술적인 이름을 사용하기, 인수는 되도록이면 적게!&lt;/p&gt;
&lt;p&gt;처음부터 잘 짜여진 코드는 누구에게도 어려운 것이라고 하니 좀 위안이 되었다. 나도 그동안 내가 했던 코드들을 잘 리팩토링 해보며 개선해 가야 겠다!&lt;/p&gt;
&lt;h3&gt;🎈 궁금한 내용이나, 잘 이해되지 않는 내용이 있다면 적어보세요.&lt;/h3&gt;
&lt;p&gt;다형성(polymorphism)이란?&lt;/p&gt;
&lt;p&gt;: 프로그램 언어 각 요소들(상수, 변수, 식, 객체, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질&lt;/p&gt;</content:encoded></item><item><title><![CDATA[노개북 - 클린코드 Assignment 03]]></title><description><![CDATA[📌 1주차 - Assignment #03 📚 TIL (2024.01.28) -…]]></description><link>https://kirahaa.github.io/clean-code-03/</link><guid isPermaLink="false">https://kirahaa.github.io/clean-code-03/</guid><pubDate>Sun, 28 Jan 2024 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;📌 &lt;strong&gt;1주차 - Assignment #03&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;📚 TIL (2024.01.28) - 2장. 의미있는 이름&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3&gt;책에서 기억하고 싶은 내용을 써보세요.&lt;/h3&gt;
&lt;h4&gt;이름을 잘 짓는 간단한 규칙&lt;/h4&gt;
&lt;h5&gt;의도를 분명히 밝혀라&lt;/h5&gt;
&lt;p&gt;좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.
변수나 함수 그리고 클래스 이름은 다음과 같은 굵직한 질문에 모두 답해야 한다.
변수의 존재 이유는? 수행 기능은? 사용 방법은? 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.&lt;/p&gt;
&lt;h5&gt;그릇된 정보를 피하라&lt;/h5&gt;
&lt;p&gt;그릇된 단서는 코드 의미를 흐린다.
예를 들어 hp, aix, sco는 변수 이름으로 적합하지 않다.&lt;br/&gt;
여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면, accountList라 명명하지 않는다.
accountGroup, bunchOfAccounts, 아니면 단순히 Accounts라 명명한다.&lt;br/&gt;
서로 흡사한 이름을 사용하지 않도록 주의한다.
XYZControllerForEfficientHandlingOfStrings, XYZControllerForEfficientStorageOfStrings라는 이름을 사용한다면?
일관성이 떨어지는 표기법은 그릇된 정보다.&lt;/p&gt;
&lt;h5&gt;의미있게 구분하라&lt;/h5&gt;
&lt;p&gt;불용어(noise word, stop word): 분석에 큰 의미가 없는 단어 &lt;br/&gt;
ex) the, a, an, is, I, my 등과 같이 문장을 구성하는 필수 요소지만 문맥적으로 큰 의미가 없는 단어&lt;/p&gt;
&lt;p&gt;연속된 숫자를 덧붙이거나 불용어를 추가하는 방식은 적절하지 못하다.&lt;br/&gt;
Product라는 클래스가 있다고 가정할 때, 다른 클래스를 ProductInfo 혹은 ProductData라 부른다면 개념을 구분하지 않은 채 이름만 달리한 경우다.
그렇다고 a나 the와 같은 접두어를 사용하지 말라는 소리가 아니다. 의미가 분명히 다르다면 사용해도 무방하다.&lt;/p&gt;
&lt;p&gt;불용어는 중복이다. moneyAmount는 money와 구분이 안 된다.&lt;br/&gt;
customerInfo는 customer와, accountData는 account와, theMessage는 message와 구분이 안된다.
읽는 사람이 차이를 알도록 이름을 지어라.&lt;/p&gt;
&lt;h5&gt;발음하기 쉬운 이름을 사용하라&lt;/h5&gt;
&lt;p&gt;발음하기 어려운 이름은 토론하기도 어렵다.&lt;/p&gt;
&lt;h5&gt;검색하기 쉬운 이름을 사용하라&lt;/h5&gt;
&lt;p&gt;상수나 영어에서 많이 쓰이는 문자를 변수 이름에 사용할 경우 검색이 어렵다.
이름 길이는 범위 크기에 비례해야 한다. 변수나 상수를 코드 여러 곳에서 사용한다면 검색하기 쉬운 이름이 바람직하다.&lt;/p&gt;
&lt;h5&gt;인코딩을 피하라&lt;/h5&gt;
&lt;p&gt;유형이나 범위 정보까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다.
인코딩한 이름은 거의가 발음하기 어려우며 오타가 생기기도 쉽다.&lt;/p&gt;
&lt;h5&gt;자신의 기억력을 자랑하지 마라&lt;/h5&gt;
&lt;p&gt;프로그래머들은 일반적으로 똑똑하기에 자신의 정신적 능력을 과시하고 싶어한다.
똑똑한 프로그래머와 전문가 프로그래머 사이에서 나타나는 차이점 하나만 들자면, 전문가 프로그래머는 &lt;strong&gt;명료함이 최고&lt;/strong&gt;라는 사실이다.&lt;/p&gt;
&lt;h5&gt;클래스 이름&lt;/h5&gt;
&lt;p&gt;클래스 이름과 객체 이름은 명사나 명자구가 적합하다.
Customer, WikiPage, Account, AddressParser 등이 좋은 예다.&lt;/p&gt;
&lt;h5&gt;메서드 이름&lt;/h5&gt;
&lt;p&gt;메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등이 좋은 예다.&lt;/p&gt;
&lt;h5&gt;기발한 이름은 피하라&lt;/h5&gt;
&lt;p&gt;특정문화에서만 사용하는 농담은 피하는 편이 좋다. 재미난 이름보다 명료한 이름을 선택하라.&lt;/p&gt;
&lt;h5&gt;한 개념에 한 단어를 사용하라&lt;/h5&gt;
&lt;p&gt;추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다.
일관성 있는 어휘는 코드를 사용할 프로그래머가 반갑게 여길 선물이다.&lt;/p&gt;
&lt;h5&gt;말장난을 하지 마라&lt;/h5&gt;
&lt;p&gt;한 단어를 두 가지 목적으로 사용하지 마라. 다른 개념에 같은 단어를 사용한다면 그것은 말장난에 불과하다.&lt;/p&gt;
&lt;h5&gt;해법 영역에서 가져온 이름을 사용하라&lt;/h5&gt;
&lt;p&gt;모든 이름을 문제 영역(domain)에서 가져오는 정책은 현명하지 못하다.&lt;br/&gt;
프로그래머들에게 익숙한 기술 개념은 아주 많다. 기술 개념에는 기술 이름이 가장 적합한 선택이다.&lt;/p&gt;
&lt;h5&gt;문제 영역에서 가져온 이름을 사용하라&lt;/h5&gt;
&lt;p&gt;적절한 &apos;프로그래머 용어&apos;가 없다면 문제 영역에서 이름을 가져온다.
우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄 알아야 한다.&lt;/p&gt;
&lt;h5&gt;의미 있는 맥락을 추가하라&lt;/h5&gt;
&lt;p&gt;예를 들어, firstName, lastName, street, houseNumber, city, state, zipcode라는 변수가 있다.
변수를 훑어보면 주소라는 사실을 금방 알아차릴 수 있다.
하지만 어느 메서드가 state라는 변수 하나만 사용한다면? 변수 state가 주소 일부라는 사실을 금방 알아챌까?&lt;/p&gt;
&lt;p&gt;addr라는 접두어를 추가해 addrFirstName, addrLastName, addrState라 쓰면 맥락이 좀 더 분명해진다.&lt;/p&gt;
&lt;h5&gt;불필요한 맥락을 없애라&lt;/h5&gt;
&lt;p&gt;&apos;고급 휘발유 충전소(Gas Station Deluxe)&apos;라는 애플리케이션을 짠다고 가정하자.
모든 클래스 이름을 GSD로 시작하겠다는 생각은 전혀 바람직하지 못하다.
일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다. 이름에 불필요한 맥락을 추가하지 않도록 주의한다.&lt;/p&gt;
&lt;h3&gt;오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.&lt;/h3&gt;
&lt;p&gt;이름을 잘 짓는 방법에 이렇게나 많은 항목이 존재하는 지 몰랐다.&lt;br/&gt;
특히 ProductInfo 혹은 ProductData 같은 변수 이름을 많이 사용했던 것 같은데, 나한테 얘기하는 것 같아 찔렸다ㅎㅎ&lt;/p&gt;
&lt;p&gt;그럼에도 불구하고 이름 짓는 것은 가장 어렵다. 그래도 이름 잘 짓는 습관을 잘 들여놔야 겠다!&lt;/p&gt;
&lt;h3&gt;궁금한 내용이나, 잘 이해되지 않는 내용이 있다면 적어보세요.&lt;/h3&gt;
&lt;p&gt;문제 영역(domain)이라는 용어를 처음 알게 됐다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;사전적 의미&lt;br/&gt;
&lt;strong&gt;domain&lt;/strong&gt; : 영역, 범위&lt;/p&gt;
&lt;p&gt;사용자가 사용하는 것, 소프트웨어로 해결하고자 하는 문제 영역 (=비즈니스 영역)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6&gt;애매모호한 코드&lt;/h6&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;public enum OrderState {
    STEP1, STEP2, STEP3, STEP4, STEP5, STEP6
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h6&gt;도메인 용어를 사용한 코드&lt;/h6&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;public enum OrderState {
    PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED, CANCELED
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;=&gt; 코드의 가독성을 높여서 코드를 분석하고 이해하는데 시간을 줄여준다.&lt;/p&gt;
&lt;p&gt;전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용한다.
이렇게 하면 소통 과정에서 발생하는 용어의 모호함을 줄일 수 있고 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[노개북 - 클린코드 Assignment 02]]></title><description><![CDATA[📌 1주차 - Assignment #02 📚 TIL (2024.01.27) - 추천사 ~ 1장. 깨끗한 코드 책에서 기억하고 싶은 내용을 써보세요. 추천사 "사소한 곳에서 발휘하는 정직은 사소하지 않다." 품질 관리론 S…]]></description><link>https://kirahaa.github.io/clean-code-02/</link><guid isPermaLink="false">https://kirahaa.github.io/clean-code-02/</guid><pubDate>Sat, 27 Jan 2024 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;📌 &lt;strong&gt;1주차 - Assignment #02&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;📚 TIL (2024.01.27) - 추천사 ~ 1장. 깨끗한 코드&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h3&gt;책에서 기억하고 싶은 내용을 써보세요.&lt;/h3&gt;
&lt;h4&gt;추천사&lt;/h4&gt;
&lt;p&gt;&quot;사소한 곳에서 발휘하는 정직은 사소하지 않다.&quot;&lt;/p&gt;
&lt;h5&gt;품질 관리론 S5 규칙&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;정리: 무엇이 어디에 있는지 알아야 한다.&lt;/li&gt;
&lt;li&gt;정돈: 코드는 누구나 예상하는 위치에 있도록 정돈한다.&lt;/li&gt;
&lt;li&gt;청소: 필요없는 주석 등은 제거한다.&lt;/li&gt;
&lt;li&gt;청결(표준화): 공통으로 사용하는 코드 스타일과 기법 등의 필요성.&lt;/li&gt;
&lt;li&gt;생활화: 주기적으로 코드를 돌아보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&quot;첫 아이 이름을 짓듯이 심사숙고해서 변수 이름을 지어야 한다.&quot;&lt;/p&gt;
&lt;p&gt;&quot;일관적인 들여쓰기 스타일이 버그 수를 줄여주는 가장 중요한 요인 중 하나라고 추측하게 되었다.&quot;&lt;/p&gt;
&lt;p&gt;&quot;사소한 것에 집중할 뿐 아니라 사소한 것에 정직해야 한다.&quot;&lt;br/&gt;
코드에 정직하고, 코드의 상태에 관하여 동료들에게 정직하고, 무엇보다도, 자기 코드에 대해서 자신에게 정직하라는 뜻이다.&lt;/p&gt;
&lt;h4&gt;1장. 깨끗한 코드&lt;/h4&gt;
&lt;h5&gt;르블랑의 법칙&lt;/h5&gt;
&lt;p&gt;&quot;나중은 절대 오지 않는다.&quot; - 한번 작성한 쓰레기 코드를 나중에 수정하는 일은 결코 없다.&lt;/p&gt;
&lt;p&gt;좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다.
나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.&lt;br/&gt;
기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.&lt;/p&gt;
&lt;p&gt;우아한 코드: &quot;외양이나 태도가 기품 있고 단아하며 보기에 즐거운&quot; 코드&lt;/p&gt;
&lt;p&gt;나쁜 코드는 나쁜 코드를 &apos;유혹&apos;한다!&lt;br/&gt;
창문이 깨진 건물은 누구도 상관하지 않는다는 인상을 풍긴다. 사람들도 관심을 끊는다.&lt;br/&gt;
창문이 더 깨져도 상관하지 않는다.&lt;br/&gt;
나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다.&lt;/p&gt;
&lt;h5&gt;깨끗한 코드란?&lt;/h5&gt;
&lt;p&gt;깨끗한 코드는 한가지에 &apos;집중&apos;한다.&lt;/p&gt;
&lt;p&gt;깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.&lt;/p&gt;
&lt;p&gt;깨끗한 코드란 다른 사람이 고치기 쉽다.&lt;/p&gt;
&lt;p&gt;깨끗한 코드는 주의 깊게 작성한 코드다. 누군가 시간을 들여 깔끔하고 단정하게 정리한 코드다.&lt;/p&gt;
&lt;p&gt;중복 줄이기, 한 기능만 수행하기, 제대로 표현하기, 작게 추상화하기.&lt;/p&gt;
&lt;p&gt;읽으면서 짐작한 대로 돌아가는 코드가 깨끗한 코드다.&lt;/p&gt;
&lt;h5&gt;보이스카우트 규칙&lt;/h5&gt;
&lt;p&gt;캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.&lt;/p&gt;
&lt;h3&gt;오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요.&lt;/h3&gt;
&lt;p&gt;사실 당연하다고 생각해던 이론들이 실무를 하다보면 당연하지 않다는 걸 느낀다.&lt;/p&gt;
&lt;p&gt;일을 하다보면 기한이 촉박하다는 이유로, 더럽고 지저분한 코드를 짜게 되는 경우가 많다.
하지만 언제나 그랬듯 빨리 가는 유일한 방법은 코드를 깨끗하게 유지하는 습관밖에 없다는 것이다.&lt;/p&gt;
&lt;p&gt;코드를 짜다보면 생각없이 짜게 되는 경우가 많았는데, 시간을 들여 주의 깊게 작성해야 겠다는 반성을 했다.&lt;br/&gt;
나중에 고치겠다는 생각하지 말고, 처음부터 제대로 잘 작성하자!&lt;/p&gt;
&lt;h3&gt;궁금한 내용이나, 잘 이해되지 않는 내용이 있다면 적어보세요.&lt;/h3&gt;
&lt;p&gt;책에서도 &quot;명쾌한 추상화&quot;, &quot;작게 추상화하라&quot;라는 말이 나오는데, 항상 &lt;strong&gt;추상화&lt;/strong&gt;라는 개념이 헷갈린다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;추상화&lt;/strong&gt;: 공통의 속성이나 기능을 묶어 이름을 붙이는 것으로 객체 지향적 관점에서 클래스를 정의하는 것을 추상화라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 283px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/46a50595d6810091dd62ef4a0cf7864f/9a54c/%EC%B6%94%EC%83%81%ED%99%94.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaElEQVR42p2T0WrbQBBF/Z/9gX5Af6aPfehDoQ/5hdKntFBKKYYkXkuWKieKpMqWtdKudndOkRQcHAg2HRgY7i6XO/fuLkBAhLmE5+n/arHc97y7+sKHH4q0bXD2gLct4g1h0Pihww8acR3i7XnCtA98TjTXecOv+CfLx4yk3lI2JWIqgm8htPi+JNjdWf2L43GwPDQF6z9b1I1itTtMeFWUlHWD+G4iPUs42udGG72l2GXcPhSkeUFyaKcLmyhCxTEEQ7D7yxROFQacqal6y7Y50A3DSUzBabypZiwEROSp3VP7U8IxhEHnbNYrvn+7pq6bWeEmpvxbg1hcV1yucFw52Jog0BszYyJskpiqHsNwmGoJYlirFSuV0uuE7O4t6vcbsuTjC8LgGPYRvi/wXT4F4PQ9MuwRW+K7R7zOJ3VK3RFFKbrNKbJP3C7fU+RfX3h4XGX25nkOU1/8sE/5zv0POVrxWij/ADAAWEmazB6aAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;추상화&quot;
        title=&quot;&quot;
        src=&quot;/static/46a50595d6810091dd62ef4a0cf7864f/9a54c/%EC%B6%94%EC%83%81%ED%99%94.png&quot;
        srcset=&quot;/static/46a50595d6810091dd62ef4a0cf7864f/4d6f2/%EC%B6%94%EC%83%81%ED%99%94.png 158w,
/static/46a50595d6810091dd62ef4a0cf7864f/9a54c/%EC%B6%94%EC%83%81%ED%99%94.png 283w&quot;
        sizes=&quot;(max-width: 283px) 100vw, 283px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;추상화&lt;/strong&gt;란 현실 세계에서 존재하는 모든 사물의 공통점과 공통 기능을 유추해서 클래스를 만들어내는 일련의 과정이다.
예를 들어, 토끼, 고양이, 사자, 치타가 있을 때 이것들을 각각의 객체라 하며 이 객체들을 하나로 묶으려 할 때, 동물 또는 생물이라는 어떤 추상적인 객체로 크게 정의한다고 하자.
이때 동물 또는 생물이라고 묶는 것을 &lt;strong&gt;추상화&lt;/strong&gt;라고 한다. &lt;strong&gt;추상화는 다른 객체들과는 구분되는 핵심적인 특징들에만 집중함으로써, 복잡도를 관리할 수 있도록 한다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[노개북 - 클린코드 Assignment 01]]></title><description><![CDATA[📌 1주차 - Assignment #0…]]></description><link>https://kirahaa.github.io/clean-code-01/</link><guid isPermaLink="false">https://kirahaa.github.io/clean-code-01/</guid><pubDate>Fri, 26 Jan 2024 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;📌 &lt;strong&gt;1주차 - Assignment #01&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;- 책 구매 인증&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/e0d081b1027f23dde0278967bdd5c46a/b37e7/cleancode_front.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 133.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMEBQH/xAAWAQEBAQAAAAAAAAAAAAAAAAACAAH/2gAMAwEAAhADEAAAAWitTuMGtTiUV0HhH//EAB0QAAICAQUAAAAAAAAAAAAAAAECAAMyERITITH/2gAIAQEAAQUCopQ08FUYIsTCW5L5HGpsYiB23J2P/8QAFhEAAwAAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/ASv/xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAS/9oACAECAQE/AWUV/8QAHBAAAgICAwAAAAAAAAAAAAAAAAECERAhEiIy/9oACAEBAAY/Ao8oKzwiqQsrOmx9mbP/xAAfEAADAAIABwAAAAAAAAAAAAAAAREhQRAxUXGBkeH/2gAIAQEAAT8hbTDLLaF8saqLGkYdnhMVaG9QmT3nkQovJHdDYzq1P//aAAwDAQACAAMAAAAQiPN//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxCHgz//xAAXEQEBAQEAAAAAAAAAAAAAAAABACER/9oACAECAQE/EOyHbUGX/8QAHBABAAMAAgMAAAAAAAAAAAAAAQARITFBYXHh/9oACAEBAAE/EEW0dB1nYmBYdBQcsyjIONjG59sELwgJ3BoMUz2wPQPSIA1BgtLWFaWz/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;clean code&quot;
        title=&quot;&quot;
        src=&quot;/static/e0d081b1027f23dde0278967bdd5c46a/af1fa/cleancode_front.jpg&quot;
        srcset=&quot;/static/e0d081b1027f23dde0278967bdd5c46a/ab180/cleancode_front.jpg 158w,
/static/e0d081b1027f23dde0278967bdd5c46a/ba98e/cleancode_front.jpg 315w,
/static/e0d081b1027f23dde0278967bdd5c46a/af1fa/cleancode_front.jpg 630w,
/static/e0d081b1027f23dde0278967bdd5c46a/23301/cleancode_front.jpg 945w,
/static/e0d081b1027f23dde0278967bdd5c46a/b37e7/cleancode_front.jpg 1080w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;개발자 필독서 중에 항상 나오던 책이라 꼭 읽어보고 싶었는데,
이번 기회를 통해 제대로 읽어 볼 수 있을 것 같다!&lt;br/&gt;
책 표지를 중요시하는 편인데 제목에 맞게 참 깔끔하고 간결한 표지ㅎㅎ&lt;/p&gt;
&lt;p&gt;앞으로 열심히 읽어보겠습니다!🙋‍♀️&lt;br/&gt;
노개북 화이팅~!~!📚&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리액트 쿼리(React Query)를 사용하는 이유]]></title><description><![CDATA[세줄 요약 React Query는 React Application에서 서버 상태를 불러오고, 캐싱하며, 지속적으로 동기화하고 업데이트하는 작업을 도와주는 라이브러리입니다. 복잡하고 장황한 코드가 필요한 다른 데이터 불러오기 방식과 달리 React…]]></description><link>https://kirahaa.github.io/why-react-query/</link><guid isPermaLink="false">https://kirahaa.github.io/why-react-query/</guid><pubDate>Mon, 20 Nov 2023 13:57:56 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;세줄 요약&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;React Query는 React Application에서 서버 상태를 불러오고, 캐싱하며, 지속적으로 동기화하고 업데이트하는 작업을 도와주는 라이브러리입니다.&lt;/li&gt;
&lt;li&gt;복잡하고 장황한 코드가 필요한 다른 데이터 불러오기 방식과 달리 React Component 내부에서 간단하고 직관적으로 API를 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;더 나아가 React Query에서 제공하는 캐싱, Window Focus Refetching 등 다양한 기능을 활용하여 API 요청과 관련된 번잡한 작업 없이 &quot;핵심 로직&quot;에 집중할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;React Query란?&lt;/h3&gt;
&lt;p&gt;React Query는 React Application에서 서버의 상태를 불러오고, 캐싱하며, &lt;strong&gt;지속적으로 동기화&lt;/strong&gt;하고 업데이트 하는 작업을 도와주는 라이브러리입니다.
React Query는 우리에게 친숙한 Hook을 사용하여 React Component 내부에서 자연스럽게 서버(또는 비동기적인 요청이 필요한 Source)의 데이터를 사용할 수 있는 방법을 제안합니다.&lt;/p&gt;
&lt;p&gt;다음은 리액트 쿼리를 적용하기 전과 후의 API 통신 방법입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// React query 사용 전
import {useEffect, useState} from &amp;quot;react&amp;quot;;

const [coins, setCoins] = useState&amp;lt;ICoin[]&amp;gt;([])
const [loading, setLoading] = useState(true);

useEffect(() =&amp;gt; {
  (async() =&amp;gt; {
    const response = await fetch(&amp;quot;https://api.coinpaprika.com/v1/coins&amp;quot;)
    const json = await response.json()
    setCoins(json)
    setLoading(false)
  })()
}, [])&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// React query 사용 후
// api.ts
export const fetchCoins = async () =&amp;gt; {
  const response = await fetch(&amp;quot;https://api.coinpaprika.com/v1/coins&amp;quot;)
  return await response.json()
}

// Coins.ts
const {isLoading, data} = useQuery&amp;lt;ICoin[]&amp;gt;({ queryKey: [&amp;#39;allCoins&amp;#39;], queryFn: fetchCoins })
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;길고 거창한 설명 없이도 해당 코드를 보면 React Query를 사용한 API 요청과 상태 관리가 얼마나 쉽고 자연스러운지 알 수 있습니다.&lt;/p&gt;
&lt;h3&gt;React Query의 Query 요청&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 가장 기본적인 형태의 React Query useQuery Hook 사용 예시
const { data } = useQuery(
  queryKey,  // 이 Query 요청에 대한 응답 데이터를 캐시할 때 사용할 Unique Key (required)
  fetchFn,   // 이 Query 요청을 수행하기 위한 Promise를 Return하는 함수 (required)
  options,   // useQuery에서 사용되는 Option 객체 (optional)
) &lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;useQuery&lt;/code&gt; Hook으로 수행되는 Query 요청은 HTTP METHOD &lt;strong&gt;GET&lt;/strong&gt; 요청과 같이 서버에 저장되어 있는 &quot;상태&quot;를 불러와 사용할 때 사용합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React Query는 다양한 UI에 유연하게 적용할 수 있도록 &lt;code&gt;useQueries&lt;/code&gt;, &lt;code&gt;useInfiniteQuery&lt;/code&gt; 같은 Hook들도 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React Query의 &lt;code&gt;useQuery&lt;/code&gt; Hook은 요청마다(API마다) 구분되는 **Unique Key (aka. Query Key)**를 필요로 합니다.
React Query는 이 Unique Key로 서버 상태 (aka. API Response)를 로컬에 캐시하고 관리합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const Coins = () =&amp;gt; {
  const {isLoading, data} = useQuery&amp;lt;ICoin[]&amp;gt;({ queryKey : [&amp;#39;allCoins&amp;#39;], queryFn: fetchCoins })
  // &amp;#39;allCoins&amp;#39;를 Key로 사용하여 데이터 캐싱
  // 다른 컴포넌트에서 &amp;#39;allCoins&amp;#39;를 QueryKey로 사용한 useQuery Hook이 있다면 캐시된 데이터를 우선 사용합니다.

  // FYI, `data === undefined`를 평가하여 로딩 상태를 처리하는 것이 더 좋습니다.
  // React Query는 내부적으로 stale-while-revalidate 캐싱 전략을 사용하고 있기 때문입니다.
  return (
    &amp;lt;Container&amp;gt;
      &amp;lt;Header&amp;gt;
        &amp;lt;Title&amp;gt;Coins&amp;lt;/Title&amp;gt;
      &amp;lt;/Header&amp;gt;
      {isLoading ? &amp;lt;Loader&amp;gt;Loading&amp;lt;/Loader&amp;gt; : (
        &amp;lt;CoinsList&amp;gt;
          {data?.slice(0, 100).map(coin =&amp;gt; &amp;lt;Coin key={coin.id}&amp;gt;
          &amp;lt;Link to={coin.id} state={coin}&amp;gt;
          &amp;lt;Img src={`https://coinicons-api.vercel.app/api/icon/${coin.symbol.toLowerCase()}`} alt={coin.name}/&amp;gt;
            {coin.name} &amp;amp;rarr;
          &amp;lt;/Link&amp;gt;
        &amp;lt;/Coin&amp;gt;)}
      &amp;lt;/CoinsList&amp;gt;)} 
    &amp;lt;/Container&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;stale-while-revalidate&lt;/strong&gt;란?&lt;br/&gt;&lt;br/&gt;
&lt;code&gt;stale-while-revalidate&lt;/code&gt;는 개발자가 캐싱된 콘텐츠를 즉시 로드하는 즉시성과 객싱된 최신 콘텐츠가 향후에 사용되도록 보장하는 최신성 간의 균형을 유지하는데 도움을 주는 HTTP Cache-Control 확장 디렉티브입니다.&lt;/p&gt;
&lt;p&gt;브라우저는 Cache-Control의 max-age를 기준으로 캐싱된 컨텐츠의 최신 상태 여부를 판단하게 되는데, swr은 캐싱된 낡은 컨텐츠에 대한 확장된 지시를 표현합니다.
react-query를 사용함으로써 swr은 낡은 캐시로부터 빠르게 컨텐츠를 반환하고, 백그라운드에서 요청을 통해 캐싱된 컨텐츠의 재검증을 진행하여 캐싱 레이어에서 최신화된 대이터를 보장할 수 있도록 swr 캐싱 전략을 취하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;React Query를 쓰면 이런 게 편해진다&lt;/h3&gt;
&lt;h4&gt;- Boilerplate 코드의 감소&lt;/h4&gt;
&lt;p&gt;Redux를 사용할 경우 Redux의 기본 원칙 준수를 위한 다양한 Boilerplate 코드들이 필요합니다.
더 나아가 다음 예시 코드를 보면 API 상태 관리를 위해 하나의 API 요청을 3가지 Action을 사용해 처리하고 있고,
후에 기능이 추가되어 API 개수가 많아진다면 이런 상용구적인 코드도 함께 늘어나게 됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;API 상태를 Redux를 사용하여 관리하는 부분의 코드&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// features/todos/todos.slice.ts
// API 상태를 관리하기 위한 Redux State
import { createSlice, PayloadAction } from &amp;#39;@reduxjs/toolkit&amp;#39;;
import { TodoItem } from &amp;#39;types/todo&amp;#39;;

export interface TodoListState {
  data?: TodoItem[];
  isLoading: boolean;
  error?: Error;
}

const initialState: TodoListState = {
  data: undefined,
  isLoading: false,
  error: undefined,
}

export const todoListSlice = createSlice({
  name: &amp;#39;todoList&amp;#39;,
  initialState,
  reducers: {
    requestFetchTodos: (state) =&amp;gt; {
      state.isLoading = true;
    },
    successFetchTodos: (state, action: PayloadAction&amp;lt;TodoItem[]&amp;gt;) =&amp;gt; {
      state.data = action.payload;
      state.isLoading = false;
      state.error = undefined;
    },
    errorFetchTodos: (state, action: PayloadAction&amp;lt;string&amp;gt;) =&amp;gt; {
      state.data = undefined;
      state.isLoading = false;
      state.error = action.payload;
    }
  }
});

export const { requestFetchTodos, successFetchTodos, errorFetchTodos } = todoListSlice.actions;

export default todoListSlice.reducer;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;React Query로 API 상태를 관리하는 부분의 코드&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// quries/useTodosQuery.ts
// API 상태를 불러오기 위한 React Query Custom Hook
import axios from &amp;#39;axios&amp;#39;;
import { useQuery } from &amp;#39;react-query&amp;#39;;
import { TodoItem } from &amp;#39;types/todo&amp;#39;;

// useQuery에서 사용할 UniqueKey를 상수로 선언하고 export로 외부에 노출합니다.
// 상수로 UniqueKey를 관리할 경우 다른 Component (or Custom Hook)에서 쉽게 참조가 가능합니다.
export const QUERY_KEY = &amp;#39;/todos&amp;#39;;

// useQuery에서 사용할 `서버의 상태를 불러오는데 사용할 Promise를 반환하는 함수`
const fetcher = () =&amp;gt; axios.get&amp;lt;TodoItem[]&amp;gt;(&amp;#39;/todos&amp;#39;).then(({ data }) =&amp;gt; data);

const useTodosQuery = () =&amp;gt; {
  return useQuery(QUERY_KEY, fetcher);
};

export default useTodosQuery;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;단순히 비교해봐도 &lt;strong&gt;Redux를 사용한 비동기 데이터 관리&lt;/strong&gt; 코드와 &lt;strong&gt;React Query를 사용한 비동기 데이터 관리&lt;/strong&gt; 코드의 분량이 크게 차이남을 알 수 있습니다.
코드의 분량이 적어졌다는 것은 개발자에게 불필요한 작업이 필요 없어짐을 뜻하기도 하지만, 소스코드의 복잡도를 낮추어 유지보수의 용이성을 높이고 작업 간에 발생할 수 있는 사이드 이펙트나 휴먼 에러를 사전에 더
잘 막을 수 있다는 의미도 갖게 될 것입니다.&lt;/p&gt;
&lt;h4&gt;- API 요청 수행을 위한 규격화된 방식 제공&lt;/h4&gt;
&lt;p&gt;React Query는 &lt;code&gt;React에서 비동기 데이터를 관리하기 위해 만들어진 라이브러리&lt;/code&gt;입니다. React Query는 API 요청 및 상태 관리를
위해 (상당히 잘 만들어진!) 규격화된 방식을 제공합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface ApiState {
  data?: Data;
  isLoading: boolean;
  error?: Error;
}

interface ApiState {
  data?: Data;
  status: &amp;#39;IDLE&amp;#39; | &amp;#39;LOADING&amp;#39; | &amp;#39;SUCCESS&amp;#39; | &amp;#39;ERROR&amp;#39;;
  error?: Error;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;Redux로 API 상태를 관리하는 경우 프로젝트 환경에 따른 설계와 구현이 요구되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React Query는 API 상태와 관련된 다양한 데이터를 제공하여 복잡한 구현과 설계 없이도 개발자가 효율적으로 화면을 구성할 수 있게끔 도와줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isIdle,
  isLoading,
  isLoadingError,
  isPlaceholderData,
  isPreviousData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  refetch,
  remove,
  status,
} = useQuery(queryKey, queryFn);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;React Query는 다양한 형태의 데이터를 제공하여 복잡한 작업 없이도 효율적으로 화면을 구성할 수 있다. (참고: &lt;a href=&quot;https://react-query.tanstack.com/reference/useQuery&quot;&gt;React Query 공식 홈페이지&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;- 사용자 경험 향상을 위한 기능 제공&lt;/h4&gt;
&lt;p&gt;이전에는 비동기 데이터 관리를 위해 직접 구현하고 사용했던 기능들을, React Query는 자체적으로 제공하는 다양한 기능이 있어 이를 사용자 경험 향상에 손쉽게 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ex)
// quires/useTodosQuery.ts
// API 상태를 불러오기 위한 React Query Custom Hook

const useTodosQuery = () =&amp;gt; {
  return uesQuery(QUERY_KEY, fetcher, { refetchOnWindowFoucs: true });
}

export default useTodosQuery;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;React Query를 사용할 경우 단순한 옵션 부여만으로 &lt;strong&gt;Window Focus 이벤트 발생 시 서버 상태 동기화&lt;/strong&gt; 시나리오를 달성할 수 있습니다.
다루는 API가 많아지고 컴포넌트 구조가 복잡해질수록 이전의 &lt;strong&gt;직접 Event Binding&lt;/strong&gt;하는 방식보다 유지보수하기 좋은 코드가 될 것입니다.&lt;/p&gt;
&lt;p&gt;React Query와 함께라면 &lt;a href=&quot;https://tanstack.com/query/latest/docs/react/guides/window-focus-refetching?from=reactQueryV3&amp;#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Fwindow-focus-refetching&quot;&gt;Refetch on window focus&lt;/a&gt;외에
&lt;a href=&quot;https://tanstack.com/query/latest/docs/react/guides/caching?from=reactQueryV3&amp;#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Fcaching&quot;&gt;API Caching&lt;/a&gt;, &lt;a href=&quot;https://tanstack.com/query/latest/docs/react/guides/query-retries?from=reactQueryV3&amp;#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Fquery-retries&quot;&gt;API Retry&lt;/a&gt;, &lt;a href=&quot;https://tanstack.com/query/latest/docs/react/guides/optimistic-updates?from=reactQueryV3&amp;#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Foptimistic-updates&quot;&gt;Optimistic Update&lt;/a&gt;, &lt;a href=&quot;https://tanstack.com/query/latest/docs/react/plugins/persistQueryClient?from=reactQueryV3&amp;#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fplugins%2FpersistQueryClient&quot;&gt;Persist Caching&lt;/a&gt; 등 사용자 경험 향상을 위한 다양한 기법들을 손쉽게 프로젝트에 포함시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;React Query에서 제공하는 이러한 기능들은 우리 개발자들로 하여금 제품과 직접적으로 연관되지 않는 작업에 투입해야 하는 리소스를 경감시켜 더 중요한 비즈니스 로직에 집중할 수 있게끔 도와줍니다.
이러한 환경은 우리가 더 견고한 제품을 만들 수 있는 바탕이 되어주고 있습니다.&lt;/p&gt;
&lt;h3&gt;마치며&lt;/h3&gt;
&lt;p&gt;React Query를 사용하면, &lt;strong&gt;&apos;불필요한 코드의 감소&apos;, &apos;업무와 협업의 효율성을 위한 규격화된 방식 제공&apos;, &apos;사용자 경험 향상을 위한 다양한 Built-in 기능&apos;&lt;/strong&gt; 이라는 장점들을 정리해 볼 수 있겠네요~&lt;br/&gt;
저도 React Query를 사용하면서 큰 매력을 느끼고 있었는데요!&lt;br/&gt;
이렇게 정리해 보니 더더욱 쓸 이유가 확실해 보입니다!👍&lt;/p&gt;
&lt;p&gt;그럼 다음 포스팅에서 또 만나요!~😉&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;참고 링크&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.kakaopay.com/post/react-query-1/&quot;&gt;https://tech.kakaopay.com/post/react-query-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://youthfulhps.dev/web/stale-while-ravalidate/&quot;&gt;https://youthfulhps.dev/web/stale-while-ravalidate/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[웹 성능 최적화를 위한 Lazy Loading 기법]]></title><description><![CDATA[Lazy Loading이란 무엇일까? 레이지 로딩(Lazy Loading…]]></description><link>https://kirahaa.github.io/img-lazy-loading/</link><guid isPermaLink="false">https://kirahaa.github.io/img-lazy-loading/</guid><pubDate>Wed, 01 Nov 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h3&gt;Lazy Loading이란 무엇일까?&lt;/h3&gt;
&lt;p&gt;레이지 로딩(Lazy Loading)은 페이지를 읽어들이는 시점에 중요하지 않은 리소스 로딩을 추후에 할 수 있게 하는 기술입니다.
페이지를 로드하자마자 리소스를 로딩하는 일반적인 방식 대신, 실제로 사용자 화면에 보여질 필요가 있을 때까지 이러한 로딩을 지연하는 것입니다.&lt;/p&gt;
&lt;p&gt;레이지 로딩의 목적은 &lt;strong&gt;(1) 최초 페이지 로딩 시간을 개선&lt;/strong&gt;하고 당장 화면에 표시되지 않는 이미지, 영상 등의 리소스를 나중에 로딩하면서 &lt;strong&gt;(2) 최초 데이터 전달 양을 감소시키는 것&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;웹페이지를 로딩하는 기존 방식은 모든 리소스들을 한번에 받는 것입니다.
이렇게하면 최초 로딩 시간이 더 커지게 되는데, 이러한 로딩 시간 증가는 인터넷 연결 속도가 느린 지역이나 디바이스를 사용할 때 특히 더 두드러지게 체감됩니다.&lt;/p&gt;
&lt;p&gt;이러한 문제를 해결하기 위해 사용할 수 있는 테크닉이 레이지 로딩인 것입니다.
레이지 로딩을 적용하면, 화면에 당장 보여지지 않거나 아직 유저의 인터렉션이 일어나지 않은 특정 리소스들의 로딩을 딜레이시킬 수 있습니다.
이러한 방식을 적용하면, 당장 필요한 컨텐츠들이 먼저 로딩되고, 다른 리소스들은 필요해질 때 로딩되기 때문에 웹 페이지의 퍼포먼스를 눈에 띄게 개선할 수 있습니다.&lt;/p&gt;
&lt;p&gt;레이지 로딩은 주로 이미지와 영상들에 적용됩니다.
하지만 이미지나 영상 뿐만 아니라, 다이나믹 컴포넌트, 방대한 양의 스크립트, 외부 위젯 등 다른 컨텐츠에도 적용될 수 있습니다.
이렇듯 용량이 큰 컨텐츠들을 추후 필요해질 때 추가 로딩하도록 개발을 진행한다면 최초 페이지 로딩 시간을 줄이고 사용자 경험을 개선할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이제 레이지 로딩이 무엇인지 알았으니, 어떻게 적용하면 되는지 살펴보도록 합시다!✨&lt;/p&gt;
&lt;h3&gt;loading=&quot;lazy&quot; 태그 속성 사용&lt;/h3&gt;
&lt;p&gt;HTML의 img 태그에 loading=&apos;lazy&apos;를 추가해주면 image의 lazy 로딩이 가능합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;#x3C;img src=&quot;./image.jpg&quot; loading=&quot;lazy&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;해당 속성을 사용하면 요소가 웹 브라우저 뷰포트에 들어오는 시점에 해당 컨텐츠의 다운로드 및 화면 표시가 이루어집니다.
대부분의 웹 브라우저에서 지원되고 사용이 간편하지만, 기능적으로는 지연 로딩 여부만 가능하기 때문에 지연 로딩되는 대상에 대한 세세한 제어는 할 수 없습니다.
세세한 제어를 하려면 자바스크립트로 구현하는 Intersection Observer API를 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;그리고 반드시 &lt;strong&gt;이미지의 크기 속성 값&lt;/strong&gt;이 있어야만 loading=&quot;lazy&quot; 속성이 적용되어 동작합니다.
명시적으로 크기를 표시하지 않은 이미지는 지연 로딩이 적용되지 않습니다.
크기를 표시할 때는 꼭 스크롤하는 방향에 대한 크기를 정해야 합니다.
세로로 스크롤하는 웹페이지면 높이값이 있어야 지연 로딩이 적용됩니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트 Intersection Observer API 이용&lt;/h3&gt;
&lt;p&gt;정기적으로 업데이트가 되고 있는 모던 웹 브라우저에서는 모두 지원되는 자바스크립트 API 기능입니다.
이 API는 지연 로딩을 위한 API라기 보다는 웹페이지의 특정 요소가 뷰포트 영역과 교차를 하는지(뷰포트 영역 안에 들어왔는지)를 감시하는 모니터링 API입니다.
웹페이지 요소가 뷰포트 영역 안에 들어오면, 해당 요소를 표시하거나, 또는 다른 특정 동작을 하도록 하는 트리거를 발생시켜 콜백 함수의 코드를 실행합니다.&lt;/p&gt;
&lt;p&gt;Intersection Observer API 기능은 자바스크립트를 통해 기능을 구현하며, 웹 브라우저 뷰포트 안으로 들어오는 요소의 동작을 세밀하게, 또 선택적으로 제어할 수 있어서 트래픽을 더 효율적으로 제어할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;Intersection Observer 생성하기&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let observer = new IntersectionObserver(callback, options)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;IntersectionObserver 생성자를 사용하여 옵저버를 만들 수 있습니다.
인자로는 &lt;strong&gt;(1)콜백함수&lt;/strong&gt;와 &lt;strong&gt;(2)옵션들&lt;/strong&gt;이 들어가는데, 먼저 옵션들을 살펴봅시다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const options = {
  root: ...,
  rootMargin: ...,
  threshold: ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;IntersectionObserver 생성자에 전달하는 두 개의 인자 중 두번째 옵션엔, 세 가지 필드가 있습니다.&lt;/p&gt;
&lt;p&gt;(1) root:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타겟 엘리먼트와의 교차 정도를 체크할 상대방입니다. 꼭 타겟의 윗 조상님들 중 하나여야 합니다. 만약 따로 지정하지 않거나, 명확하게 null이라고 표기할 경우엔 디폴트로 브라우저의 뷰포트가 root로 지정됩니다.&lt;/li&gt;
&lt;li&gt;VanillaJS로 할 때는 document.queryselector ~~ 와 같이 작성하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2) rootMargin:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;루트를 감싸고 있는 마진을 뜻합니다. CSS margin 속성이랑 비슷한 모양으로 값을 넣을 수 있습니다. (예를 들어, CSS에서 10px 10px 10px 10px이라고 쓰면 top, right, bottom, left인 것과 같이 저 순서대로 값을 넣을 수 있습니다.) 이 값은 %로 작성될 수도 있습니다.&lt;/li&gt;
&lt;li&gt;이 값들은 교차를 계산하기 전에 루트 엘리먼트의 바운딩 박스의 양 분의 늘어남/줄어남을 담당합니다. 디폴트는 모두 0입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(3) threshold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타겟 엘리먼트가 몇 % 정도 보여줘야 IntersectionObserver의 첫번째 인자로 전달된 콜백이 실행되어야 하는지를 정하는 값입니다.&lt;/li&gt;
&lt;li&gt;그냥 일반 숫자 또는 배열로 표기합니다. 만약 &quot;내 타겟이 50%정도 노출되었을 때 콜백을 실행시켜!&quot;라고 명령하고 싶다면 0.5를 넣어주면 됩니다. 이것보다 조금 더 복잡하게, 노출도(?)가 25% 늘어날때마다 콜백이 실행되게 하고 싶다면 배열 값을 넣어주면 됩니다. [0, 0.25, 0.5, 0.75, 1].&lt;/li&gt;
&lt;li&gt;디폴트값은 0이며, 이는 즉 내 타겟의 픽셀 한 개만 보이더라도 콜백을 실행해버리겠다는 의미입니다. 반대로, 1.0으로 설정하면 내 타겟을 이루는 모든 픽셀이 보여져야만 콜백이 실행된다는 것을 뜻합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;관찰 대상, 타겟 지정하기&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let myTarget = document.querySelector(&amp;#39;.lazy&amp;#39;);
observer.observe(myTarget);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;관찰자인 Observer를 만들었으니 그 관찰자의 관심 대상인 관찰 대상, target element도 만들어주어야 합니다.
타겟은 observer(타겟) 메소드를 통해 지정할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;콜백이 실행되면...&lt;/h4&gt;
&lt;p&gt;지정된 threshold를 만나는 순간 콜백이 실행됩니다. 콜백이 실행되면, 콜백은 IntersectionObserverEntry 객체와 우리의 관찰자 observer를 전달받게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let callback = (entries, observer) =&amp;gt; {
  entries.forEach(entry =&amp;gt; {
    ...
  })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;콜백함수가 받게 되는 entry list는 각 타겟당 하나의 엔트리를 포함하고 있습니다.
이 엔트리는 Intersection Observer API의 인터페이스로, 특정 시점에서의 타겟 엘리먼트와 루트의 교차 여부를 보여줍니다.
메소드는 없고, read-only인 속성 7개를 가지고 있는데 그 중에서 isIntersection 속성에 대해 알아봅시다.&lt;/p&gt;
&lt;p&gt;isIntersection 속성은 Boolean으로 true/false 값을 갖는데, true일 경우엔 엔트리의 주인공인 타겟이 루트와 현재 교차하고 있다는 것을 의미합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const myElement = useRef();

// ...


const handleScrolling = useCallback(( [entry] ) =&amp;gt; {
  if (entry.isIntersecting) {
    // 만약 지금 타겟이 루트랑 교차중이라면, 이 곳을 실행!
  }
}, [...]) 

useEffect(() =&amp;gt; {
  let observer;
  const {current} = myElement;
  
  if (current) {
    observer = new IntersectionObserver(handleScrolling, {threashold: 0.7})
    observer.observe(current)
    
    return () =&amp;gt; observer &amp;amp;&amp;amp; observer.disconnect()
  }
}, [handleScrolling])&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;++ 바닐라JS 예시 코드&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;window.onload = function () {
  const imgs = document.querySelectorAll(&amp;#39;.img&amp;#39;);

  const options = {
    root: null,
    threshold: 0.5
  };

  const callback = function(entries, Observer) {
    entries.forEach(entry =&amp;gt; {
      if(entry.isIntersecting) {
        Observer.unobserve(entry.target);
        entry.target.src = entry.target.dataset.src;
      }
    })
  }

  let observer = new IntersectionObserver(callback, options);

  for(let i = 0; i &amp;lt; imgs.length; i++) {
    observer.observe(imgs[i]);
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;마치며&lt;/h4&gt;
&lt;p&gt;프론트엔드 개발자가 되고 싶었던 가장 큰 이유 중 하나가 바로 보기 좋고 재미있는 각종 인터랙션과 애니메이션 등을 많이 만들어보고 싶었기 때문인데,
이번에 INtersection Observer API를 공부해보니 너무 재미있었습니다! 꼭 다음 프로젝트에서 써먹을 수 있길 바라며,,, 그럼 틀린 부분이 있다면 댓글 부탁드리고 다음에 또 만나욥+_+&lt;/p&gt;</content:encoded></item><item><title><![CDATA[클로저와 더 가까워지기]]></title><description><![CDATA[closure와 closer해져봅시다 ㅋ.ㅋ 클로저를 알기 전에, 자바스크립트의 렉시컬 스코핑에 대해 먼저 알아보도록 합시다! 스코프(Scope…]]></description><link>https://kirahaa.github.io/js-closure/</link><guid isPermaLink="false">https://kirahaa.github.io/js-closure/</guid><pubDate>Tue, 31 Oct 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;closure와 closer해져봅시다 ㅋ.ㅋ&lt;/p&gt;
&lt;h3&gt;클로저를 알기 전에,&lt;/h3&gt;
&lt;p&gt;자바스크립트의 렉시컬 스코핑에 대해 먼저 알아보도록 합시다!&lt;/p&gt;
&lt;h3&gt;스코프(Scope)란?&lt;/h3&gt;
&lt;p&gt;스코프란 참조 대상 식별자(변수와 함수같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 전역 스코프
const var1 = &amp;#39;global&amp;#39;;

const func = () =&amp;gt; {
  // 함수 레벨 스코프
  const var2 = &amp;#39;function&amp;#39;;
  
  console.log(global);  // 접근 가능
};

func();
console.log(local);  // 접근 불가능&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;전역 스코프를 가진 변수는 어디서든 참조할 수 있지만, 함수 레벨 스코프를 가진 변수는 함수 외부에서 참조하려고 할 경우 참조에러가 발생하게 됩니다.
이러한 개념을 스코프라고 합니다.&lt;/p&gt;
&lt;h3&gt;렉시컬 스코프(Lexical scope)란?&lt;/h3&gt;
&lt;p&gt;렉시컬 스코프는 함수를 어디에 선언하였는지에 따라 상위 스코프가 결정되는 것을 말합니다.
자바스크립트를 포함한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따르며, 이를 정적 스코프(Static Scope)라고 부르기도 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const func = () =&amp;gt; {
  const var1 = &amp;#39;function1&amp;#39;;
  
  const func2 = () =&amp;gt; {
    console.log(var1); // function2
  };
  
  func2();
};
func();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;내부 함수에서 외부 함수의 변수에 접근이 가능한데, 이것은 함수가 중첩될 때 구문 분석기가 변수 이름을 확인하는 방법을 설명하는 정적 스코프의 예시입니다.
&apos;정적&apos;이란, 정적 번위 지정 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미합니다.
즉, 호출 스택과 관계없이 선언 시점에 스코프를 결정합니다. 함수를 호출할 때가 아니라 선언할 때 스코프가 정해지기 때문에 외부에서는 내부 변수에 접근할 수 없게 됩니다.&lt;/p&gt;
&lt;p&gt;반대로 동적 스코프의 선언은 런타임 도중에 실행 콘텍스트나 호출 콘텍스트에 의해 결정됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const scope = &amp;#39;정적 스코프&amp;#39;;

const init = () =&amp;gt; {
  const scope = &amp;#39;동적 스코프&amp;#39;;
  func();
};

const func = () =&amp;gt; {
  console.log(scope);  // 정적 스코프
};

init();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자바스크립트는 정적 스코프를 따르기 때문에 &lt;strong&gt;정적 스코프&lt;/strong&gt;가 출력될 것이지만, 만약 동적 스코프를 따른다면 &lt;strong&gt;동적 스코프&lt;/strong&gt;가 출력될 것입니다.&lt;/p&gt;
&lt;h3&gt;ES6&lt;/h3&gt;
&lt;p&gt;ES6 이전에는 함수 스코프와 전역 스코프 두 가지만 존재했고, ES6 이후부터 블록 스코프가 등장하게 되었습니다.
var로 선언한 변수는 함수 내부 또는 외부에서 선언되었는지에 따라 함수 스코프 또는 전역 스코프를 가지게 되는데, 이때, 중괄호로 표시된 블록이 스코프를 생성하지 않는다는 점에서 혼란을 일으킬 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var x = 1;
if (true) {
  var x = 2;
  var y = 3;
}
console.log(x);  // 2
console.log(y);  // 3&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;console.log에서 x가 어떤 블록 스코프에도 포함되지 않기 때문에 에러가 발생해야 할 것 같지만, 블록은 var로 선언한 변수에 대해 스코프를 생성하지 않기 때문에 var는 전역 변수를 생성합니다.
let/const를 사용하면 이런 혼란에서 벗어날 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const x = 1;
if (true) {
  const x = 2;
  const y = 3;
}
console.log(x); // 1
console.log(y); // Uncaught ReferenceError: y is not defined&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러니, 엉망진창인 var를 버리고 let과 const를 사용하도록 하자!&lt;/p&gt;
&lt;p&gt;이제 본격적으로 클로저에 대해 이야기해 봅시다!&lt;/p&gt;
&lt;h3&gt;클로저란?&lt;/h3&gt;
&lt;p&gt;클로저(closure)는 함수와 그 함수가 선언된 렉시컬 환경(lexical environment) 사이의 특별한 관계입니다.
함수 내부에서  정의한 변수와 그 함수의 외부 변수 사이의 관계를 나타낸다고 볼 수 있습니다. 보통은 함수가 실행을 마치고 렉시컬 환경이 소멸될 때, 해당 함수 내에서 선언된 변수들도 사라집니다.
하지만 클로저에서는 외부 변수에 대한 참조가 남아 있어 내부 변수들에 계속해서 접근이 가능합니다.
함수가 속한 문맥적 번위를 기억하여 함수의 범위 밖에서도 내부에 접근할 수 있게 해주는 기능이라고 볼 수 있습니다.
클로저는 함수가 다른 함수 내부에서 정의되고, 내부 함수가 외부 함수의 변수를 참조할 때 생성됩니다.
내부 함수가 외부 함수로부터 반환되거나 다른 코드 블록 내에서 참조될 때 클로저가 형성되는 것입니다.&lt;/p&gt;
&lt;p&gt;코드를 한번 살펴봅시다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const outerFunction = () =&amp;gt; {
  const outerVar = 10;
  
  const innerFunction = () =&amp;gt; {
    console.log(outerVar);  // outerVar에 접근 가능
  };
  
  return innerFunction;
};

const closureExample = outerFunction();
closureExample(); // 10&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 코드에서 &lt;code&gt;innerFunction&lt;/code&gt;은 &lt;code&gt;outerFunction&lt;/code&gt; 내부에서 정의되고, &lt;code&gt;closureExample&lt;/code&gt;에 할당된 다음 외부에서 호출됩니다.
이때 &lt;code&gt;innerFunction&lt;/code&gt;은 외부 함수 &lt;code&gt;outerFunction&lt;/code&gt;의 &lt;code&gt;outerVal&lt;/code&gt; 변수에 접근할 수 있으며, 클로저가 형성됩니다.&lt;/p&gt;
&lt;h4&gt;잠깐!&lt;/h4&gt;
&lt;p&gt;var를 사용할 경우, 클로저와 함께 사용했을 때도 당연히 버그가 발생할 가능성이 큽니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function createCounter() {
  var count = 0;
  
  var increment = function () {
    count++;
    console.log(count);
  };
  
  var decrement = function () {
    count--;
    console.log(count);
  };
  
  return {
    increment: increment,
    decrement: decrement
  };
}

var counter = createCounter();

counter.increment(); // 1
counter.increment(); // 2

// 버그 원인
var count = 10; // 외부에서 count 변수 재정의

counter.decrement();  // 11 (예상치 못한 결과)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;클로저를 어떻게 활용할 수 있을까?&lt;/h3&gt;
&lt;h4&gt;1. 리액트 훅&lt;/h4&gt;
&lt;p&gt;숨쉬듯 사용하는 &lt;code&gt;useState&lt;/code&gt;가 이러한 클로저를 이용해서 상태를 기억합니다. &lt;code&gt;useState&lt;/code&gt;는 &lt;code&gt;state&lt;/code&gt;와 &lt;code&gt;setState&lt;/code&gt;의 두 함수를 내부적으로 가지는데,
실제로 &lt;code&gt;state&lt;/code&gt;와 &lt;code&gt;setState&lt;/code&gt;를 사용하는 시점은 &lt;code&gt;useState&lt;/code&gt;의 호출이 끝난 후이지만, 클로저가 내부 변수 값을 기억하고 있기 때문에 이후에도 접근이 가능합니다.
&lt;code&gt;useState&lt;/code&gt; 뿐만 아니라 커스텀 훅에서도 클로저를 이용해서 상태를 기억할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const useBoolean = (defaultValue = false): [boolean, () =&amp;gt; void, () =&amp;gt; void] =&amp;gt; {
  const [value, setValue] = useState(defaultValue);
  
  return [value, () =&amp;gt; setValue(true), () =&amp;gt; setValue(false)];
};

const [showModal, onOpenModal, onCloseModal] = useBoolean();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;2. 비동기 작업 관리&lt;/h4&gt;
&lt;p&gt;클로저는 비동기 작업을 관리하고 상태를 유지하는 데 유용합니다.
예를 들어, 타이머 콜백 함수 내에서 외부 변수를 사용하여 특정 조건에 따라 작업을 중단하거나 다시 시작할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const createTimer = () =&amp;gt; {
  let count = 0;
  const timer = setInterval(() =&amp;gt; {
    console.log(count++);
  }, 1000);
  
  return function stopTimer() {
    clearInterval(timer);
  };
};

const stopFunc = createTimer();

setTimer(() =&amp;gt; {
  stopFunc(); // 타이머 중지
}, 5000);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;3. 모듈 패턴&lt;/h4&gt;
&lt;p&gt;이러한 클로저를 이용해서 프라이빗 변수를 흉내내는 모듈 패턴을 구현할 수도 있습니다. 모듈 패턴을 사용하면 전역 스코프에서 변수 노출을 최소화하고 코드를 모듈화할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const counterModule = (() =&amp;gt; {
  let count = 0;
  
  const increment = () =&amp;gt; {
    count++;
  }
  
  const decrement = () =&amp;gt; {
    count--;
  }
  
  const getCount = () =&amp;gt; {
    return count;
  }
  
  return {
    increment,
    decrement,
    getCount,
  }
})();

counterModule.increment();
console.log(counterModule.getCount()); // 1&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;꽤나 많은 개념이 들어간 글이었는데, 결론적으로 클로저는 자바스크립트에서 매우 강력한 개념 중 하나이며, 함수의 스코프와 변수 관리를 효율적으로 처리할 수 있도록 해줍니다.
클로저를 올바르게 활용하면 코드를 더 효과적으로 작성하고 유지 관리할 수 있습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[타입스크립트의 꽃, 제네릭]]></title><description><![CDATA[타입스크립트는 자바스크립트의 상위 집합 언어로, 정적 타입을 지원하여 코드의 안정성과 생산성을 향상시켜줍니다. 그 중에서도 제네릭(Generic…]]></description><link>https://kirahaa.github.io/ts-generic/</link><guid isPermaLink="false">https://kirahaa.github.io/ts-generic/</guid><pubDate>Mon, 30 Oct 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;타입스크립트는 자바스크립트의 상위 집합 언어로, 정적 타입을 지원하여 코드의 안정성과 생산성을 향상시켜줍니다.&lt;/p&gt;
&lt;p&gt;그 중에서도 제네릭(Generic)은 타입스크립트의 핵심 기능 중 하나입니다. 오늘은 제네릭의 개념, 사용법, 그리고 실제 활용 방법에 대해 알아봅시다!&lt;/p&gt;
&lt;h2&gt;제네릭이란?&lt;/h2&gt;
&lt;p&gt;제네릭은 타입스크립트에서 코드의 일반화(generic)를 가능하게 해주는 기능입니다.
제네릭을 사용하면 함수, 클래스, 인터페이스 등 다양한 타입에 대해 작동하도록 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;제네릭을 사용하면&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;컴파일 시점에서 타입 체크를 할 수 있어 런타임 에러를 사전에 방지할 수 있고,&lt;strong&gt;(타입 안정성)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;한 번 작성한 제네릭 코드를 다양한 타입에 대해 재사용할 수 있고,&lt;strong&gt;(재사용성)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;제네릭을 통해 일반적인 동작을 정의하고, 구체적인 타입은 사용하는 곳에서 결정할 수 있습니다.&lt;strong&gt;(추상화)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그렇다면 실제로 어떻게 제네릭을 사용하는지 살펴봅시다!&lt;/p&gt;
&lt;h3&gt;1. 함수 제네릭&lt;/h3&gt;
&lt;p&gt;함수를 정의할 때, 입력값과 반환값에 대해 제네릭 타입을 지정할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const reverse = &amp;lt;T&amp;gt;(items: T[]): T[] =&amp;gt; {
  return items.reverse();
};

const numbers = [1, 2, 3, 4, 5];
const reversedNumbers = reverse(numbers); // [5, 4, 3, 2, 1]

const names = [&amp;#39;Alice&amp;#39;, &amp;#39;Bob&amp;#39;, &amp;#39;Charlie&amp;#39;];
const reversedNames = reverse(names); // [&amp;#39;Charlie&amp;#39;, &amp;#39;Bob&amp;#39;, &amp;#39;Alice&amp;#39;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;프로미스(Promise)나 콜백(callback) 함수에서도 제네릭을 유용하게 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const fetchData = &amp;lt;T&amp;gt;(url: string): Promise&amp;lt;T&amp;gt; =&amp;gt; {
  return fetch(url)
    .then((response) =&amp;gt; response.json())
    .then((data: T) =&amp;gt; data);
};

fetchData&amp;lt;{ id: number; name: string }&amp;gt;(&amp;#39;/api/users/1&amp;#39;)
  .then((user) =&amp;gt; {
    console.log(user.id, user.name);
  })
  .catch((error) =&amp;gt; {
    console.log(&amp;#39;Error:&amp;#39;, error);
  })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;2. 클래스 제네릭&lt;/h3&gt;
&lt;p&gt;클래스를 정의할 때, 인스턴스 변수에 대해 제네릭 타입을 지정할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Box&amp;lt;T&amp;gt; {
  private item: T;

  constructor(item: T) {
    this.item = item;
  }
  
  getItem(): T {
    return this.item;
  }
}

const numberBox = new Box&amp;lt;number&amp;gt;(18);
console.log(numberBox.getItem()); // 18

const stringBox = new Box&amp;lt;string&amp;gt;(&amp;#39;Hello&amp;#39;);
console.log(stringBox.getItem());  // &amp;#39;Hello&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;배열, 맵, 집합 등과 같은 컬렉션 데이터 구조에서 제네릭을 사용하여 다양한 타입의 요소를 저장하고 처리할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Collection&amp;lt;T&amp;gt; {
  private items: T[] = [];
  
  addItem(item: T): void {
    this.items.push(item);
  }
  
  getItems(): T[] {
    return this.items;
  }
}

const numberCollection = new Collection&amp;lt;number&amp;gt;();
numberCollection.addItem(1);
numberCollection.addItem(&amp;#39;Apple&amp;#39;); // Error: Argument of type &amp;#39;string&amp;#39; is not assignable to parameter of type &amp;#39;number&amp;#39;.

const stringCollection = new Collection&amp;lt;string&amp;gt;();
stringCollection.addItem(&amp;#39;Apple&amp;#39;);
stringCollection.addItem(1); // Error: Argument of type &amp;#39;number&amp;#39; is not assignable to parameter of type &amp;#39;string&amp;#39;.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;3. 컴포넌트 제네릭&lt;/h3&gt;
&lt;p&gt;컴포넌트에서도 제네릭을 사용하여 타입 안정성을 확보하고 재사용성을 높일 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const ListComponent = &amp;lt;T extends ReactNode&amp;gt;({ data }: { data: T[] }) =&amp;gt; (
  &amp;lt;ul&amp;gt;
    {data.map((item, index) =&amp;gt; (
      &amp;lt;li key={index}&amp;gt;{item}&amp;lt;/li&amp;gt;
    ))}
  &amp;lt;/ul&amp;gt;
);

const stringList: string[] = [&amp;#39;Apple&amp;#39;, &amp;#39;Banana&amp;#39;, &amp;#39;Orange&amp;#39;];
const numberList: number[] = [1, 2, 3];

const RenderListComponents = () =&amp;gt; {
  &amp;lt;&amp;gt;
    {/* data: string[] */}
    &amp;lt;ListComponent data={stringList} /&amp;gt;
  
    {/* data: number[] */}
    &amp;lt;ListComponent data={numberList} /&amp;gt;

    {/* Error: Type &amp;#39;number[]&amp;#39; is not assignable to type &amp;#39;string[]&amp;#39;. */}
    &amp;lt;ListComponent&amp;lt;string&amp;gt; data={numberList} /&amp;gt;
  &amp;lt;/&amp;gt;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;&quot;어라, 저 extends는 뭔가요?🙄&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;제네릭 제약(Constraints)&lt;/h2&gt;
&lt;p&gt;제네릭을 제한해서 사용할 순 없을까요? 이럴 때 사용할 수 있는 것이 &lt;strong&gt;제네릭 제약&lt;/strong&gt;입니다.
제네릭 제약은 extends 키워드를 사용하여 설정됩니다.
&lt;code&gt;T extends SomeType&lt;/code&gt;에서 &lt;code&gt;T&lt;/code&gt;는 &lt;code&gt;SomeType&lt;/code&gt; 타입 또는 &lt;code&gt;SomeType&lt;/code&gt;을 상속하는 타입으로 제한됩니다.&lt;/p&gt;
&lt;p&gt;제네릭 제약은 제네릭 타입을 특정 타입으로 제한하기 위해 사용되는 기능입니다.
제네릭을 사용하여 범용적인 코드를 작성하면서도, 특정 타입에 대해서만 동작하도록 제약을 걸 수 있습니다.
이를 통해 코드의 타입 안정성을 더욱 높일 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const getProperty = &amp;lt;T, K extends keyof T&amp;gt;(obj: T, key: K): T[K] =&amp;gt; {
  return obj[key];
}

const person = { name: &amp;#39;Alice&amp;#39;, age: 30 };
getProperty(person, &amp;#39;name&amp;#39;); // &amp;#39;Alice&amp;#39;
getProperty(person, &amp;#39;age&amp;#39;); // 30
getProperty(person, &amp;#39;address&amp;#39;); // Error: Argument of type &amp;#39;&amp;quot;address&amp;quot;&amp;#39; is not assignable to parameter of type &amp;#39;&amp;quot;name&amp;quot; | &amp;quot;age&amp;quot;&amp;#39;.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위의 예시와 같이, 제네릭 제약을 사용하여 key의 타입이 obj의 키로 제한하는 것을 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;타입스크립트의 제네릭은 코드의 재사용성과 유연성을 높여주는 강력한 기능입니다. 제네릭을 통해 타입 안정성을 강화하고, 재사용 가능한 유연한 코드를 작성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/441693e668b4a2655e0e0507110b6f79/40619/ts.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 89.87341772151898%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB7WzWVCskKB//xAAZEAADAQEBAAAAAAAAAAAAAAAAAQIRMRD/2gAIAQEAAQUCqlJuoffGVw//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAXEAEAAwAAAAAAAAAAAAAAAAAgASEx/9oACAEBAAY/ArkYf//EABoQAQEBAQEBAQAAAAAAAAAAAAEAIRExQVH/2gAIAQEAAT8h1OEbCHJBjX7IBOB4QPyHYeX/2gAMAwEAAgADAAAAEBAHPP/EABURAQEAAAAAAAAAAAAAAAAAACAh/9oACAEDAQE/EKP/xAAaEQABBQEAAAAAAAAAAAAAAAAAARARQWGR/9oACAECAQE/EJ1q6If/xAAcEAEAAwACAwAAAAAAAAAAAAABABEhMXFBUWH/2gAIAQEAAT8QJVA9+YiXHcZDfP2Z0NwEslO0XwRyAEzNL6gaA9xrqf/Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;typescript jjang&quot;
        title=&quot;&quot;
        src=&quot;/static/441693e668b4a2655e0e0507110b6f79/af1fa/ts.jpg&quot;
        srcset=&quot;/static/441693e668b4a2655e0e0507110b6f79/ab180/ts.jpg 158w,
/static/441693e668b4a2655e0e0507110b6f79/ba98e/ts.jpg 315w,
/static/441693e668b4a2655e0e0507110b6f79/af1fa/ts.jpg 630w,
/static/441693e668b4a2655e0e0507110b6f79/40619/ts.jpg 700w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리액트(React)는 왜 쓰는 걸까?]]></title><description><![CDATA[…]]></description><link>https://kirahaa.github.io/why-use-react/</link><guid isPermaLink="false">https://kirahaa.github.io/why-use-react/</guid><pubDate>Fri, 15 Sep 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;프론트엔드 시장에서 가장 많이 사용되는 라이브러리 중 하나는 리액트입니다.&lt;br/&gt;
저도 남들 다한다는 리액트를 따라 배우기 시작했는데 왜 리액트를 쓰는지, 리액트를 잘 사용하고 있는지, 리액트에 들어간 나의 코드는 적절한가?라는 의문이 들었고,
이러한 질문에 답하기 위해 리액트를 사용하는 이유에 대해 정리해 보기로 하였습니다.✨&lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2&gt;🎊 프론트엔드 라이브러리와 프레임워크의 등장&lt;/h2&gt;
&lt;p&gt;프론트엔드 라이브러리가 등장하게 된 이유는 동적인 웹 페이지를 보다 효율적으로 유지보수하고 관리할 수 있도록 하기 위함입니다.&lt;br/&gt;
여기서 정적, 동적인 웹 페이지가 무엇일까요?&lt;/p&gt;
&lt;p&gt;정적인 페이지는 웹 서버에 이미 저장되어 있는 HTML 문서를 클라이언트에게 전달하여 받은 페이지입니다.
기업을 소개하는 페이지라면, 단순히 기업 정보를 전달하기 위한 목적이기 때문에 유저의 인터렉션은 중요하지 않은 요소로 볼 수 있습니다.
이런 경우엔 단순히 HTML이나 CSS의 구성만으로도 충분히 멋진 웹 페이지를 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;반면, 동적인 페이지는 유저의 행동 흐름에 따라 웹페이지의 구성을 달리해주어야 하는 페이지를 말합니다.
즉, 유저의 요청 정보를 처리한 후 제작된 HTML 문서를 클라이언트가 전달받게 됩니다.&lt;/p&gt;
&lt;p&gt;동적인 페이지가 주를 이루는 요즘, 웹 페이지라기 보다, 웹 애플리케이션이라는 용어가 더 어울릴 정도로 유저 인터랙션을 처리하기 위한 상태 변화가 상당히 많아졌습니다.
&lt;strong&gt;이를 자연스러운 유저 인터페이스로 만들어주기 위해서 프론트엔드 라이브러리 / 프레임워크가 등장하게 된 것입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;🙋‍♀️ 그래서 프론트엔드 라이브러리 / 프레임워크는 뭘 도와주는데?&lt;/h2&gt;
&lt;p&gt;웹 애플리케이션이라 불릴 만큼, 프로젝트 규모가 커지고, 다양한 유저 인터랙션이 전달된다면 그만큼 DOM 요소들 또한 변화가 이루어져야 한다는 것과 같습니다.
DOM 요소들이 변화한다는 것은 랜더 트리 재생성, 요소의 스타일 계산, 레이아웃 구성, 페인팅 하는 과정을 거쳐야 한다는 것과 같습니다.
결국, 유저 인터렉션이 전달되는 만큼, 이와 같은 과정이 반복되어야 한다는 것이죠.&lt;/p&gt;
&lt;p&gt;하지만, 이러한 과정이 반복되면 될수록 브라우저가 많은 연산을 해야 한다는 것이고, 이는 전체적인 프로세스의 &lt;strong&gt;비효율성을 야기&lt;/strong&gt;합니다.
또한, 많은 DOM 요소의 변화를 개발자가 직접 관리하는 것은 적지 않은 짐으로 다가오게 될 것입니다.&lt;/p&gt;
&lt;p&gt;결국, 프론트엔드 라이브러리 / 프레임워크는 DOM 관리와 상태 변화 관리를 최소화하고, 개발자는 오직 기능 개발, 사용자 인터페이스에 보다 더 집중할 수 있도록
도와주는 것이며 이러한 목적을 가지고 다양한 해결 방식, 추구 방향을 가지고 각각의 프론트엔드 라이브러리 / 프레임워크가 탄생하게 되었습니다.&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;🤷‍♀️ 그럼, 왜 리액트야?&lt;/h2&gt;
&lt;p&gt;각각의 프론트엔드 라이브러리 / 프레임워크들은 추구하는 방향과 특징들이 다릅니다.&lt;br/&gt;
그렇다면, 우리가 사용할 리액트의 특징은 무엇이 있을까요?&lt;/p&gt;
&lt;h3&gt;Component 단위 작성&lt;/h3&gt;
&lt;p&gt;컴포넌트는 UI를 구성하는 개별적인 뷰 단위로서, UI 개발을 레고라고 한다면, 컴포넌트는 블록 역할을 하게 됩니다.
이러한 블록을 조립해 하나의 완성품을 만드는 것과 같습니다. 이러한 특징은 하나의 컴포넌트를 여러 부분에서 사용할 수 있게 해줍니다.
웹 애플리케이션의 여러 곳에 버튼이 필요하다면, 공통된 하나의 버튼 컴포넌트를 생성하고 그 컴포넌트를 필요한 곳에 가져다 사용하면 되죠.&lt;/p&gt;
&lt;p&gt;이러한 특징은 &lt;strong&gt;생산성과 유지 보수를 용이하게 합니다.&lt;/strong&gt;
하나의 요소의 변화가 다른 요소들의 변화에 영향을 미치는 복잡한 로직을 업데이트하는 까다로운 작업의 경우, 컴포넌트의 재사용 기능으로서 보완할 수 있게 됩니다.&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;JSX&lt;/h3&gt;
&lt;p&gt;JSX(Javascript + XML)는 자바스크립트에 대한 확장 구문으로서, 리액트에서 element(요소)를 제공해 줍니다.
장점은 매우 다양합니다. 단순히 개발자가 마크업 코드에 익숙하다면, 그것만으로도 JSX를 통해 컴포넌트를 구성하는 데 쉽게 적응할 수 있다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;아래 코드에서 return ()에 감싸져 있는 HTML 문법과 매우 유사한 코드가 바로 JSX입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import logo from &amp;#39;./logo.svg&amp;#39;;
import &amp;#39;./App.css&amp;#39;;

const App = () =&amp;gt; {
  return (
    &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
      &amp;lt;header className=&amp;quot;App-header&amp;quot;&amp;gt;
        &amp;lt;img src={logo} className=&amp;quot;App-logo&amp;quot; alt=&amp;quot;logo&amp;quot;/&amp;gt;
        &amp;lt;h1 className=&amp;quot;App-title&amp;quot;&amp;gt;Welcome to React&amp;lt;/h1&amp;gt;
      &amp;lt;/header&amp;gt;
      &amp;lt;p class=&amp;quot;App-intro&amp;quot;&amp;gt;
        To get started, edit &amp;lt;code&amp;gt;src/App.js&amp;lt;/code&amp;gt; and save to reload.
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default App;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이와 같은 코드는 create-react-app을 통해 리앹그 프로젝트를 생성할 때 포함되어 있는 Babel이 컴파일 해줍니다.&lt;br/&gt;
덕분에 우리는 익숙한 HTML 문법과 유사한 JSX를 통해 컴포넌트를 생성할 수 있게 됩니다.&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;Virtual DOM&lt;/h3&gt;
&lt;p&gt;유저의 인터렉션에 의해 상태 변화가 일어나면 브라우저 작동 원리에 의해 렌더링 과정을 반복하게 됩니다. Virtual DOM은 이러한 과정에 의해 발생하는 비효율성을 최소화하기 위해 탄생합니다.&lt;/p&gt;
&lt;p&gt;virtual DOM의 개념이 기존에 아예 없었던 것은 아닙니다. 또한, Virtual DOM 개념을 적용한 유일한 프론트엔드 라이브러리 / 프레임워크는 아닙니다.
하지만, 리액트는 성공적으로 Virtual DOM 개념을 적용한 선발 주자라고 할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;Virtual DOM의 작동 원리&lt;/h4&gt;
&lt;p&gt;유저 인터랙션에 의해 View에 변화가 발생하여 10개의 노드를 수정해 주어야 한다면, 10번의 레이아웃 재계산, 10번의 리렌더링이 필요하다는 것입니다.&lt;/p&gt;
&lt;p&gt;Virtual DOM은 변화가 발생하면, 실제 DOM에 적용되기 전에 Virtual DOM에 우선 적용을 시켜봅니다.
실제 DOM에 바로 적용하나, Virtual DOM에 적용하나 같은 연산 비용이 필요할 거라 생각하실 수 있지만, Virtual DOM은 렌더링 과정이 필요 없기 때문에 연산 비용이 실제 DOM보다 적습니다.&lt;/p&gt;
&lt;p&gt;Virtual DOM에서 이러한 연산이 끝나고 나면, 최종적인 변화를 실제 DOM에 전달해 줍니다. 즉, 10번의 작업을 하나로 묶어 딱 한 번 전달해 줍니다.
물론, 레이아웃 계산과 리렌더링하는 과정의 규모는 커지겠지만, 횟수를 줄이는 것으로 충분히 연산 비용을 적게 만들어 줍니다.&lt;/p&gt;
&lt;p&gt;또한, Virtual DOM은 어떤게 바뀌었는지, 어떤게 바뀌지 않았는지 자동으로 파악하여 필요한 DOM 트리만 업데이트할 수 있게 해줍니다.&lt;/p&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3&gt;정리&lt;/h3&gt;
&lt;p&gt;리액트는 유저의 인터렉션을 처리하는 동적인 페이지가 많아짐에 따라, 자연스러운 유저 인터페이스를 만들어주기 위해서 등장하였습니다.&lt;br/&gt;
리액트는 Component 단위 작성으로 생산성과 유지 보수를 보다 용이하게 하며, JSX를 사용해 익숙한 HTML 문법으로 컴포넌트를 생성할 수 있습니다.
또한 Virtual DOM을 이용해 리렌더링의 횟수를 줄여, 연산 비용을 적게 만듭니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;br/&gt;
&lt;p&gt;이렇게 리액트가 등장하게 된 배경과 다양한 프론트엔드 라이브러리 / 프레임워크 중에서 리액트 만의 장점과 특징을 정리해 보았는데요!
앞으로는 이 특징들을 기억하며, 리액트를 사용하는 것도 좋을 것 같네요ㅎㅎ😊&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프론트엔드 면접 준비하기]]></title><description><![CDATA[Reference: 신입 프론트엔드 개발자가 면접 전 꼭 알아야 할 기본 질문 11가지 Part…]]></description><link>https://kirahaa.github.io/fe-interview-web/</link><guid isPermaLink="false">https://kirahaa.github.io/fe-interview-web/</guid><pubDate>Thu, 14 Sep 2023 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Reference: &lt;a href=&quot;https://zero-base.co.kr/event/media_FE_school_qna&quot;&gt;신입 프론트엔드 개발자가 면접 전 꼭 알아야 할 기본 질문 11가지&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 1. 웹 기본 지식&lt;/h2&gt;
&lt;h3&gt;프로그래밍이란 뭐라고 생각하나요?&lt;/h3&gt;
&lt;p&gt;프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션입니다. 해결해야 할 문제(요구사항)를 명확히 이해한 후 적절한 문제 해결 방안을 정의할 필요가 있다.
0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구를 설명하는 작업이며, 그 결과물이 바로 코드다&lt;/p&gt;
&lt;h3&gt;HTTP와 HTTPS의 차이와 https를 사용했을 때의 장점은 무엇일까요?&lt;/h3&gt;
&lt;p&gt;HTTPS(HyperText Transfer Protocol Secure)는 기존 프로토콜(컴퓨터 사이의 데이터 교환 방식 규칙 정의)에서 데이터가 쉽게 도난 당할 수 있는 것을
방지하기 위해서 SSL(보안 소켓)을 사용하면서 브라우저와 서버 사이에 안전하게 암호화된 연결을 만들 수 있게 도와줍니다.
또한 TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지합니다.
TLS는 데이터 무결성을 제공하므로 데이터가 전송 중에 손상되거나 수정되는 것을 방지합니다.&lt;/p&gt;
&lt;p&gt;또한, HTTPS의 장점은 검색엔진 최적화(SEO)에 도움이 됩니다. 구글과 같은 포털에서는 HTTPS를 사용하는 웹 사이트에 가산점을 부여합니다.
별개로 주소창 옆에 HTTPS가 아니라면 주의 요함과 같은 경고 문구가 있는데 사용자 측면에서도 자주 들어가고 싶지 않겠지요.&lt;/p&gt;
&lt;h3&gt;캐시란 무엇이고 어떻게 동작할까요?&lt;/h3&gt;
&lt;p&gt;캐시는 데이터나 값을 미리 복사해 높은 임시 저장소를 말합니다. 캐시는 데이터를 접근하는 시간이 오래걸리는 경우나 값을 계산하는 시간이 오래걸리는 로직등에 사용합니다.
캐시가 없다면 데이터가 변경되지 않는 고정 데이터임에도 계속해서 네트워크를 통해 데이터를 다운 받아야 합니다. 불필요한 데이터를 계속 받는다면 데이터 비용의 비중도 올라가게 됩니다.
그리고 결국 사용자 측면에서도 로딩 속도가 반복해서 느려지게 되고, 이는 사용자에게 좋지 못한 경험을 제공합니다.&lt;/p&gt;
&lt;p&gt;캐시를 사용하면 새로고침 시에 반복되는 데이터가 네트워크를 통하지 않으므로 네트워크 사용량이 줄고, 브라우저 로딩 속도가 빨라지게 되며, 이는 빠른 사용자 경험으로 직결됩니다.&lt;/p&gt;
&lt;h3&gt;브라우저 렌더링 엔진은 HTML, CSS, Javascript를 어떤 순서로 해석할까요?&lt;/h3&gt;
&lt;p&gt;렌더링 엔진은 HTML 문서 자체를 파싱하여 DOM트리를 만듭니다. 그런 다음 CSS파일과 함께 포함된 CSSOM을 생성합니다. 이후 DOM트리와 CSSOM의 결과를 합친 렌더트리를 구축합니다.
그리고 렌더트리를 배치(Layout)한 후, 마지막으로 렌더트리를 그립니다. 렌더트리를 그리는 과정에서 화면에 그리는 Paint라는 레이어를 채우는 과정을 거쳐 합성(Composite)을 통해 실제로 레스터화를 하며 픽셀로 변환하는 단계를 거칩니다.&lt;/p&gt;
&lt;h3&gt;쿠키, 로컬스토리지, 세션스토리지는 각각 어떤 특징을 가지고 있을까요?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;쿠키&lt;/strong&gt;&lt;br/&gt;
만료 기간이 있는 Key, Value 형태의 저장소를 말합니다.&lt;br/&gt;
대부분의 브라우저가 지원하며, HTTP 요청마다 포함되어 API 호출의 부담으로 작용할 수 있습니다. 용량은 약 4KB 정도로 작은 편입니다.&lt;br/&gt;
쿠키 자체의 도난 위험이 있어 최근에는 구글 크롬의 샌드박스 정책과 같이 보안의 위험이 있는 경우를 방지하기 위해서 노력하는 중입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;로컬스토리지&lt;/strong&gt;&lt;br/&gt;
가장 큰 특징으로는 브라우저 창을 닫더라도 데이터가 유지됩니다. 장점은 서버에 불필요한 데이터를 저장하지 않는 다는 점입니다.&lt;br/&gt;
그리고 브라우저마다 차이는 있지만 용량이 약 5MB로 매우 큽니다. 단점으로는 HTML5을 지원하지 않는 브라우저에서는 사용이 불가능합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;세션스토리지&lt;/strong&gt;&lt;br/&gt;
가장 큰 특징으로는 브라우저 창을 닫는 순간 영구적으로 데이터가 삭제됩니다. &lt;br/&gt;
세션스토리지도 마찬가지로 서버에 불필요한 데이터를 저장하지 않고, 용량이 5MB로 매우 크고 HTML5를 지원하지 않는 브라우저에서는 사용할 수 없습니다.&lt;/p&gt;
&lt;p&gt;주로 폼 정보나 장바구니 정보 등 휘발성이 강한 개인적인 내용에는 세션스토리지를 사용합니다. 자동 로그인 기능이나 다크모드 테마와 같은, 사용자에 귀속되면서 유출되어도 상관 없는 정보들에는
로컬스토리지를 사용하고, 만료 기간을 두고 몇일 보지 않는 팝업 같은 부분은 쿠키를 사용하는 것이 좋습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Part 2. 프레임워크 활용 지식&lt;/h2&gt;
&lt;h3&gt;CSR과 SSR의 차이는 무엇일까요?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CSR(Client Side Rendering)&lt;/strong&gt;&lt;br/&gt;
최초에 서버에서 전체 페이지를 로딩해서 사용자에게 보여주고 이후에는 사용자의 요청에 따라서 리소스를 서버에서 제공하면서 클라이언트가 해석하고 바로 렌더링을 하는 방식입니다.&lt;br/&gt;
빠른 반응속도가 특징이며, 초기 구동속도가 SSR에 비해서 느리고 SEO에 취약합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSR(Server Side Rendering)&lt;/strong&gt;&lt;br/&gt;
기존에 존재하던 방식으로 사용자가 웹페이지에 접근할 때 서버에서 페이지에 대한 요청을 해서 html과 같은 view 리소스들을 어떻게 보여줄지 결정한 뒤에 사용자에게 반환합니다.&lt;br/&gt;
SEO(검색엔진최적화)에 있어서는 google의 검색봇 등의 크롤링을 위해서 정적인 웹페이지의 리소스를 제공하는 것이 중요한데 이런 부분에 있어서는 SSR을 사용하는 것이 보다 도움이 됩니다.&lt;/p&gt;
&lt;h3&gt;리액트나 뷰와 같은 가상돔을 사용하는 프레임워크에서 상태 관리란 무엇일까요?&lt;/h3&gt;
&lt;p&gt;상태 관리란 해당 컴포넌트에 적용되는 상태이며, 화면이 바뀌는 것에 대한 데이터를 state로 만들어줍니다. 이러한 state를 사용하는 이유는 데이터가 변할 때마다 데이터에 관련된 DOM을 찾아서 원하는 동작들을 실행한다면 코드도 중복되고 불필요한 DOM에 대한 접근이 많아질 것입니다.
React에서는 주로 Redux를 사용하며, Vue에서는 Vuex를 사용합니다. 기존의 디자인 패턴인 MVC 패턴과 다르게 단방향으로 데이터가 흐르는 Flux 패턴을 사용합니다.
따라서 View는 데이터가 어떻게 바뀌었는지 직접 MVC의 Model을 사용해서 참조할 필요가 없으며, Dispatch를 통해 Action을 발생시키므로 인해 Store에서 전체적으로 영향을 주는 View를 갱신합니다.&lt;/p&gt;
&lt;h3&gt;Webpack, Parcel, Rollup과 같은 모듈 번들러가 하는 일은 무엇이고 왜 사용할까요?&lt;/h3&gt;
&lt;p&gt;최종적으로 바인딩되는 웹 어플리케이션 리소스들(HTML, CSS, JS, Image, Font 등)을 모두 모듈로 보고, 이를 조합해서 하나로 만드는 역할을 합니다.&lt;br/&gt;
기존 HTML이나 Javascript 파일이 상대적으로 작았던 시절에는 서비스를 유지하는 것에 있어서 그렇게 큰 문제가 되지 않았으나 인터넷이 계속 발달을 거듭하며 대규모 웹 서비스들이 탄생하고,
이에 대해서 수십 수백개의 자바스크립트 파일들을 유지보수하면서 조금 더 편하고 모듈화 된 작업 단위들을 유지보수하고자 하는 욕구에 의해서 탄생했습니다.&lt;/p&gt;
&lt;h3&gt;프레임워크와 라이브러리의 차이는 무엇일까요?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;프레임워크&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프레임워크는 원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 필요한 기능을 갖추고 있는 골격, 뼈대를 말합니다.&lt;/p&gt;
&lt;p&gt;애플리케이션 개발 시 필수적인 코드, 알고리즘, DB 연동과 같은 기능들을 위해 어느 정도 뼈대(구조)를 제공하며 이러한 뼈대 위에서 사용자는 코드를 작성하여 애플리케이션을 개발합니다.
앱/서버 등의 구동, 메모리 관리, 이벤트 루프 등의 공통된 부분은 프레임워크가 관리하며, 사용자는 프레임워크가 정해준 방식대로 클래스, 메서드들을 구현하면 됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 서버 개발에 사용되는 Spring&lt;/li&gt;
&lt;li&gt;Python 서버 개발에 사용되는 Django, Flask&lt;/li&gt;
&lt;li&gt;안드로이드 앱 개발에 사용되는 Android&lt;/li&gt;
&lt;li&gt;아이폰 앱 개발에 사용되는 Cocoa Touch&lt;/li&gt;
&lt;li&gt;웹 개발에 사용되는 Angular, Vue.js 등&lt;/li&gt;
&lt;li&gt;Node.js 기반의 웹 서버를 구축할 수 있는 Express&lt;/li&gt;
&lt;li&gt;자바 기반의 JSP를 위한 프레임 워크 Struts&lt;/li&gt;
&lt;li&gt;루비로 작성된 MVC 패턴을 이용하는 Ruby on Rails&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;라이브러리&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;라이브러리는 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임. 즉 특정 기능을 모아둔 코드, 함수들의 집합이며 코드 작성 시 활용 가능한 도구들을 의미합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python pip로 설치한 패키지/모듈 (tensorflow, pandas, beautifulsoup 등등)&lt;/li&gt;
&lt;li&gt;C++의 표준 템플릿 라이브러리(STL)&lt;/li&gt;
&lt;li&gt;Node.js에서 npm으로 설치한 모듈&lt;/li&gt;
&lt;li&gt;HTML의 클라이언트 사이드 조작을 단순화하는 JQuery&lt;/li&gt;
&lt;li&gt;웹에서 사용자 인터페이스 개발에 사용되는 React.js&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;Part 3. 컴퓨터 공학&lt;/h2&gt;
&lt;h3&gt;스택과 큐의 차이는 무엇일까요?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;스택&lt;/strong&gt;&lt;br/&gt;
스택은 물건을 쌓고 그것을 다시 뺄 수 있는 구조로 되어있습니다. 보통 배열이라고 하는 자료형의 구조도 스택으로 되어있습니다. 배열의 길이를 정하고 거기에 데이터를 넣는 것을 PUSH라고 합니다.
그리고 다시 꺼내는 것을 POP이라고 하며, LIFO(Last-In-First-Out) 구조라고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;큐&lt;/strong&gt;&lt;br/&gt;
큐는 먼저 들어온 데이터가 먼저 처리되는 구조로 되어있습니다. 입구와 출구가 있는 이벤트 루프를 생각하면 쉽습니다. FIFO(First-In-First-Out) 구조라고 합니다.&lt;/p&gt;
&lt;h3&gt;컴파일러와 인터프리터의 차이는 무엇일까요?&lt;/h3&gt;
&lt;p&gt;우리가 코드를 통해 내린 명령을 수행할 주체는 컴퓨터입니다. 따라서 사람이 이해할 수 있는 자연어가 아니라 컴퓨터가 이해할 수 있는 언어, 즉 기계어로 명령을 전달해야 합니다.&lt;br/&gt;
기계어는 우리가 사용하는 언어와는 너무나도 체계가 다르기 때문에 기계어로 직접 명령을 전달하는 것을은 매우 어렵습니다. 기계어로 직접 명령을 전달하는 것을 대신할 가장 유용한 대안은
사람이 이해할 수 있는 약속된 구문으로 구성된 프로그래밍 언어를 사용해 프로그램을 작성한 후, 그것을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기를 이용하는 것입니다.&lt;br/&gt;
이 일종의 번역기를 컴파일러(compiler) 혹은 인터프리터(interpreter)라고 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compile: 변환하다&lt;br/&gt;
interpret: 해석하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;컴파일러&lt;/strong&gt;&lt;br/&gt;
전체 코드를 보고 명령어를 수집하고 재구성 합니다. C, C++ 등이 해당합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;인터프리터&lt;/strong&gt;&lt;br/&gt;
소스코드의 각 행을 연속적으로 분석하며 실행합니다. 인터프리터는 고레벨 언어를 중간 레벨 언어로 변환 한 뒤에 각 행마다 실행하기 때문에 보통은 컴파일러가 인터프리터보다 빠릅니다.&lt;br/&gt;
Python, Javascript 등이 해당합니다. Java는 컴파일러에서 .class파일로 변환한 뒤에 인터프리터 과정으로 한번 더 해석을 하기 때문에 두가지 방법 모두 다 쓴다고 할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;프로세스와 스레드의 차이는 무엇일까요?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;프로세스&lt;/strong&gt;&lt;br/&gt;
운영체제로부터 CPU 자원을 할당받는 작업의 단위입니다. 메모리에 올라와서 실행되고 있는 프로그램의 인스턴스를 의미합니다. Stack, Code, Data, Heap 구조로 되어있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스레드&lt;/strong&gt;&lt;br/&gt;
프로세스 내에서 실행되는 여러 흐름의 단위입니다. 프로세스 내에서 각각 Stack만 따로 할당 받고 Code, Data, Heap 영역은 공유합니다.
멀티 스레드가 가지는 장점은 첫 번째로 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소하므로 자원을 효율적으로 관리할 수 있고, 스레드 간의 통신 비용이 더 적게 발생합니다.
대신, 스레드 간에 공유자원으로 인한 문제를 위해 동기화에 대해서 신경을 써줘야 합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[웹 성능 최적화 - 브라우저는 어떻게 렌더링을 할까]]></title><description><![CDATA[…]]></description><link>https://kirahaa.github.io/web-perform-optimization/</link><guid isPermaLink="false">https://kirahaa.github.io/web-perform-optimization/</guid><pubDate>Tue, 05 Sep 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;최적화! 왠지 중요하고 챙겨야할 것 같지만 막상 설명하라고 하면 말이 안나오는 그것!
저도 어디선가 줍줍한 지식들로 대략적으로는 알고 있지만 막상 정리하려니 참 어렵게 느껴지더라고요..?!&lt;br/&gt;
사실 꼭 면접에 대비하기 위함이 아니더라도, 사용자에게 좋은 UX를 남겨주기 위해서는 웹 사이트를 사용자에게 빠르고 쾌적하게 보여주는 것이 좋겠죠?&lt;/p&gt;
&lt;p&gt;우선 웹 브라우저가 어떻게 화면을 그려내는가(=렌더링)에 대해 살펴보려고 합니다.&lt;br/&gt;
저처럼 UI 개발을 하는 분들은 사용자에게 보여질 View를 자주 다루실텐데, 항상 헷갈리는 이 개념에 대해 자세히 파헤쳐봅시다!!&lt;/p&gt;
&lt;p&gt;혹시 맞지 않는 내용이 있다면 언제든 말씀 부탁드립니다😉&lt;/p&gt;
&lt;h2&gt;브라우저: 탐색을 시작합니다&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;browse: 둘러보다[훑어보다], 대강 읽다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;웹 브라우저는 웹의 다양한 콘텐츠를 탐색할 수 있게 만들어주는 프로그램입니다. 여기에는 크롬이나 엣지 같은 익숙한 이름부터, 브레이브나 토어 같이 다소 낯선 이름들까지,
정말 다양한 브라우저가 존재합니다.&lt;/p&gt;
&lt;h3&gt;웹 브라우저 인기 랭킹 in 한국 (2023년 8월)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://gs.statcounter.com/browser-market-share/all/south-korea/#monthly-202208-202308&quot;&gt;출처: statcounter&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Chrome - 50.7%&lt;/li&gt;
&lt;li&gt;Safari - 18.15%&lt;/li&gt;
&lt;li&gt;Samsung Internet - 15.49%&lt;/li&gt;
&lt;li&gt;Whale Browser - 7.82%&lt;/li&gt;
&lt;li&gt;Edge - 5.85%&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;예상했던 대로 Chrome이 가장 많은 비중을 차지하고, Safari가 그 다음입니다. 삼성 인터넷도 꽤나 비중이 크네요!&lt;/p&gt;
&lt;p&gt;2018년까지만 해도 사용률 2위가 무려 &apos;IE&apos;입니다..! 그만큼 국내에서는 IE의 비중이 굉장히 높았습니다. 그래서 신경을 쓰지 않을 수 없었던 참 얄미운 녀석이었죠..&lt;br/&gt;
하지만 모바일 시장의 확대, 액티브엑스 탈피 등의 시장 변화와 함께 마침내 2022년 IE가 잠들면서 이전에 비하면 스트레스가 줄었다고 할 수 있겠네요.&lt;/p&gt;
&lt;h3&gt;웹 브라우저의 동작&lt;/h3&gt;
&lt;p&gt;웹 브라우저에 접속해 주소창에 도메인을 입력하면 아주 짧은 순간에 많은 일이 일어납니다. DNS를 통해 IP 주소를 획득하고, TCP를 통해 연결하고, HTTP 요청을 보내 응답을 받습니다.
이 과정에는 캐싱이 포함됩니다. 이 일련의 과정들은 다음에 더 자세히 알아보도록 하고😋 아무튼, 안전한 HTML 파일을 잘 받아왔다고 가정해봅시다😉&lt;/p&gt;
&lt;h4&gt;웹 브라우저의 구조&lt;/h4&gt;
&lt;p&gt;웹 브라우저는 다음과 같은 구조로 이루어져 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자 인터페이스(User Interface) - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분.&lt;/li&gt;
&lt;li&gt;브라우저 엔진(Browser Engine) - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어&lt;/li&gt;
&lt;li&gt;렌더링 엔진(Rendering Engine) - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.&lt;/li&gt;
&lt;li&gt;통신(Networking) - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.&lt;/li&gt;
&lt;li&gt;자바스크립트 해석기(Javascript Interpreter) - 자바스크립트 코드를 해석하고 실행&lt;/li&gt;
&lt;li&gt;UI(UI Backend) - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f20076b46244a8af02020cf7fd166890/b7baf/structure.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.78481012658227%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdulQwD/xAAVEAEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAQABBQJj/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFRABAQAAAAAAAAAAAAAAAAAAIOH/2gAIAQEABj8Cq//EABsQAAEEAwAAAAAAAAAAAAAAAAEAECFxMUHw/9oACAEBAAE/ISLQdLUW8N//2gAMAwEAAgADAAAAEKvP/8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQMBAT8Qh//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/EKf/xAAbEAEBAQACAwAAAAAAAAAAAAABEQBBUSEx4f/aAAgBAQABPxBJ8sJUtnNY9Gro+eXAkTOzBCG//9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;웹 브라우저 구조&quot;
        title=&quot;&quot;
        src=&quot;/static/f20076b46244a8af02020cf7fd166890/af1fa/structure.jpg&quot;
        srcset=&quot;/static/f20076b46244a8af02020cf7fd166890/ab180/structure.jpg 158w,
/static/f20076b46244a8af02020cf7fd166890/ba98e/structure.jpg 315w,
/static/f20076b46244a8af02020cf7fd166890/af1fa/structure.jpg 630w,
/static/f20076b46244a8af02020cf7fd166890/23301/structure.jpg 945w,
/static/f20076b46244a8af02020cf7fd166890/b7baf/structure.jpg 1088w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 집중해서 볼 부분은 바로 &apos;렌더링 엔진&apos;으로, 우리가 만든 마크업과 스타일을 해석해서 그려내는 역할을 합니다.&lt;br/&gt;
물론 두루두루 친해지고 싶지만 일단 여기선 렌더링에 집중해 봅시다!&lt;/p&gt;
&lt;h4&gt;렌더링 엔진의 종류&lt;/h4&gt;
&lt;p&gt;어떤 렌더링 엔진을 쓰는지는 웹 브라우저마다 조금씩 다릅니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Webkit (Safari)
&lt;ul&gt;
&lt;li&gt;Apple에서 개발, 컨커러 브라우저의 KHTML을 기반으로 만든 엔진&lt;/li&gt;
&lt;li&gt;Safari, iOS 브라우저에서 사용하며, 크롬도 Blink 탑재 전에는 해당 엔진을 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Blink (Chrome, Whale, Samsung Internet, Edge)
&lt;ul&gt;
&lt;li&gt;Google에서 개발, Webkit에서 파생된 엔진 (Chromium 28 버전부터 적용)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Trident (Internet Explorer)
&lt;ul&gt;
&lt;li&gt;Microsoft에서 개발, Internet Explorer에서 사용되었지만 웹 표준 미준수 + 각종 버그 + 보안 문제 등으로 이젠 안-녕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EdgeHTML (Edge)
&lt;ul&gt;
&lt;li&gt;Microsoft에서 개발, Trident에서 벗어나 Edge에서 사용되던 엔진이었지만, 2019년부터 Edge 브라우저를 Chromium 기반으로 재구축하면서 이젠 안-녕(2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gecko (Firefox)
&lt;ul&gt;
&lt;li&gt;Mozilla에서 개발&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;사실 웹 브라우저를 만드는 비법은 제조사마다 다르고, 각 엔진도 저마다 고유한 개성이 있어 동작 과정이 조금씩 다릅니다.&lt;/p&gt;
&lt;p&gt;그롬(그리고 아마 대부분의 최신 브라우저)의 경우 각 탭마다 별도의 렌더러 프로세스가 돌아가고 있어서, 여러 개의 탭을 열면 각가 렌더링 엔진이 동작해 해당 탭의 내용을 표시합니다.&lt;br/&gt;
그래서 하나의 탭이 죽어도 다른 탭은 멀쩡히 살아남을 수 있습니다.&lt;/p&gt;
&lt;h2&gt;웹 브라우저가 화면을 그려내는 과정&lt;/h2&gt;
&lt;p&gt;그렇다면 HTML, CSS, Javascript를 어쩜 그리 찰떡같이 해석해서 화면을 그려내는 것인가!가 이 글의 제일 궁금한 포인트이기에 그 일련의 흐름을 알아봅시다.&lt;/p&gt;
&lt;h3&gt;(1) 삐빅, HTML 읽는 중··· 🔍&lt;/h3&gt;
&lt;p&gt;HTML 문서를 받기 시작하면 우선 이를 &lt;strong&gt;파싱(Parsing)하는 작업&lt;/strong&gt;을 시작합니다.&lt;br/&gt;
파싱이란 문서를 해석하고 구조화된 데이터로 바꾸는 것으로, 말하자면 마크업을 렌더링하기 위한 형태로 바꾸는 단계입니다.&lt;/p&gt;
&lt;p&gt;렌더러 프로세스의 메인 스레드는 HTML 문서의 원시 바이트를 읽은 다음, 정해진 파일 인코딩에 맞춰 각각을 문자로 전환합니다. 그러면 아래와 같이 꺽쇄로 묶인 문자열을 읽게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
   &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;/&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
Hello
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;이나 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;는 W3C HTML5 표준에 규정된 문자열이므로 각각의 의미와 규칙을 이해할 수 있습니다. 브라우저는 이것들을 쪼개서 &apos;토큰(Token)&apos;으로 만듭니다.&lt;br/&gt;
예를 들어, &lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;을 보면 html 시작 토큰을 만들고, &lt;code&gt;&amp;#x3C;/html&gt;&lt;/code&gt;를 보면 html 종료 토큰을 만들어 냅니다. 여기에는 태그 뿐만 아니라 속성(&lt;code&gt;class&lt;/code&gt; 등)이나, 텍스트 같은 HTML 요소가 포함돼요.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ea20ce432bfadb1bbab87c587a99270d/bbbf7/htmlToToken.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVR42qWQMW/CMBCF/f9/AhILrLR0YChOooRWAXXP1I2mjRqB4uDajuTL3VV2paKqiIVPN91773R6gm9AMLP3vmmaruvatjXGXHGr6HHWnsOI2Pe91lopZaNA/2JEjMTWDZ+H45d1GDcCAPKiuFsssjRNk8C+rn8uUgQRmfAEXL6Z2WO53FX322r37hyyMFoX67WUMpEyz/NNlr1WFTMDwBjxAIyjAn6u7eQhm66e5slL+TGE8IX/LoHEw8hA7OO4MWwEBeEvVxoLIv128g0mD4+Bzf1S8AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;html to token&quot;
        title=&quot;&quot;
        src=&quot;/static/ea20ce432bfadb1bbab87c587a99270d/984b6/htmlToToken.png&quot;
        srcset=&quot;/static/ea20ce432bfadb1bbab87c587a99270d/4d6f2/htmlToToken.png 158w,
/static/ea20ce432bfadb1bbab87c587a99270d/3c1ae/htmlToToken.png 315w,
/static/ea20ce432bfadb1bbab87c587a99270d/984b6/htmlToToken.png 630w,
/static/ea20ce432bfadb1bbab87c587a99270d/e7d8e/htmlToToken.png 945w,
/static/ea20ce432bfadb1bbab87c587a99270d/58c38/htmlToToken.png 1260w,
/static/ea20ce432bfadb1bbab87c587a99270d/bbbf7/htmlToToken.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇게 문서를 토큰화했으면, 만든 토큰을 가지고 구조화시킵니다.
&lt;code&gt;&amp;#x3C;html&gt;&amp;#x3C;head&gt;&amp;#x3C;/head&gt;&amp;#x3C;/html&gt;&lt;/code&gt;에서 head 종료 토큰은 html 종료 토큰 전에 존재합니다. 따라서 head는 html의 자식이구나! 하고 판단할 수 있어요.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/7469ba2e10846111c028ab452820e128/bbbf7/htmlToNode.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 30.37974683544304%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVR42qWPPWsCQRCG73+FYJHflcJKC9MFUioq2AmCMWlSiLWNjeLH+X2eaLzLnt7e7O7MyOpVgjZ5mmFe5mF4Hb6gtU4A0Bi+DxECgAJAMszEzA6RHUFwGI+GYRA8lGm13kzceSzlNXEU8VRgfxsNdse+L1yBJ5OepiDaPVlG80roVkK3LGZFFF0rnwx3PPVW+3x9L2U/qm1P/SrrapMCIK19qPcaL9XCczH/9FPK8DJHxI4m9mJeRXohYPEH65jlbXHbi9Re7b6TbUv6X4nfxHhsP/M/OAODo1Kn/lTyewAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;html to node&quot;
        title=&quot;&quot;
        src=&quot;/static/7469ba2e10846111c028ab452820e128/984b6/htmlToNode.png&quot;
        srcset=&quot;/static/7469ba2e10846111c028ab452820e128/4d6f2/htmlToNode.png 158w,
/static/7469ba2e10846111c028ab452820e128/3c1ae/htmlToNode.png 315w,
/static/7469ba2e10846111c028ab452820e128/984b6/htmlToNode.png 630w,
/static/7469ba2e10846111c028ab452820e128/e7d8e/htmlToNode.png 945w,
/static/7469ba2e10846111c028ab452820e128/58c38/htmlToNode.png 1260w,
/static/7469ba2e10846111c028ab452820e128/bbbf7/htmlToNode.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;토큰을 파싱해 구조를 만들었으면 각 토큰은 해당하는 &apos;노드(Node)&apos;로 변환됩니다. 노드는 부모-자식이라는 계층적 관계를 통해 문서의 구조를 표현해내는 요소입니다.&lt;br/&gt;
사실 HTML 문서의 모든 것은 노드가 되어 구조를 형성합니다. 태그는 요소 노드(Element Node)가 되고, 그 안에 적은 건 텍스트 노드가 되죠. 속성은 물론, 독타입 선언이나 주석도 모두 노드가 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c1c25a24b1e0b01f3562def5cc8cd3a1/668eb/dom.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 136.70886075949366%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAIAAADzvTiPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC2klEQVR42o2Uy08TURSH+c+Mj8hCl8alIVFjjAs3GBPDAiI7IwujGN1pBBGMok2U+FgAJYBRkClQwNSUR2tpOwzQedx7z0tn2kJLC3JmNnPO+e6593fPnBZpZq7rFquWz+cBoGlay4FvIhKReDze1dnZ29vb3d19q709lUrthY6CmVlEcrlcIpFIJpOWZc3MzLiuuxeqg5kZG4wI99YiIkRozGHmFiICOBADrY1SWmujtVZKG2MO8ABQgRvWFBYhprW11UxmI6ovSHIcGHS2b2nsznK8M/2ta3GsY3mi8/dUh958F/FwGBwGCE2w+mh0qO1T/+WJt9e+Dlz+MnBl9uNVnXl+NFwRC9EwloRdhF3CXWaXsRRh9P9thw+gNlxyteeDAQYghGMKVt6b3squWn/WLILdfed/YDBAwm4iPXF9dLBtbOhSbua2mE1AqeUP3zYJBeni4v2F8bvzo107qSdkthH5OHClxSi829CQpVaqo2ClVBAEKnx9z/M831OBr5TyfV9rfQQMkdNEDlOvnymHyjlNYGIOtMnmtmynxCK1RwDifHEnt+kAMUb5NTCEIqEq7GQ+F1Lv7XRMb1vROaPGAOUVJu10LLsyrLcm0JQQeR8G0MAi9vt4/8k3va1vHp7ITt8Q8iDsFxGVTo5ciD0929dzyoqdF98CEgBdUxkZtRMUp+2NuJMZN6Vf1crh+dW25WTGi+vjbuEHYYBIjYKFYwYAowEgdffGUk5jEUBqLpiv9EZms2g7JHUwIxfzW7lsnoAJmwoWbHiZt7ml/vxKHzhT1XYiQ17aGfm5+uJ76tm6+0HBNjUKxnZs+vXZVw9ahx+fLszeFPRCrUF8Tr+bv3jv5Zmewda+yXMOzAkeFIzQuHpnwbcTvj1nvPUawWDXpOzAKniWEywD6jrBqgOQACX8e0K16kcqCIEQClX9Fbg8XKmsG+jySwi0b+FtAeqwZtS8Ze8/+C8xNvmCqVWUqQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Dom&quot;
        title=&quot;&quot;
        src=&quot;/static/c1c25a24b1e0b01f3562def5cc8cd3a1/984b6/dom.png&quot;
        srcset=&quot;/static/c1c25a24b1e0b01f3562def5cc8cd3a1/4d6f2/dom.png 158w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/3c1ae/dom.png 315w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/984b6/dom.png 630w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/e7d8e/dom.png 945w,
/static/c1c25a24b1e0b01f3562def5cc8cd3a1/668eb/dom.png 1008w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;주요 포인트는 &lt;strong&gt;HTML 문서를 읽어 노드로 만들고 계층 형태로 구조화한다는 것!&lt;/strong&gt;&lt;br/&gt;
이걸 트리 구조라고도 하는데 말 그대로 나무처럼 생겼어요. 뿌리가 있고 가지가 있으며 거기서 잎이 돋아난 나무를 거꾸로 배치한 것이 트리 구조입니다.&lt;br/&gt;
이렇게 구성된 노드 트리를 &lt;strong&gt;DOM(Document Object Model) 트리&lt;/strong&gt;라고도 불러요.&lt;/p&gt;
&lt;p&gt;그중에서도 처음으로 생성되는 가장 상위에 있는 노드인 &lt;code&gt;document&lt;/code&gt;를 루트(Root)라고 부릅니다. 루트 = 뿌리, 노드 = 가지라는 걸 생각하면 귀여운 이름이죠!
참고로 텍스트 노드처럼 자식을 가질 수 없는 노드는 리프(leaf)라고 부릅니다 🌿&lt;br/&gt;
개발자들은 뿌리(document node)를 진입점으로 문서 내 다른 DOM 요소들을 탐색하고 조작할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;DOM?&lt;/h4&gt;
&lt;p&gt;아까부터 DOM이라는 단어가 몇 번 언급되었는데, DOM은 말그대로, 문서(Document)를 객체(Object) 기반으로 표현한 모델(Model)입니다.&lt;/p&gt;
&lt;p&gt;이 모델은 HTML, XML 등의 문서 내 요소를 객체로 표현해 프로그래밍 언어에서 조작할 수 있게 하는 인터페이스를 제공합니다. 우리는 DOM API를 통해 DOM 객체를 조작할 수 있어요.&lt;br/&gt;
만약 span 텍스트를 바꾸고 싶다면 &lt;code&gt;document.body.getElementByTagName(&apos;span&apos;)[0].innerText = &apos;Hello&apos;&lt;/code&gt;로 접근해 조작하면 됩니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM Object
DOM에서 문서와 관련된 객체를 뜻하며, 접근하고 조작하기 위한 인터페이스를 제공합니다.&lt;br/&gt;
프로그래밍적으로 접근하고 조작할 수 있는 객체의 개념입니다.&lt;/li&gt;
&lt;li&gt;DOM Node
DOM Tree(=Node Tree)를 구성하는 온갖 노드들을 말합니다.
트리 구조를 통해 서로 간의 계층적 관계를 나타내요. 문서를 표현하는 각 콘텐츠를 지칭하는 개념입니다.&lt;/li&gt;
&lt;li&gt;DOM Element
DOM Node 중에서도 태그로 표현되는 요소들(&lt;code&gt;div&lt;/code&gt; 등)을 Element Node라고 합니다.
이들을 부르는 다른 말이 DOM Element에요.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇듯 DOM은 트리 구조로 웹 페이지를 표현하며, 이 DOM 트리를 이루는 구성요소가 바로 노드입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c184587551d3e12c11835cbc6963cfab/21062/cssom.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 18.354430379746837%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA10lEQVR42k2P607CQBBG+/5PZNQoqUoRGjAWrNDWEvAWNNGYLktnL8dsa4JfMsnMd/7MicRYnPcY67DWEeI9iHFY74/MHZk+BA7Gggi00t+hj7avn6SzjLyoUVowIrRieP/45i7LSaf3PBZrmr1grbDXUK6FeFgxuFqRjDeM0i3xsKSohWjzsiO5nTLPS5S2KKXQuuVt90U6m3OdTFgsq441zQ+Ncqxq4ezygZPzjPimYjR55vRiwfKpJRL5Uzb/lT1d73y/G9dphwTz8GVQDBN0D22/h/4XNYYvGCEiVb4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cssdom&quot;
        title=&quot;&quot;
        src=&quot;/static/c184587551d3e12c11835cbc6963cfab/984b6/cssom.png&quot;
        srcset=&quot;/static/c184587551d3e12c11835cbc6963cfab/4d6f2/cssom.png 158w,
/static/c184587551d3e12c11835cbc6963cfab/3c1ae/cssom.png 315w,
/static/c184587551d3e12c11835cbc6963cfab/984b6/cssom.png 630w,
/static/c184587551d3e12c11835cbc6963cfab/21062/cssom.png 926w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DOM은 후술할 CSSOM이라는 것과 결합해 렌더(Render) 트리를 만들며, 브라우저는 이걸 통해 화면을 그려냅니다.&lt;br/&gt;
따라서 &lt;strong&gt;DOM은 실제로 화면에 보여지는 것과 일치하지 않다&lt;/strong&gt;고 할 수 있습니다. 예를 들어, &lt;code&gt;display: none&lt;/code&gt; 처리한 요소는 화면에 보이지 않지만 DOM에는 존재하며, &lt;code&gt;:after&lt;/code&gt; 같은 가상요소는 렌더링되었지만 DOM 객체가 아니므로 자바스크립트로 조작하는 것이 불가합니다.&lt;/p&gt;
&lt;p&gt;또한, HTML 문서를 보고 만들긴 했지만 DOM이 HTML과 완전히 일치한다고 할 수도 없습니다. 브라우저는 우리가 닫는 태그를 빼먹고 썼더라도 친절하게 DOM을 구성해주니까요.&lt;/p&gt;
&lt;p&gt;한편, DOM은 자바스크립트의 영향을 받을 수 있습니다. 예를 들면 &lt;code&gt;appendChild()&lt;/code&gt; 메서드로 돔을 추가하는 것도 가능하죠! 그래서 자바스크립트에 의해 DOM 파싱은 &apos;방해받을 수&apos; 있습니다.
이에 대한 내용은 다음 글에서 좀 더 살펴보겠습니다.&lt;/p&gt;
&lt;h3&gt;(2) 삐빅, CSS 읽는 중··· 🔍&lt;/h3&gt;
&lt;p&gt;CSSOM은 이름에서 유추할 수 있듯, CSS Object Model의 약자로 CSS 문서를 객체로 나타내고 조작하기 위한 인터페이스를 제공하는 웹 표준입니다.&lt;br/&gt;
렌더링 엔진이 HTML을 쫙- 스캔할 때, 아마 대부분 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;에서 스타일시트를 만나게 될 거에요. 렌더링에 이 CSS가 필요하다고 생각되면 요청해서 스타일시트 내용을 받아오게 됩니다.&lt;br/&gt;
CSS도 파싱 과정을 거쳐서 Bytes -&gt; Characters -&gt; Tokens -&gt; Nodes -&gt; Object Model로 만들어집니다. 이걸 CSSOM이라고 부르고요. 마찬가지로 트리 형태로 구조화되어 있어요.&lt;/p&gt;
&lt;p&gt;CSS의 C는 캐스케이딩이죠. 즉, 스타일 규칙은 계단식으로 상속됩니다. 브라우저는 트리 구조를 따라 각 노드에 적용할 수 있는 가장 일반적인 규칙부터 시작해 추가적인 스타일을 적용합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;body { font-size: 16px; }
p { font-weight: bold; }
span { display: none; }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;예를 들면, &lt;code&gt;&amp;#x3C;p&gt;&lt;/code&gt;는 &lt;code&gt;&amp;#x3C;body&gt;&lt;/code&gt;의 자식이니까 &lt;code&gt;&amp;#x3C;body&gt;&lt;/code&gt;에 적용된 스타일인 &lt;code&gt;font-size: 16px;&lt;/code&gt;가 적용됩니다. 그 다음에는 자기 자신의 스타일인 &lt;code&gt;font-weight: bold;&lt;/code&gt;가 추가로 적용됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bb73360d8dd76d980020bd9ef7593cd1/bbbf7/css.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.34177215189873%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABHUlEQVR42o2QbWvCMBSF+/9/lmyDwdQPzpXZrXRSa9WZ2DTNe3LGjSAMhuxCPtyXPJxzCtyplBKmaYK1FsYYaK2gXcTuJNF0DM2OozsphJhuf4p7wBBCBlVVhbqu4azBkU1YvDM8r3ZYlD3KZoB1/wTGGKGUAmMMwzBAqQnOB0iToB05oJuUndwF0gGpk1JmoNY6KyX71APpSvujiiO3eN30WFd7rKoDum9zg3DOM4gydM5hHEe0bZv39PZni9Vmj3XV460+4yw8iu1B42G5xezlE0/LL3y0IisjgBAC3vsMpf5yuaAsy9yPo0TdaczmDR4XDeblET3zKMQU0PMIoRJ8TDAu/oKQUrJPM1JKudKOZlx69PyaqQ8RxgX8ANIpHMsSVyDUAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;css tree&quot;
        title=&quot;&quot;
        src=&quot;/static/bb73360d8dd76d980020bd9ef7593cd1/984b6/css.png&quot;
        srcset=&quot;/static/bb73360d8dd76d980020bd9ef7593cd1/4d6f2/css.png 158w,
/static/bb73360d8dd76d980020bd9ef7593cd1/3c1ae/css.png 315w,
/static/bb73360d8dd76d980020bd9ef7593cd1/984b6/css.png 630w,
/static/bb73360d8dd76d980020bd9ef7593cd1/e7d8e/css.png 945w,
/static/bb73360d8dd76d980020bd9ef7593cd1/58c38/css.png 1260w,
/static/bb73360d8dd76d980020bd9ef7593cd1/bbbf7/css.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다만 아직 위의 트리는 완전한 CSSOM 트리가 아니에요! 사실 브라우저들은 저마다 기본으로 제공하는 스타일이 있습니다. 개발자 도구를 열어보면 우리가 정의하지 않은 속성이 user agent stylesheet에서 적용된 걸 볼 수 있어요.&lt;/p&gt;
&lt;h4&gt;CSS 속독 비법: 오른쪽부터 읽기&lt;/h4&gt;
&lt;p&gt;참, 브라우저는 CSS를 빠르게 파싱하기 위해 오른쪽에서 왼쪽으로 읽는다는 사실 아셨나요?! RTL(right-to-left) 파싱 또는 상향식 파싱이라고 하며 말 그대로 셀렉터의 오른쪽(자식)부터 왼쪽(부모)으로 거슬러 올라가며 읽습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;header div h1 p span { color: red; }
header span.text { color: red; }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 두 개의 규칙이 있습니다. 스타일을 계산할 때 어느 쪽이 더 빠를까요?&lt;/p&gt;
&lt;p&gt;사실 웬만한 모던 브라우저는 CSS 선택자 매칭 최적화가 되어 있어 이 정도로 큰 차이는 없겠지만 일단 이론상으로는 후자가 좀 더 빠릅니다.&lt;/p&gt;
&lt;p&gt;전자는 span부터 시작해, p, h1 등을 거슬러 올라가 header까지 일치하는지 확인해야 합니다. 브라우저가 DOM 트리를 순회하며 요소를 확인해야 하는데, DOM 트리가 크거나 복잡한 경우 속도가 느려질 수 있어요.&lt;br/&gt;
후자는 클래스 셀렉터를 쓰고 있는데, 이렇게 하면 DOM 트리를 탐색할 필요 없이 렌더링 엔진이 알아서 빠르게 인덱싱을 하기 때문에 상대적으로 더 빠릅니다.&lt;/p&gt;
&lt;p&gt;이렇게 오른쪽부터 읽는 이유는 스타일을 계산해야 하는 요소는 하나인데 읽어야 하는 규칙은 산더미처럼 많기 때문입니다. 가장 오른쪽부터 시작해서 일치하는지 않는지 먼저 빠르게 판단하면 나머지 셀렉터는 읽지 않고 다음 판단으로 넘어갈 수 있습니다.
왼쪽부터 읽어야 한다면 DOM 트리 탐색을 위해 전체 HTML을 스캔해서 갖고 있어야 할 수도 있겠죠.&lt;/p&gt;
&lt;p&gt;또, 각 브라우저별 렌더링 엔진이 가진 최적화 기술도 RTL 파싱에 적합한 매커니즘을 갖고 있다고 합니다. 하지만 이제 모던 브라우저는 성능이 짱짱하기에 셀렉터 최적화에 너무 매달릴 필요는 없을 것 같네요.&lt;/p&gt;
&lt;h3&gt;(3) 삐빅, 렌더 트리 구성하는 중··· 🌳&lt;/h3&gt;
&lt;p&gt;HTML과 CSS를 읽어 DOM 트리와 CSSOM 트리를 구성했으면, 이제 둘을 결합시켜 렌더 트리를 만들 차례입니다. 렌더 트리는 화면에 실제로 표시되는 시각적 요소를 계층적으로 나타낸 것으로, 얘도 ROM(Render Object Model)이라 부르기도 합니다.&lt;/p&gt;
&lt;p&gt;브라우저는 아래와 같은 단계를 거쳐 렌더 트리를 구성합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DOM 트리의 루트(document)에서 시작해서 렌더링할 노드를 찾아냅니다.&lt;/li&gt;
&lt;li&gt;각 노드에 일치하는 CSSOM 규칙을 찾아 적용합니다.&lt;/li&gt;
&lt;li&gt;이제 콘텐츠와 스타일을 결합해 가시적인(visible) 노드를 구성합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d339153b6e64d8decde5b9606a9193b9/53c9c/tree.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.70886075949367%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvLgNgIor/xAAXEAADAQAAAAAAAAAAAAAAAAABEDEA/9oACAEBAAEFAkELjF//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAACAwEBAAAAAAAAAAAAAAAAAREhMRBB/9oACAEBAAE/IfZHaGoeEqS3zQWc/9oADAMBAAIAAwAAABAT4ID/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAgEBPxAp/8QAHxAAAgIBBAMAAAAAAAAAAAAAAREAITEQQVFxocHw/9oACAEBAAE/EDxYq+IqtjRmKEgUPnM9qooiAW4HoaeAZg60/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;dom cssom rom&quot;
        title=&quot;&quot;
        src=&quot;/static/d339153b6e64d8decde5b9606a9193b9/af1fa/tree.jpg&quot;
        srcset=&quot;/static/d339153b6e64d8decde5b9606a9193b9/ab180/tree.jpg 158w,
/static/d339153b6e64d8decde5b9606a9193b9/ba98e/tree.jpg 315w,
/static/d339153b6e64d8decde5b9606a9193b9/af1fa/tree.jpg 630w,
/static/d339153b6e64d8decde5b9606a9193b9/23301/tree.jpg 945w,
/static/d339153b6e64d8decde5b9606a9193b9/53c9c/tree.jpg 1045w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;핵심은 눈에 보이는 시각적 요소만 포함한다는 점&lt;/strong&gt;입니다. 예를 들어, &lt;code&gt;display: none&lt;/code&gt;이 적용된 DOM 요소는 화면에 렌더링되지 않으므로 렌더 트리에 포함되지 않습니다.
마찬가지로 &lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;이나 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;도 시각적인 내용이 없기 때문에 생략됩니다.&lt;br/&gt;
위 이미지에서도 &lt;code&gt;&amp;#x3C;span&gt;&lt;/code&gt;은 &lt;code&gt;display: none&lt;/code&gt;이 적용됐기에 자식인 텍스트 노드(&quot;World&quot;)는 렌더 트리에서 제외됐어요. 마찬가지로 &lt;code&gt;&amp;#x3C;html&gt;&lt;/code&gt;이나 &lt;code&gt;&amp;#x3C;head&gt;&lt;/code&gt;도 시각적인 내용이 없기 때문에 생략된 걸 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;덧붙여 &lt;code&gt;:before&lt;/code&gt; 및 &lt;code&gt;:after&lt;/code&gt;로 만든 가상 요소는 DOM 요소는 아니지만 화면에 렌더링되므로 렌더 트리에 포함됩니다.&lt;/p&gt;
&lt;h3&gt;(4) 삐빅, 설계도 만드는 중··· 📐&lt;/h3&gt;
&lt;p&gt;지금까지의 흐름을 거쳐 &apos;그려내야 할 것&apos;을 알아냈습니다. 그럼 이제 이대로 화면에 그리면 되는 걸까요? 사실··· 할 일이 더 있습니다.
구체적으로 어디에 얼마만큼 그려야 하는지 아직 모르기 때문입니다.&lt;br/&gt;
예를 들어 &lt;code&gt;width: 50%&lt;/code&gt;는 어떤 부모를 기준으로 한 건지, &lt;code&gt;font-size: 4em&lt;/code&gt;은 어디서부터 계산해야 하는지 아직은 알 수 없어요. 그래서 브라우저는 렌더 트리의 루트부터 시작해
각각의 정확한 위치와 크기를 알아내야 합니다. &quot;width: 50%는 250px이고, font-size: 4em은 22px이군&quot;하고 정확하게 파악하는 거죠.&lt;/p&gt;
&lt;p&gt;이 과정을 &lt;strong&gt;&apos;Layout(레이아웃)&apos; 또는 &apos;Reflow(리플로우)&apos;&lt;/strong&gt; 라고 부릅니다. 최종적인 설계도를 그리는 단계라 할 수 있겠네요!&lt;/p&gt;
&lt;p&gt;브라우저는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model&quot;&gt;box model&lt;/a&gt;에 따라 페이지에서 노드가 차지하는 박스를 만들고, 이를 트리 형태로 구조화합니다.
그리고 각 박스의 크기와 위치를 계산해서 페이지의 레이아웃을 구성합니다.&lt;/p&gt;
&lt;h3&gt;(5) 삐빅, 화면을 그리는 중··· 🎨&lt;/h3&gt;
&lt;p&gt;드디어 웹 페이지에 화면을 그릴 수 있습니다! (마침내!)&lt;br/&gt;
레이아웃 단계가 끝나면 &lt;strong&gt;렌더링 트리를 화면의 픽셀로 변환하는 &apos;페인트(Paint)&apos; 이벤트가 실행됩니다.&lt;/strong&gt; 여기서도 브라우저는 화면에 그려낼 요소를 트리 형태로 구조화하며, 이를 페인트 트리라고 부릅니다.&lt;/p&gt;
&lt;h4&gt;합성 단계&lt;/h4&gt;
&lt;p&gt;화면에 그려내야 하는 단계인 만큼, &apos;페인트&apos; 단계는 렌더링 엔진이 가장 바쁜 구간입니다. 특히 그림자나 그라디언트 같은 렌더링은 페인팅하는 데 시간이 걸리는 비싼 작업이죠.&lt;br/&gt;
그래서 이때 보다 &lt;strong&gt;효율적인 렌더링을 위해 &apos;합성(Composite)&apos; 이라는 과정&lt;/strong&gt;을 거칩니다.&lt;/p&gt;
&lt;p&gt;합성은 렌더링 파이프라인의 레이아웃 및 페인팅 단계 후에 발생합니다. 최종적으로 보여질 화면을 위해 웹 페이지의 여러 요소를 결합하거나 투명도 효과를 적용합니다. &lt;code&gt;z-index&lt;/code&gt;, &lt;code&gt;opacity&lt;/code&gt; 같은 값을 렌더링에 적용하는 거죠.
크롬의 경우, 컴포지터 스레드(compositor thread)라는 별도 스레드가 합성을 담당합니다.&lt;/p&gt;
&lt;h4&gt;레이어로 나누면 편하니까&lt;/h4&gt;
&lt;p&gt;이때 요소를 &lt;strong&gt;&apos;레이어&apos;로 분리하여 관리하기 위해 레이터 트리(Layer Tree)를 생성&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;p&gt;어도비 포토샵을 써보셨으면 레이어 패널에서 눈을 끄거나 켜면서 레이어를 관리한 경험이 있으실 텐데 그것과 비슷합니다!
예를 들어 사이드 네비게이션 바가 열린 화면을 그려야 하는 경우를 생각해 봅시다.
기존 메인 화면 위에 그려도 되지만, 레이어 위에 네비게이션 바를 그려서 합성하는 게 훨씬 효율적입니다.
네비게이션을 닫는다고 해도 해당 레이어에만 변화가 일어나니 전체를 다시 렌더링 할 필요도 없죠!&lt;/p&gt;
&lt;p&gt;이렇게 웹 페이지를 몇 개의 레이어로 나눈 뒤 컴포지터 스레드에서 각각을 칠하고 합성하면 빠르고 효율적으로 작업을 끝낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;레이어 분리 상황을 보고 싶다면 크롬 개발자 도구의 Layers 탭에서 확인할 수 있습니다. 세부사항을 보면 합성 원인도 확인할 수 있어요.
만약 해당 패널이 보이지 않는다면, &lt;code&gt;Cmd(Ctl)+P&lt;/code&gt;로 검색 창을 띄운 뒤 &lt;code&gt;&gt;Layers&lt;/code&gt;를 입력하세요!&lt;/p&gt;
&lt;h4&gt;하드웨어··· 가속!!!&lt;/h4&gt;
&lt;p&gt;혹시 하드웨어 가속에 대해 들어보셨나요?? 여기서는 CPU가 처리하기 어려운 복잡한 작업을 &lt;strong&gt;GPU에서 처리하도록 하여 성능 향상을 끌어내는 것&lt;/strong&gt;을 말합니다.
GPU는 그래픽 렌더링과 병렬 처리에 최적화되어 있기 때문에 복잡한 그래픽 작업을 보다 효율적으로 처리합니다.
&lt;strong&gt;CSS 속성으로 transfrom, opcity 속성을 사용하면 GPU에서 처리되어 더 부드럽게 애니메이션을 표현할 수 있습니다.&lt;/strong&gt;
그 외에 canvas나 WebGL도 하드웨어 가속으로 처리됩니다.&lt;/p&gt;
&lt;p&gt;사실 레리어도 세분화해서 나뉘어지지만, 여기서는 하드웨어 가속을 사용하여 처리하는 그래픽 레이어를 가리킵니다.
레이어가 생성되면 일반적으로 하드웨어 가속이 발생하고, GPU에서 레이어들을 합성하여 최종 이미지를 생성합니다.&lt;br/&gt;
하지만 trnasform, opacity 속성을 쓴다고 항상 레이어가 생성되어 하드웨어 가속이 발생하는 것은 아닙니다. 레이어를 관리하는 데는 비용이 들기 때문에
브라우저는 자기 마음대로(=최적화 상황에 따라) 레이어를 만들지 않거나 서로 합치기도 합니다. 하지만 대부분의 경우는 렌더링 성능을 향상시킬 수 있기에 최대한
하드웨어 가속 속성을 써서 전환 효과를 만드는 것이 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;.slide {
   will-change: transform;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 필요하다면 &lt;code&gt;will-change&lt;/code&gt;라는 속성을 써서 브라우저에게 해당 요소를 레이어로 승격시키고 하드웨어 가속을 쓰고 싶다고 말할 수도 있습니다.
하지만 이 경우에도 적용할지 여부는 브라우저 마음이라는 점!&lt;/p&gt;
&lt;h4&gt;최적화 = 일 덜 시키기&lt;/h4&gt;
&lt;p&gt;화면을 그리기 위해 렌더링 엔진은 &lt;strong&gt;Layout =&gt; Paint =&gt; Composite&lt;/strong&gt; 이라는 과정을 거친다는 것을 알았습니다.
그렇다는 건 화면에 변화가 일어났을 때 해당 영역에서 저 과정을 반복한다는 셈이죠.
그래서 &lt;strong&gt;성능 최적화를 위해서는 레이아웃이나 페인트를 발생시키는 상황을 줄이는 것이 좋습니다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이른바 리플로우/리페인트라고 부르는, &apos;다시 그리는 비용&apos;을 줄이려면 위 파이프라인에서 합성만 발생하는 것이 가장 좋고요!
즉, 렌더링 엔진에게 일을 덜 시키면 됩니다. 요 내용은 나중에 프레임 최적화를 배울 때 더 살펴보겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;요약&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;국내 브라우저 TOP3 : 1) 크롬  2) 사파리  3) 삼성 인터넷&lt;/li&gt;
&lt;li&gt;브라우저의 렌더링 엔진이 HTML과 CSS를 해석해서 화면을 그려준다.
&lt;ul&gt;
&lt;li&gt;크롬은 Blink, 사파리는 Webkit, 파이어폭스는 Gecko 엔진을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;렌더링 과정&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;① HTML 해석 후 DOM 트리 구성&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;② CSS 해석 후 CSSOM 트리 구성&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;③ DOM + CSSOM 결합하여 렌더 트리 구성&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;④ 레이아웃 계산&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;⑤ 페인트 및 레이어 합성&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3&gt;에필로그&lt;/h3&gt;
&lt;p&gt;브라우저가 웹 페이지를 표시하려면 제법 긴 과정을 거쳐야 한다는 걸 알았습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;① 리소스 가져오기&lt;br/&gt;
② 파싱&lt;br/&gt;
③ DOM 트리 &amp;#x26; CSSOM 트리 구성&lt;br/&gt;
④ 렌더 트리 구성&lt;br/&gt;
⑤ 레이아웃 계산&lt;br/&gt;
⑥ 페인팅 &amp;#x26; 합성&lt;br/&gt;
⑦ 렌더링&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 &lt;strong&gt;&apos;주요 렌더링 경로(CRP; Critical Rendering Path)&apos;&lt;/strong&gt; 라고도 부릅니다. 말그대로 사용자에게 꼭 필요한 화면을 렌더링하는 데 필요한 흐름입니다.&lt;/p&gt;
&lt;p&gt;그럼 이쯤 드는 생각:
&quot;브라우저가 렌더링을 하는 방법을 알았으니, 이제 어떻게 렌더링 최적화를 할 수 있을지 궁금한데...&quot;&lt;/p&gt;
&lt;p&gt;그래서 CRP를 최적화하는 것을 포함해 브라우저가 이미지, 애니메이션 등 리소스를 표현할 때 어떻게 성능 최적화를 할 수 있을지 이제부터 알아봅니다!(빠밤)&lt;br/&gt;
결국 우리의 목적은 웹 페이지를 빠르게 그려내고 상호 작용할 수 있도록 해서 유저의 체감 성능을 높이는 거니까요.😉&lt;/p&gt;
&lt;p&gt;그럼, 다음 포스팅도 기대해주세요! 끝까지 읽어주셔서 감사합니다 🙇‍♀️&lt;/p&gt;</content:encoded></item><item><title><![CDATA[주소창에 www.google.com을 입력했을 때 일어나는 과정]]></title><description><![CDATA[개발자로서 주소창에 특정 웹 페이지의 주소를 입력했을 때, 어떤 과정을 통해 데이터가 전달되고, 화면에 렌더링되는지를 확실하게 알아봅시다.
(면접에서 나오는 단골 질문이기도 하고..^^) 데이터를 받아오는 과정 1. www.google.com…]]></description><link>https://kirahaa.github.io/when-searching-google/</link><guid isPermaLink="false">https://kirahaa.github.io/when-searching-google/</guid><pubDate>Fri, 01 Sep 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;개발자로서 주소창에 특정 웹 페이지의 주소를 입력했을 때, 어떤 과정을 통해 데이터가 전달되고, 화면에 렌더링되는지를 확실하게 알아봅시다.&lt;br/&gt;
(면접에서 나오는 단골 질문이기도 하고..^^)&lt;/p&gt;
&lt;h3&gt;데이터를 받아오는 과정&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;a href=&quot;http://www.google.com&quot;&gt;www.google.com&lt;/a&gt; 입력하면 입력한 URL 주소 중, 도메인 이름에 해당하는 google.com을 DNS 서버에서 검색을 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;웹 브라우저는 DNS 서버에 검색하기 전에 캐싱된 DNS 기록들을 먼저 확인합니다.&lt;br/&gt;
만약 해당 도메인 이름에 맞는 IP 주소가 존재하면, DNS 서버에 해당 도메인 이름에 해당하는 IP주소를 요청하지 않고 캐싱된 IP주소를 바로 반환합니다.&lt;br/&gt;
일치하는 IP 주소가 존재하지 않는다면, 다음 과정인 DNS 서버 요청으로 넘어갑니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DNS(Domain name system) 서버는 도메인 주소에 대응하는 IP 주소를 찾아주는 역할을 수행합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. 가장 가까운 DNS 서버에서 해당 도메인 이름에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달을 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ISP(ex. SK 브로드밴드, KT...)를 통해 DNS서버가 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS Query를 전달합니다.&lt;br/&gt;
DNS Query는 현재 DNS 서버에 원하는 IP 주소가 존재하지 않으면 다른 DNS 서버를 방문하는 과정을 원하는 IP 주소를 찾을 때까지 반복합니다.&lt;br/&gt;
해당 도메인 이름에 맞는 IP 주소로 변환하는 과정은 점(.)을 기준으로 계층적으로 구분하여 구성이 됩니다.&lt;br/&gt;
해당 계층의 탐색 순서는 뒤에서부터 해당 도메인 이름에 맞는 지역 DNS를 탐색하며, root DNS 서버가 나올때까지 거꾸로 탐색합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ex) . =&gt; com =&gt; google.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이와 같이 Local DNS 서버가 여러 DNS 서버를 차례대로 물어봐서 답을 찾는 과정을 &lt;strong&gt;Recursive Query&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ad4d1651f22bf52400b38576dc237078/ed282/recursive_query.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACvUlEQVR42oWSz28MYRzGJ5G44YS/ACdSXSWaCIkf7bZ+RClpOUjUQYITB60eSHDQhjhI9ODiQFDRrYQ2SlVFyZqu7bb7a+Z9Z95933fefWfe2Znd2Z3ZDKlsL46e5HN7niffPPlK0v+1enJycn8sFtsvSdKq/7oxxgcIIW0Qwg5VVTsVRTmez+e7FxcXT6VSqTOZTOZsybaXKClkZDneOz8fPzM7O3t2ZmamBypKVyNTKBSilNJ2COG+RmEThLCJENJMCN+Tz+ebG3Bu702n061vRkc734yPnxwbG+t6/frl4cRiYteLF89Hnj198ioIgs0Iob2apjVDCLcjhLZKjLGNuVxurV+p3KuURAWA/FHhOO2VknCLRWP4myxvKgtr3jaLP99NTW2xLT7EEFz+/un9ZT8MD/mVcsXi/F48Hl9HKV3fuPAcAKCbGOQyxXhQVbU+XdcvFnTYn0ylBqenp/t/zM09nJv79vDDx+mBZDJ5Har5m9ls+mo2m73CKLtBCLkEADiNEOpd2TEMgw7fMR/4JeuuEOZtIcTu30HtmlMkw0XDeExp8aTgRrdTpCOexYcwxgOqmjvol+0hv2Te8Wu1+67nRVfKIIQ9JucvBTMyFjMSBOMkQmicMyONdbAEVDWnAvAVAnUWQZAjBbSk63pa07SYxXmCE/zL4jzNGHulKEqX5NXrzUG1esJznDYuRFS4oiMMw07TNNcIwXan5r9fSMjy+Xhc7pPlX31VpxpRFGVDUK0e8zw36rpuVDhOW7lcPuGVSk2S53mffa+8bDEjoJTWCcF127b/YIxHuUGIRQshI7hGDVrL5bK/374dFwCAd+WSHVoGqTPGGgSu6y7btj0hGYaxU6c0Qk0zYppmhFIa0XU9omlaq4pQS1rXI5mM2sKYve3LROzIyPCtRwsLC60Nz0ruHzsar/cX9cgr/gZxD7YAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;recursuve query&quot;
        title=&quot;&quot;
        src=&quot;/static/ad4d1651f22bf52400b38576dc237078/984b6/recursive_query.png&quot;
        srcset=&quot;/static/ad4d1651f22bf52400b38576dc237078/4d6f2/recursive_query.png 158w,
/static/ad4d1651f22bf52400b38576dc237078/3c1ae/recursive_query.png 315w,
/static/ad4d1651f22bf52400b38576dc237078/984b6/recursive_query.png 630w,
/static/ad4d1651f22bf52400b38576dc237078/e7d8e/recursive_query.png 945w,
/static/ad4d1651f22bf52400b38576dc237078/ed282/recursive_query.png 964w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.전달받은 IP주소를 이용하여 웹 브라우저는 웹 서버에게 해당 웹사이트에 맞는 html문서를 요청합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;해당 HTTP 요청 메세지는 TCP/IP 프로토콜을 사용하여 서버로 전송됩니다.&lt;br/&gt;
TCP는 전송 제어프로토콜로 데이터의 전송을 제어하고 데이터를 어떻게 보낼 지, 어떻게 맞출 지 정합니다.&lt;br/&gt;
IP의 특징인 비신뢰성과 비연결성으로 인해 IP 프로토콜 만으로는 통신을 할 수 없습니다. 그렇기에, 신뢰성과 연결성을 책임지는 TCP를 활용하여 통신을 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP/IP : 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신규약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP(Internet Protocol)
&lt;ul&gt;
&lt;li&gt;전 세계 수억대의 컴퓨터가 인터넷을 하기 위해서는 서로의 정체를 알 수 있도록 특별한 주소를 부여했는데 이 주소를 IP주소라 한다.&lt;/li&gt;
&lt;li&gt;IP주소는 4바이트로 이루어진 주소번호를 사용한다. ex)192.168.100.100&lt;/li&gt;
&lt;li&gt;숫자로 된 인터넷 주소는 식별하기 어렵기에 인간이 식별하기 쉬운 도메인 이름으로 변환시켜주는 Domain Name 서비스를 사용한다. ex) &lt;a href=&quot;http://www.naver.com&quot;&gt;www.naver.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Internet Protocol의 줄임말로, 인터넷에서 컴퓨터의 위치를 찾아서 데이터를 전송하기 위해 지켜야 할 규약이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TCP(Transmission Control Protocol)
&lt;ul&gt;
&lt;li&gt;두 호스트가 교환하는 데이터와 승인메세지의 형식을 정의&lt;/li&gt;
&lt;li&gt;서버와 클라이언트간의 데이터를 신뢰성있게 전달하기 위해 만들어진 규약&lt;/li&gt;
&lt;li&gt;TCP는 데이터 패킷에 일련의 번호를 부여하여 데이터 손실을 찾아서 교정하고, 순서를 재조합하여 클라이언트에게 전달할 수 있게 해준다. 이는 데이터가 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 뒤바뀌어서 전달될 수 있기 때문에 중요하다.&lt;/li&gt;
&lt;li&gt;복잡해서 신뢰성이 높다.&lt;/li&gt;
&lt;li&gt;인터넷은 패킷을 이용해서 정보를 전달하므로, 이 패킷을 전달하는 규약도 필요하다.&lt;/li&gt;
&lt;li&gt;패킷: 데이터를 일정한 크기로 자른 단위로 인터넷에서 정보를 전달하는 단위이다. 나누어진 패킷이 순서대로 도착한다는 보장이 없으므로 규칙이 필요하다.&lt;/li&gt;
&lt;li&gt;TCP는 전달받은 패킷을 재조립하고, 패킷에 손상이 있거나 손실된 패킷이 있다면 재전송을 요청하는 패킷을 전송하여 재전송받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;즉, IP는 데이터가 찾아갈 주소, TCP는 찾아온 데이터가 형식에 맞게 왔는지 확인하는 필터입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP는 3 way handshake 과정을 통해 연결 및 데이터를 수신받고, 4 way handshake 과정을 통해 연결을 종료합니다.&lt;/p&gt;
&lt;p&gt;🎈 &lt;strong&gt;3 way handshake의 과정&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 클라이언트는 B 서버에 접속을 요청하는 SYN 패킷을 전송합니다.&lt;/li&gt;
&lt;li&gt;B 서버는 SYN 요청을 받고 A 클라이언트에게 요청을 수락한다는 SYN_ACK flag가 설정된 패킷을 전송합니다.&lt;/li&gt;
&lt;li&gt;A 클라이언트는 B 서버에게 ACK를 전송 후, 연결이 이루어지고 데이터가 오고 가게 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/501247226fffe9d0df1ac51492c81e90/298c1/3_way_handshake.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 73.41772151898735%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABcRAAAXEQHKJvM/AAACpklEQVR42q1UTWsTQRiexFqt9itNk+xOZnfcTbrZJnFbSaylFaI0jRFpoZUUIUpoaJUiigftTRb01IMfFG8F9SAeSi9CCSVpmmQ2Kdm2lP4Gb/4GhZEpTTXRYA++MAy88+778TzPuwD8Mgv4z2YFALQ0JqaUWimlLUfH2hDPzqmju94cDke7IAhQkpyuk1QXBIcHIVdwMPnA7089HfR6vZ11o4qiU7bb7R0Y8yrrNJFItDJ/sVicJoS8KZVKr/L5fIJ1E4/HzyCELiPOEffduR8Ozj6LyLLsrEsIIbTzPC8Kgh0yXywW62H+3V3z/d7eHi2Xy7RarX4EAHQHg4rqdnZr0GkfC0ynRvtn5qOcl3P8PkELQsiNELohCEIAIdRWe8hk8h7DMK7t7+9EdnYMmUFjs9m6PFevh2RVvaVEb48NLLyMKaFI73E2v9/fKoqiDWPMIYR62EdNmGcwsGKWyPo3TpvTFYyxGn6dk4dXv7Y1BbzG5ubm5sNMJrNWLBY/EEI+ra2tZvL53KOjmH/KzFKTDaWUSQFsb2+vHhwcUMMwvpum+aNSqVBCyJcTJcQYn+V5vhdj3F3zLS4uIl3XR7LZbF8uty5vbGx4V1ZWDmXFMHe7e/vUqSTvv/dY5PnQuTqWGcOMaYy5fiYNl0s7z8BvtkEIoSEIe6KM4cDdJxOuRtmwiowYdodCodM+nxxm/q2trRQhJFsul7OFQmGOxUej0S7Wkpuz3VQmUqMXZxb+kI2Fscvz/DiEUGHrlE5PdrAHQshbwzCoaZq0UqksAwA6NU1TLgQCA4IkjKtTc8OD888jsqY56/CTJMnFxvV4oCDLh6MeWjqd7lhaWoK6rsNkMnm8XkPLJalvcvaK6AuMhF98vhR5V2j/28/B2rDoliZqaMrwT+ASyxeVojxIAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3 way handshake&quot;
        title=&quot;&quot;
        src=&quot;/static/501247226fffe9d0df1ac51492c81e90/984b6/3_way_handshake.png&quot;
        srcset=&quot;/static/501247226fffe9d0df1ac51492c81e90/4d6f2/3_way_handshake.png 158w,
/static/501247226fffe9d0df1ac51492c81e90/3c1ae/3_way_handshake.png 315w,
/static/501247226fffe9d0df1ac51492c81e90/984b6/3_way_handshake.png 630w,
/static/501247226fffe9d0df1ac51492c81e90/e7d8e/3_way_handshake.png 945w,
/static/501247226fffe9d0df1ac51492c81e90/58c38/3_way_handshake.png 1260w,
/static/501247226fffe9d0df1ac51492c81e90/298c1/3_way_handshake.png 2293w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;🎈 &lt;strong&gt;4 way handshake 과정&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송합니다.&lt;/li&gt;
&lt;li&gt;서버는 확인메세지 ACK를 보낸 후, 자신의 통신이 끝날 때까지 기다립니다.&lt;/li&gt;
&lt;li&gt;서버의 통신이 끝났으면 연결이 종료되었다고 클라이언트에 FIN 플래그를 전송합니다.&lt;/li&gt;
&lt;li&gt;클라이언트는 확인했다는 메세지 ACK를 보냅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;만약, Client에서 세션을 종료시킨 뒤 도착하는 패킷이 있다면 해당 패킷은 Drop되고 데이터는 유실되게 됩니다.&lt;/li&gt;
&lt;li&gt;이러한 현상을 위해 Client는 Server로부터 FIN을 수신하더라도 일정시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 TIME_WAIT 과정을 마지막으로 거치게 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/fd525edf82b680152ac8096c5f60054d/9bae8/4_way_handshake.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.15189873417721%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0UlEQVR42o2TiY4aMQyGef/XKmhVVqUc5RpQgZUY2IFyzkzufFWyMAL2aC1FVpz4t38fNR7EOcdqtWK321U2733UUkqWyyVFUVT269tVardO4VhrOZ5ztDaPseK7LgXeeT6T2p3DRefaIozDeiKwMbr6Y84FshRIpdBaU5Ylxph7wGBMkoTBcMgkSRj/nqOsw3h4Waa0uj2kAwfsVhk/Wy1+tFqMRiPG4zH7/b5iEAFDhGDcbrccDntedweurKxzKCkx2lDkAnXM8c5FNl/W8FYKZTFKBzTmkynPT9/xQsW3P6s19W91Go0G9fqbns1mkX5oWu2x6G+ABlMIsDZ23d1koY5nsteM9XpNmqZRZ1nGZrPhdDp9kqG22AvnQLfIc7w2eKkxxzzahJRVVv+mHAClBuNIFy/0O10wNr7t0zW/ej3anQ7T6ZR+v39XywgYZi9ECic06JALzqcSbS6UnatmyoU5tO5dM+4yDHVoNpu02x1GwyG98SSOTXBJZnOems+UxqEc2EK8dTkAej7u8jVlFz86cmWwl4/O2sgg3JQHmYvg8J+bcgXxPm5CKEEpRBz8sL9BhwBfyYdNCXVcLBYMBoO4Cd1utzphNG6DPwL+BV0HP8g0UreAAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;4 way handshake&quot;
        title=&quot;&quot;
        src=&quot;/static/fd525edf82b680152ac8096c5f60054d/984b6/4_way_handshake.png&quot;
        srcset=&quot;/static/fd525edf82b680152ac8096c5f60054d/4d6f2/4_way_handshake.png 158w,
/static/fd525edf82b680152ac8096c5f60054d/3c1ae/4_way_handshake.png 315w,
/static/fd525edf82b680152ac8096c5f60054d/984b6/4_way_handshake.png 630w,
/static/fd525edf82b680152ac8096c5f60054d/e7d8e/4_way_handshake.png 945w,
/static/fd525edf82b680152ac8096c5f60054d/58c38/4_way_handshake.png 1260w,
/static/fd525edf82b680152ac8096c5f60054d/9bae8/4_way_handshake.png 1330w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. WAS(Web Application Server)와 데이터베이스에서 웹페이지 작업을 처리합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;웹 서버 혼자서 모든 로직 처리 및 데이터 관리를 하게 되면 서버에 과부하가 일어날 가능성이 높습니다.
그렇기에 서버의 일을 돕는 조력자 역할을 하는 것이 WAS입니다.&lt;/p&gt;
&lt;p&gt;WAS는 사용자의 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어 입니다.
특정 데이터 요청을 브라우저로부터 받게되면, 웹 서버는 페이지의 로직이나 데이터베이스의 연동을 위해 WAS에게 이들의 처리를 요청합니다.
WAS는 해당 요청을 통해 동적인 페이지 처리를 담당하고, DB에서 필요한 데이터 정보를 받아 그에 맞는 파일을 생성합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;웹 서버: 정적인 파일(HTML, CSS, 이미지 파일)을 처리&lt;br/&gt;
WAS: 동적인 파일(JS, TS)을 처리&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/614a67a8777228673abcc87e90d8c5d4/a1f70/was.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 41.139240506329116%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABcSAAAXEgFnn9JSAAABzElEQVR42mPQ3Xo7JXzzuebXm5ZqZLuoS+X76yv8P8PA6r30jvHG49dO7zh2/sHOExfvbDt64f72Exevp25968nAwMDw/z8DIwM2YL/12oy6Dfs+n9i6MWemCwN/fZSJ0kt7Bp7MLc+MT5w8/e7w/j3/jx05/PfQ/n3/Tx8/8nP6ua/+EAP/Yzdw24kTfBuOHOEFsbW0GNj4ZPiEQGzZmS+Vz9y8X3z/7u3mG1fOdV2+erXt/v37Ff7rvxgwMOAwDAaQbGNj4OcXBLOmfpNlWPWfDeS1Nx1mMqGhocxg8Zn/5Rhm/meF6d2/fz8LMgYbhmIgH8SFcAMZGJi/dNlLwNWgGUgIsMJcKDf3u9LJy3dqrly50n/7xrWJ127c6rl+82aj3+pnJgwM9SxQ9YynTpxIu3r16pJr164tPn78eAW6gWy8vFLCIIbv6s/ab968ef/qycP/e3du//v4/p3/3z6++z5jz9WY+fHyEv8Xmgrfmpmm/P79uxsPHz78f+PGjb/Pnz//j+FCfn55ARBDd8ln3W3nH9zad/7mhw1HLr7edebGu70X7z3L2XI/6FghA+f/Ra7c3TGWYtevX1928uTJ+0ePHr116dKlQwDNV/gUUAH+/AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;WAS&quot;
        title=&quot;&quot;
        src=&quot;/static/614a67a8777228673abcc87e90d8c5d4/984b6/was.png&quot;
        srcset=&quot;/static/614a67a8777228673abcc87e90d8c5d4/4d6f2/was.png 158w,
/static/614a67a8777228673abcc87e90d8c5d4/3c1ae/was.png 315w,
/static/614a67a8777228673abcc87e90d8c5d4/984b6/was.png 630w,
/static/614a67a8777228673abcc87e90d8c5d4/a1f70/was.png 683w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. WAS에서의 작업 처리 결과들을 웹 서버로 전송하고, 웹 서버는 웹 브라우저에게 html 문서 결과를 전달합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;전달 과정에서 status code를 통해 서버 요청에 따른 결과 및 상태를 전달합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1xx: 정보가 담긴 메세지&lt;/li&gt;
&lt;li&gt;2xx: response 성공&lt;/li&gt;
&lt;li&gt;3xx: 클라이언트를 다른 URL로 리다이렉트&lt;/li&gt;
&lt;li&gt;4xx: 클라이언트 측에서 에러 발생&lt;/li&gt;
&lt;li&gt;5xx: 서버 측에서 에러 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a7c83480e2c53589208dbed10e66f486/9a6db/http_status_code.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 69.62025316455697%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQADBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtJpDNX//EABoQAAICAwAAAAAAAAAAAAAAAAECABADESH/2gAIAQEAAQUCfk1WRSwr/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgEFAAAAAAAAAAAAAAAAARARADFBkcH/2gAIAQEABj8CntXO0IOX/8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECFBUf/aAAgBAQABPyH0O2uIcwBRUFAKDuBS4//aAAwDAQACAAMAAAAQzA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQADAAAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QhX//xAAaEAEBAAMBAQAAAAAAAAAAAAABEQAxQRAh/9oACAEBAAE/EEE+gIoFyl0ne2SKWdWuO8XYWhzHVSL5/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;http status code&quot;
        title=&quot;&quot;
        src=&quot;/static/a7c83480e2c53589208dbed10e66f486/af1fa/http_status_code.jpg&quot;
        srcset=&quot;/static/a7c83480e2c53589208dbed10e66f486/ab180/http_status_code.jpg 158w,
/static/a7c83480e2c53589208dbed10e66f486/ba98e/http_status_code.jpg 315w,
/static/a7c83480e2c53589208dbed10e66f486/af1fa/http_status_code.jpg 630w,
/static/a7c83480e2c53589208dbed10e66f486/9a6db/http_status_code.jpg 920w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;브라우저 렌더링 과정&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;6. Critical Rendering Path를 통해 웹 브라우저 화면에 웹 페이지 내용을 출력합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;웹 브라우저에 출력되는 단계를 Critical Rendering Path라고 하며 크게 6단계로 분류됩니다.&lt;br/&gt;
성능을 최적화하려면 수신받은 HTML, CSS, JS 파일들을 어떤 단계를 거치는지 파악한 후, 해당 과정들을 최소화하는 것이 매우 중요합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d0b38b9a6f625d4961b970dfaee36635/c13bc/critical_render_path.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZUlEQVR42nXQUWuCUAAFYP9qIfgjCpQwerlQRvjkc0H9hEju9hBhWNFmW/Zod6WWaBZe9V7vNmMbjO17PgcOh2OloigYY3me73Y727bt7RYhZFnW89PT68uLvd1uNps4jr+Td1xRFBhjQghjjFLqeV4YhlEYXqIIIbR3HLTfu66LEIrjOMsyXMqy7LNMCEmSxHEcCOHD4+PpdFqv15PJxDRNQkie58UXUqKUEkIwxp/lNE2v1yuEsFqt8jy/WCy63W6lUpFlOU3T8/l8z/2JE0VRUZQoiuLS5XJRVbVerwMATNPUNE1RlNVqNRgMarXaaDSaz+eiKLZaLd/3OUmSOp3O8Xh8K7muq2lao9Ho9Xqz2azdbjebTcMw+v2+JEnD4XA6ncqyDADwPI/DGAdBoOs6z/OCIBiGoaqqIAgAgCRJfN+/3W6/Tv6ZTSlljB0OB13XIYRBEFiWNR6Pl8vl/ZviHx/ld2/glTLn71srAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;critical render path&quot;
        title=&quot;&quot;
        src=&quot;/static/d0b38b9a6f625d4961b970dfaee36635/984b6/critical_render_path.png&quot;
        srcset=&quot;/static/d0b38b9a6f625d4961b970dfaee36635/4d6f2/critical_render_path.png 158w,
/static/d0b38b9a6f625d4961b970dfaee36635/3c1ae/critical_render_path.png 315w,
/static/d0b38b9a6f625d4961b970dfaee36635/984b6/critical_render_path.png 630w,
/static/d0b38b9a6f625d4961b970dfaee36635/c13bc/critical_render_path.png 939w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 후 과정은 &lt;a href=&quot;../web-perform-optimization/&quot;&gt;여기&lt;/a&gt;에서 자세히 정리해 놓았으니 참고 부탁드립니당ㅎㅎ&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;프론트엔드 개발 공부를 하면서도 제가 짜는 코드가 어떻게 화면에 구현되는지 모른채 얼레벌레 코드를 짜고 있었다는 것을 알게된 시간이었습니다😅&lt;br/&gt;
공부를 하면서 이런 동작 원리 하나하나가 코드를 짜는 데 중요하다는 것을 알게 되었습니다!&lt;br/&gt;
혹시나 틀린 내용이 있다면 언제든 피드백 부탁드립니다! 🙆‍♀️&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;참고&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@tnehd1998/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-www.google.com%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84-%EB%95%8C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95&quot;&gt;https://velog.io/@tnehd1998/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-www.google.com%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84-%EB%95%8C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@jhyun_k/%EB%82%B4-%ED%99%94%EB%A9%B4%EC%97%90-%EB%84%A4%EC%9D%B4%EB%B2%84%EA%B0%80-%EC%BC%9C%EC%A7%80%EB%8A%94-%EA%B3%BC%EC%A0%95&quot;&gt;https://velog.io/@jhyun_k/%EB%82%B4-%ED%99%94%EB%A9%B4%EC%97%90-%EB%84%A4%EC%9D%B4%EB%B2%84%EA%B0%80-%EC%BC%9C%EC%A7%80%EB%8A%94-%EA%B3%BC%EC%A0%95&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@thyoondev/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90&quot;&gt;https://velog.io/@thyoondev/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codechasseur.tistory.com/25&quot;&gt;https://codechasseur.tistory.com/25&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[프론트엔드 면접 준비 노트 (JavaScript)]]></title><description><![CDATA[Reference: 지금까지 받았던 신입 프론트엔드 면접 질문들 by arthur 개인 스터디 글로, 맞지 않는 내용이 있다면 피드백은 대 환영입니다 👼✨ 자바스크립트는 무슨 언어인가요? 자바스크립트는 HTML, CSS…]]></description><link>https://kirahaa.github.io/fe-interview-js/</link><guid isPermaLink="false">https://kirahaa.github.io/fe-interview-js/</guid><pubDate>Tue, 01 Aug 2023 22:12:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Reference: &lt;a href=&quot;https://velog.io/@arthur/%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80-%EB%B0%9B%EC%95%98%EB%8D%98-%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8%EB%93%A4#%EC%82%AC%EC%84%A4&quot;&gt;지금까지 받았던 신입 프론트엔드 면접 질문들 by arthur&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;개인 스터디 글로, 맞지 않는 내용이 있다면 피드백은 대 환영입니다 👼✨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;자바스크립트는 무슨 언어인가요?&lt;/h3&gt;
&lt;p&gt;자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다.&lt;br/&gt;
자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어입니다. 또한, 자바스크립트는 동적 타입 언어로, 런타임 시 타입을 결정하는 특징이 있습니다.&lt;/p&gt;
&lt;h3&gt;변수 선언, 초기화, 할당의 차이점에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;변수는 &lt;strong&gt;선언 =&gt; 초기화 =&gt; 할당&lt;/strong&gt; 단계를 거칩니다.&lt;/p&gt;
&lt;p&gt;변수 선언은 변수를 생성하는 것을 의미합니다. 변수명(식별자)을 등록하여 스코프가 참조할 대상을 만듭니다.&lt;br/&gt;
초기화는 메모리에 변수 저장을 위한 공간을 확보하는 단계입니다. 기본값으로 &lt;strong&gt;undefined&lt;/strong&gt;가 할당됩니다.&lt;br/&gt;
할당은 &lt;strong&gt;=&lt;/strong&gt; 연산자를 사용하여 값을 할당하는 단계로, &lt;strong&gt;undefined&lt;/strong&gt;로 초기화된 변수에 실제 값을 할당해주는 단계입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var name;  // 변수 선언
var name;  // 변수 선언 =&amp;gt; 초기화
console.log(name);  // undefined

name = &amp;#39;hayeong&amp;#39;;  // 변수 할당
console.log(name);  // hayeong&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;데이터 타입에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;Javascript의 타입은 &lt;strong&gt;원시 타입&lt;/strong&gt;과 &lt;strong&gt;객체 타입&lt;/strong&gt;으로 나뉩니다.&lt;/p&gt;
&lt;p&gt;원시 타입은 불변값이라고도 부르며, &lt;strong&gt;string&lt;/strong&gt;, &lt;strong&gt;number&lt;/strong&gt;, &lt;strong&gt;boolean&lt;/strong&gt;, &lt;strong&gt;undefined&lt;/strong&gt;, &lt;strong&gt;null&lt;/strong&gt;, &lt;strong&gt;symbol&lt;/strong&gt; 총 6가지 데이터 타입이 있습니다.&lt;br/&gt;
객체는 원시 타입을 제외한 나머지 값들(배열, 함수, 정규표현식 등) 모두 객체에 해당되며, 참조형 타입이라고도 부릅니다.&lt;/p&gt;
&lt;h3&gt;Symbol(심벌) 타입은 뭐죠?&lt;/h3&gt;
&lt;p&gt;Symbol 타입은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값입니다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값입니다.
따라서 주로 이름이 충동할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 위, 아래, 왼쪽, 오른쪽을 나타내는 상수를 정의합니다.
// 중복될 가능성이 없는 심벌 값으로 상수 값을 생성합니다.
const Direction = {
  UP: Symbol(&amp;quot;up&amp;quot;),
  DOWN: Symbol(&amp;quot;down&amp;quot;),
  LEFT: Symbol(&amp;quot;left&amp;quot;),
  RIGHT: Symbol(&amp;quot;right&amp;quot;)
}

const myDirection = Direction.UP;

if (myDirection === Direction.UP) {
  console.log(&amp;quot;You are going UP.&amp;quot;);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;정적 타이핑이 뭔가요?&lt;/h3&gt;
&lt;p&gt;C나 자바 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 합니다.
이를 &lt;strong&gt;명시적 타입 선언&lt;/strong&gt;이라고 합니다. 다음은 C에서 정수 타입의 변수를 선언하는 예입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// c 변수에는 1바이트 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.
char c;

// num 변수에는 4바이트 정수 타입의 값(-2,124,483,648 ~ 2,124,483,647)만을 할당할 수 있다.
int num;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;동적 타이핑이 뭔가요?&lt;/h3&gt;
&lt;p&gt;자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않습니다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var foo;
console.log(typeof foo);  // undefined

foo = 3;
console.log(typeof foo);  // number

foo = null;
console.log(typeof foo);  // object

foo = Symbol();
console.log(typeof foo);  // symbol

foo = {};
console.log(typeof foo);  // object

foo = [];
console.log(typeof foo);  // object

foo = function () {}; 
console.log(typeof foo);  // function&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론) 됩니다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있습니다.
이러한 특징을 동적 타이핑이라고 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라고 합니다. 대표적인 동적 타입 언어로는 자바스크립트, 파이썬, PHP 등이 있습니다.&lt;/p&gt;
&lt;h3&gt;생성자에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;생성자 함수란 &lt;strong&gt;new&lt;/strong&gt; 연산자와 함께 호출하여 객체를 생성하는 함수를 의미합니다.&lt;br/&gt;
생성자 함수에 의해 생성된 객체를 인스턴스라하며, 자바스크립트는 &lt;strong&gt;Object&lt;/strong&gt; 외에도 다양한 타입의 빌트인 생성자 함수를 제공합니다.&lt;br/&gt;
생성자 함수는 일반 함수와 동일한 방법으로 정의하지만, 파스칼 케이스를 사용하는 관례를 따릅니다.&lt;/p&gt;
&lt;h3&gt;this에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt; 키워드는 자신이 속한 객체를 가리키는 식별자를 참조할 수 있는 키워드입니다.&lt;br/&gt;
&lt;strong&gt;this&lt;/strong&gt;는 함수가 호출되는 방식에 따라 달라집니다.&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반 함수 호출을 사용할 경우 기본적으로 전역 객체가 바인딩됩니다.&lt;/li&gt;
&lt;li&gt;메서드 호출을 할 경우, 마침표 연산자 앞에 기술한 객체가 바인딩됩니다.&lt;/li&gt;
&lt;li&gt;생성자 함수 호출을 할 경우, 미래에 생성할 인스턴스가 바인딩됩니다.&lt;/li&gt;
&lt;li&gt;화살표 함수는 &lt;strong&gt;this&lt;/strong&gt;가 없기 때문에, 선언될 시점에서의 상위 스코프가 바인딩됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;call, apply, bind에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;이 세가지 메서드는 강제로 &lt;strong&gt;this&lt;/strong&gt;를 바꿀 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;call&lt;/strong&gt;은 커스텀 this를 지정할 수 있고, &lt;strong&gt;apply&lt;/strong&gt;는 call과 유사하지만 인자로 배열을 받는다는 점에서 차이가 있습니다.&lt;br/&gt;
&lt;strong&gt;bind&lt;/strong&gt;는 커스텀 this를 영구히 가지는 함수를 만들 수 있습니다.&lt;/p&gt;
&lt;h3&gt;콜백 함수에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;콜백 함수는 다른 함수의 인자로 넘겨지는 함수를 말합니다.&lt;br/&gt;
콜백 함수는 일반적으로 비동기적인 상황에서 사용되며, 어떤 작업이 완료되거나 특정 이벤트가 발생했을 때 호출됩니다.&lt;/p&gt;
&lt;h4&gt;콜백 지옥을 해결하는 방법을 설명해주세요.&lt;/h4&gt;
&lt;p&gt;콜백 지옥은 비동기 처리 로직을 위해 콜백 함수를 연속으로 중첩하여 사용할 때 발생하는 문제입니다.&lt;br/&gt;
콜백 지옥을 해결하는 방법에는 &lt;strong&gt;Promise&lt;/strong&gt;나 &lt;strong&gt;Async&lt;/strong&gt;가 있습니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;는 비동기 연산이 종료된 이후에 결과를 알기 위해 사용하는 객체입니다.&lt;br/&gt;
&lt;strong&gt;Promise&lt;/strong&gt;의 &lt;strong&gt;.then&lt;/strong&gt;을 사용해 함수 실행 순서를 정할 수 있습니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;ES8에서 도입된 &lt;strong&gt;async&lt;/strong&gt;, &lt;strong&gt;await&lt;/strong&gt;을 사용하면 비동기 함수를 마치 동기적 코드인 것처럼 동작하도록 구현이 가능합니다.&lt;br/&gt;
&lt;strong&gt;async&lt;/strong&gt;함수는 &lt;strong&gt;async&lt;/strong&gt; 함수 안에서만 동작하며, &lt;strong&gt;await&lt;/strong&gt; 키워드를 쓰게 되면 해당 값이 반환 되기 전까지 기다리는 동안 &lt;strong&gt;async&lt;/strong&gt; 내부 함수는 일시 중단이 됩니다.&lt;/p&gt;
&lt;h3&gt;Promise에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;는 비동기 처리를 간편하게 처리할 수 있도록 도와주는 객체로, 성공 또는 실패 상태를 가집니다.&lt;br/&gt;
비동기 작업이 완료되면 &lt;strong&gt;resolve(성공)&lt;/strong&gt; 또는 &lt;strong&gt;reject(실패)&lt;/strong&gt; 로 결과를 처리할 수 있습니다. 이렇게 처리된 결과는 &lt;strong&gt;then&lt;/strong&gt;과 &lt;strong&gt;catch&lt;/strong&gt; 메서드를 이용하여 다음 동작을 연결할 수 있습니다.
이를 통해 비동기 코드를 더 구조적이고 유지보수하기 좋게 작성할 수 있으며, 에러 처리 등을 통해 안정적인 프로그래밍을 할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;Promise.all()에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;Promise.all()은 자바스크립트의 Promise 메서드로, 여러 개의 Promise 객체를 받아 모든 Promise가 완료될 때까지 기다린 뒤, 그 결과들을 배열로 반환합니다.&lt;br/&gt;
모든 Promise가 성공적으로 처리되면 배열에는 각 Promise의 성공 결과 값이 순서대로 들어가며, 하나라도 실패하면 첫 번째 실패한 Promise의 에러를 반환합니다.&lt;/p&gt;
&lt;h3&gt;Promise와 Callback을 비교 설명해주세요.&lt;/h3&gt;
&lt;p&gt;Callback은 비동기 작업 완료 후 실행되는 함수로, 가독성과 유지보수에 어려움이 있을 수 있습니다.&lt;br/&gt;
Promise는 ES6에서 도입된 비동기 처리 객체로, 콜백 지옥을 피하고 더 편리한 비동기 작업을 가능하게 해줍니다.&lt;br/&gt;
성공 또는 실패 시 다른 처리를 할 수 있고, 여러 개의 비동기 작업을 체이닝하여 순차적 또는 병렬로 실행할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;Promise와 Async, Await의 차이를 설명해주세요.&lt;/h3&gt;
&lt;p&gt;Promise는 비동기 작업을 처리하는 객체로, then과 catch를 사용하여 결과를 다룹니다.&lt;br/&gt;
Async/Await은 Promise를 더 간결하고 직관적으로 사용하기 위한 문법으로, async 함수와 await 키워드를 사용합니다.&lt;br/&gt;
비동기 작업의 결과를 변수에 할당하거나 다른 함수에서 사용하기 용이하며, try-catch 문으로 예외 처리를 간편하게 할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;AJAX에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;AJAX는 웹 페이지에서 비동기적으로 서버와 데이터를 주고받는 기술로, 페이지 새로고침 없이 동적으로 내용을 갱신하거나 데이터를 로드할 수 있게 해주는 기술입니다.
Javascript를 사용하여 비동기 통신을 수행하며, 사용자 경험을 향상시키고 웹 페이지의 속도와 효율성을 개선합니다.&lt;/p&gt;
&lt;h3&gt;var, let, const 차이를 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;var&lt;/strong&gt;는 함수 스코프를 가집니다. 변수를 중복 선언해도 오류가 발생하지 않고, 똑같은 이름으로 여러번 선언되면 마지막 선언이 유효합니다.
호이스팅 현상이 발생하여 변수가 선언되기 전에도 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;let&lt;/strong&gt;과 &lt;strong&gt;const&lt;/strong&gt;는 중복 선언이 불가능 하며, 블록 스코프를 가집니다. &lt;br/&gt;
&lt;strong&gt;let&lt;/strong&gt;은 값이 변경될 수 있는 변수를 선언할 때 사용하고, &lt;strong&gt;const&lt;/strong&gt;는 값이 변경되지 않을 변수를 선언할 때 사용합니다.&lt;/p&gt;
&lt;p&gt;일반적으로 let과 const를 사용하여 변수를 선언하고, var는 최신 버전의 Javascript에서는 피하는 것이 좋습니다.&lt;/p&gt;
&lt;h4&gt;TDZ에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;TDZ(Temporal Dead Zone)의 약어로, 변수가 선언되었지만 해당 변수를 사용할 수 없는 현상을 가리킵니다.
TDZ는 변수가 선언되고 초기화되기 전까지의 영역을 의미하는데, ES6의 let과 const는 변수를 블록의 상단으로 호이스팅하지만 초기화하지는 않기 때문에 이런 현상이 발생합니다.&lt;/p&gt;
&lt;h3&gt;함수 선언문과 함수 표현식의 차이에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;함수 선언문은 &lt;code&gt;function add(x, y){}&lt;/code&gt;의 형태로 쓰여지며, 완료시 undefined가 출력됩니다. 이때, 이름을 생략할 수 없습니다.&lt;/p&gt;
&lt;p&gt;함수 표현식은 &lt;code&gt;const add = function(x, y) {}&lt;/code&gt;의 형태로 쓸 수 있으며, 함수 리터럴의 함수 이름을 생략할 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생하기 때문에 표현식 이전에 호출할 수 없지만, 함수 선언문으로 정의하면 함수 선언문 이전에 호출할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;이벤트 버블링과 캡처링에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;이벤트 버블링과 이벤트 캡처링은 브라우저에서 이벤트가 발생했을 때 이벤트가 어떻게 전달되는지를 설명하는 개념입니다.&lt;/p&gt;
&lt;p&gt;이벤트 버블링은 자식 요소에 등록된 이벤트 핸들러가 먼저 실행된 후 부모 요소의 핸들러가 실행하는 것을 말합니다. 가장 일반적으로 사용됩니다.&lt;/p&gt;
&lt;p&gt;이벤트 캡쳐링은 이벤트가 발생한 부모 요소의 핸들러가 먼저 실행된 후 자식 요소에 등록된 핸들러가 실행됩니다.&lt;/p&gt;
&lt;p&gt;이벤트 버블링과 캡쳐링은 이벤트의 전파 방향이 다르므로 이를 이용하여 이벤트를 효율적으로 처리할 수 있습니다. 만약 이벤트 전파를 중단하고 싶다면, &lt;code&gt;event.stopPropagation()&lt;/code&gt; 메서드를 사용하면 됩니다.&lt;/p&gt;
&lt;h4&gt;이벤트 위임에 대해서 설명해주세요.&lt;/h4&gt;
&lt;p&gt;이벤트 위임은 상위 요소에 하나의 이벤트 핸들러를 등록하여 하위 요소들의 이벤트를 한 번에 처리하는 기술입니다.
많은 수의 하위 요소에 각각 이벤트 핸들러를 등록하는 것보다 메모리 사용을 줄이고 코드를 간결하게 만들어줍니다.
상위 요소에서 이벤트가 발생하면 이벤트가 해당 요소의 하위 요소들까지 전파되어 처리됩니다.
이를 통해 동적으로 생성된 하위 요소들에 대해서도 하나의 핸들러로 처리할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;이벤트 위임의 동작 방식에 대해서 설명해주세요.&lt;/h4&gt;
&lt;p&gt;우선 상위 요소에 이벤트 핸들러를 등록합니다. 하위 요소에서 이벤트가 발생하면 이벤트는 먼저 해당 요소에서 시작하여 상위 요소로 전파됩니다.
이벤트가 상위 요소까지 전파되면 상위 요소에 등록된 이벤트 핸들러가 이벤트를 캐치하여 처리합니다. 이때 &lt;strong&gt;event.target&lt;/strong&gt; 속성을 사용하여 이벤트가 발생한 실제 요소를 식별할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;호이스팅과 발생하는 이유에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;js 엔진은 변수 선언(을 포함한 모든 선언문)이 소스 코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행합니다.
런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되고 이를 마치 코드의 제일 위에 있는 것처럼 변수가 어디에 위치하던지와 상관없이 어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅이라고 합니다.&lt;/p&gt;
&lt;p&gt;사실 변수 선언뿐 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 됩니다.
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문입니다.&lt;/p&gt;
&lt;h3&gt;스코프(Scope)에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;스코프는 변수와 함수에 접근할 수 있는 유효한 영역을 나타냅니다. 즉, 변수와 함수가 어디에서 정의되고 어디에서 참조될 수 있는지를 결정하는 규칙입니다.&lt;br/&gt;
Javascript에는 전역 스코프와 지역 스코프가 있습니다. 변수와 함수가 스코프에 따라 유효한 영역이 결정되므로, 스코프의 관리는 변수의 생명주기와 충돌을 방지하는 데 중요한 역할을 합니다.&lt;/p&gt;
&lt;h3&gt;클로저(Closure)에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;클로저(Closure)는 자신이 선언되었을 때의 환경(렉시컬 환경)인 스코프를 기억하는 함수입니다.
해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 렉시컬 환경에 남아 참조가 가능합니다.&lt;/p&gt;
&lt;p&gt;클로저는 다음 예시에서 처럼 내부에 선언된 함수가 외부 함수의 지역변수를 사용해줬을 때만 클로저라고 선언됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function outer() {
  let name = &amp;quot;hayeong&amp;quot;;
  if (true) {
    let city = &amp;quot;seoul&amp;quot;;
    console.log(city);
    console.log(name);
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const btn = document.querySelector(&amp;#39;button&amp;#39;)

btn.addEventListener(&amp;#39;click&amp;#39;, handleClick())

function handleClick() {
  let count = 0;
  return function() {
    count++
    return count
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;클로저를 사용하면 뭐가 좋죠?&lt;/h3&gt;
&lt;p&gt;클로저는 &lt;strong&gt;상태(state)를 안전하게 변경하고 유지하기위해 사용&lt;/strong&gt;합니다.
다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태변경을 허용하기 위해 사용합니다.&lt;/p&gt;
&lt;h3&gt;실행 컨텍스트에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 말합니다. 자바스크립트 엔진이 코드를 실행할 때, 실행 컨텍스트를 생성하여 코드를 평가하고 실행합니다.
실행 컨텍스트는 코드 실행에 필요한 여러 정보들을 담고 있으며, 함수 실행, 변수 및 함수 선언, 스코프 체인 등을 관리하는데 사용됩니다.&lt;/p&gt;
&lt;h4&gt;렉시컬 환경(Lexical Environment)에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;렉시컬 환경은 자바스크립트의 변수와 함수의 이름을 관리하는 공간이라고 생각하면 됩니다.
렉시컬 환경은 &lt;strong&gt;환경 레코드&lt;/strong&gt;와 &lt;strong&gt;외부 렉시컬 환경&lt;/strong&gt;으로 구성되어 있습니다.&lt;/p&gt;
&lt;p&gt;환경 레코드는 모든 지역변수를 프로퍼티로 저장하고 있는 객체입니다. this, 함수일 경우 매개변수도 포함됩니다.
외부 렉시컬 환경은 현재 렉시컬 환경보다 더 상위의 렉시컬 환경입니다.
현재 렉시컬 환경에서 원하는 변수를 찾지 못하면 현재 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 검색 범위를 확장하며, 이는 전역 렉시컬 환경까지 반복됩니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트에서 일어나는 데이터 형변환에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환되며, 이를 형 변환이라고 합니다.&lt;/p&gt;
&lt;p&gt;이는 원시값이 아닌 객체간에도 동작하는데, &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;를 사용하면 객체를 모든 종류로 형변환할 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 &lt;code&gt;toString()&lt;/code&gt;이나 &lt;code&gt;valueof()&lt;/code&gt;를 사용해서도 객체를 정해진 몇몇 타입으로 변환할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트가 동적 언어인 이유는 무엇인가요?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;여기서 동적 언어란 실행 중에 변수의 데이터 타입을 명시적으로 선언하지 않고도 변수의 타입이 자동으로 결정되며, 변수의 타입이 실행 도중에도 동적으로 변경될 수 있는 언어를 말합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자바스크립트는 &lt;strong&gt;런타임 시 변수의 타입이 결정&lt;/strong&gt;됩니다.&lt;/p&gt;
&lt;p&gt;즉, 소스가 빌드될 때 자료형이 결정되는 것이 아닌 실행 시 결정됩니다. 이를 통해 런타임까지 타입에 대한 결정을 끌고 갈 수 있지만,
실행 도중 변수에 예상치 못한 타입이 들어와 TypeError가 발생할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;프로토타입에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;자바스크립트의 모든 객체들은 메서드와 속성들을 상속받기 위한 템플릿으로써 프로토타입 객체를 갖습니다.
정확히 말하자면 상속되는 속성과 메서드들은 각 객체가 아니라 객체의 생성자의 &lt;strong&gt;prototype&lt;/strong&gt;이라는 속성에 정의되어 있습니다.
자바스크립트에서는 객체 인스턴스와 프로토타입간에 연결이 구성되며, 이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메서드를 탐색합니다.&lt;/p&gt;
&lt;h3&gt;깊은 복사와 얕은 복사에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;깊은 복사와 얕은 복사는 자바스크립트에서 객체를 복사할 때 발생하는 두 가지 다른 복사 방법을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;깊은 복사&lt;/strong&gt;는 원본 객체의 내용을 완전히 새로운 객체에 복사하는 것을 말합니다.
원본 객체와 복사된 객체가 완전히 분리되어 있어, 한쪽을 수정해도 다른 쪽에 영향을 주지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;얕은 복사&lt;/strong&gt;는 원본객체의 참조를 복사하는 것을 의미합니다. 원본 객체와 복사된 객체가 같은 객체를 참조하게 될 수 있으므로 한쪽을 수정하면
다른 쪽에도 영향을 줄 수 있습니다.&lt;/p&gt;
&lt;h3&gt;불변성을 유지하려면 어떻게 해야하나요?&lt;/h3&gt;
&lt;p&gt;불변성을 유지하기 위해서는 기존의 데이터를 변경하지 않고 새로운 데이터를 생성하고 조작해야 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spread 문법 사용: Spread 문법(...)을 활용하여 배열이나 객체를 새로운 배열이나 객체로 복사하고 수정합니다.&lt;/li&gt;
&lt;li&gt;Object.assign() 사용: &lt;code&gt;Object.assign()&lt;/code&gt; 함수를 사용하여 객체를 복사하고 수정합니다.&lt;/li&gt;
&lt;li&gt;JSON.parse(JSON.stringify(obj)) 사용: JSON.stringify는 객체를 json 문자열로 변환하는데, 이 과정에서 원본 객체와의 참조가 모두 끊어지기 때문에 깊은 복사가 가능해집니다. 이후 JSON.parse()를 통해 다시 자바스크립트 객체로 만들어주면 복사가 완료됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Blocking과 Non-Blocking에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Blocking&lt;/strong&gt; : 블로킹은 어떤 작업이 실행 중일 때, 다른 작업이 대기해야 하는 상황을 의미합니다. 즉, 하나의 작업이 끝날 때까지 다른 작업들은 대기해야 합니다.
일반적으로 동기적인 코드 실행 방식에서 블로킹이 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-Blocking&lt;/strong&gt; : 논블로킹은 어떤 작업이 실행 중일 때, 다른 작업들이 기다리지 않고 독립적으로 실행될 수 있는 상황을 의미합니다.
다른 작업들이 블로킹되지 않고 계속 진행될 수 있기 때문에 시스템의 응답성과 처리량이 향상될 수 있습니다. 일반적으로 비동기적인 코드 실행 방식에서 논블로킹이 나타납니다.&lt;/p&gt;
&lt;h3&gt;동기와 비동기에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;동기 작업&lt;/strong&gt;은 순차적으로 실행되며, 하나의 작업이 끝날 때까지 다음 작업이 실행되지 않습니다.
&lt;strong&gt;비동기 작업&lt;/strong&gt;은 작업이 완료되지 않아도 다음 작업을 실행하며, 작업의 완료는 콜백 함수나 프로미스 등을 통해 처리합니다.
여러 작업들이 동시에 실행될 수 있어 응답성이 향상되고 복잡한 작업을 처리할 때 유용합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트에서는 비동기적이고 논블로킹된 코드를 사용하여 여러 작업을 효율적으로 처리하고, 응답성을 향상시키는 것이 중요합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;블로킹 vs 논 블로킹&quot;과 &quot;동기 vs 비동기&quot;의 차이점은?&lt;/p&gt;
&lt;p&gt;비동기와 동기는 간단하게 &apos;&lt;strong&gt;코드의 순서랑 실행 순서가 일치하느냐&lt;/strong&gt;&apos;로 볼 수 있습니다.
블로킹과 논블로킹은 &apos;&lt;strong&gt;코드의 실행이 다른 코드의 실행을 막느냐&lt;/strong&gt;&apos;로 볼 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;ES6에서 새로 생긴 기능을 아는대로 말씀해주세요.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;블록 스코프, let, const&lt;/li&gt;
&lt;li&gt;클래스&lt;/li&gt;
&lt;li&gt;모듈&lt;/li&gt;
&lt;li&gt;화살표 함수&lt;/li&gt;
&lt;li&gt;매개변수 기본값&lt;/li&gt;
&lt;li&gt;템플릿 리터럴&lt;/li&gt;
&lt;li&gt;구조분해 할당(디스트럭처링)&lt;/li&gt;
&lt;li&gt;스프레드 연산자&lt;/li&gt;
&lt;li&gt;프로미스&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;undefined, null, undeclared를 비교해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;undefined&lt;/strong&gt;는 값이 할당되지 않았음을 의미합니다. 변수가 초기화 단계를 거치면 &lt;strong&gt;undefined&lt;/strong&gt;로 남아있게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;undeclared&lt;/strong&gt;는 변수 선언조차 되어있지 않은 상태를 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null&lt;/strong&gt;은 의도적으로 &lt;strong&gt;null&lt;/strong&gt;이라는 빈 값을 할당한 경우를 의미합니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트를 멀티 스레드처럼 사용하는 방법이 뭔가요? / 자바스크립트에서 비동기 로직이 어떻게 동작하는지 설명해주세요. (이벤트 루프)&lt;/h3&gt;
&lt;p&gt;Web API, Callback Queue, Event Loop 등을 통해 멀티 스레드처럼 보이게 하는 방법을 사용합니다.&lt;/p&gt;
&lt;p&gt;자바스크립트는 싱글 스레드로 동작하며, 모든 작업이 하나의 메인 스레드에서 처리됩니다. 그러나 네트워크 요청, 파일 입출력, 타이머와 같은 작업은 시간이 걸리는 경우가 많습니다.
이를 위해 비동기 로직이 필요한데, 이를 통해 시간이 걸리는 작업을 백그라운드에서 처리하고, 동시에 다른 작업을 수행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;자바스크립트 엔진 내부에는 콜스택과 메모리힙이 잇고 그 외부에 브라우저일때 사용하는 webapi와 이벤트 루프, 콜백 큐가 추가되어 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;코드가 콜스택에 쌓이고 실행되면, 자바스크립트의 엔진은 비동기 작업을 webapi에 위임합니다.&lt;/li&gt;
&lt;li&gt;webapi는 해당 작업을 수행하고 콜백 함수를 이벤트 루프를 통해 태스크 큐에게 넘겨줍니다.&lt;/li&gt;
&lt;li&gt;이벤트 루프는 콜스택에 쌓인 함수가 없을 때, 태스크 큐에 대기하던 콜백 함수를 콜스택으로 넘겨줍니다.&lt;/li&gt;
&lt;li&gt;콜스택에 쌓인 콜백함수를 실행하고 콜스택에서 제거합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;만약 promise를 사용한다면, 마이크로태스크 큐를 사용합니다. 마이크로 태스크 큐는 태스크 큐보다 우선순위가 높은 큐로, 태스크 큐에 대기중인 함수가 있더라도,
마이크로 태스크 큐가 비어있지 않다면, 마이크로 태스크 큐에 대기중인 함수부터 콜스택으로 전달합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9060ff03638b21ebada26e9d108f9854/3e3fe/async.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 66.45569620253164%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC0UlEQVR42l2S347bVBDG8xo8QivEBRdVr5CoxJ9KRSpFRUgsV0hQCQlueYrecAPXPACttIu6JdnuJtk0yTaCpYm79rETO7bj/Fk5ceLYJ+vYPxTvkhZG+o7mjOZ8Z2a+KSTmr8TlD5HPP0fWPrvCPeTxp7m/evE1q9Y3rFoPkI0dZO3u65w385/fJ4tcCon2kGj3LeKn7xDvX2NVusFF5Tby6ANk6Sby2XvI6ifI47vIyh3k4S3iw1tEh+8T/fEuyyfXWT65xnL/bdKwRyFb+WRhl3RpQmjj+3/S8w8g8liHFlnYIwvNSywtssiG2Aa5gQWRCbF56WcJBbaWQQpm2OMg+P0qkvGm/XvzL8CRIPwVDcPnbBLl9zCBgjtwMQwdwxD0ugZ6V0O3VSzTRAgNx+nn8cVisaX9ubPm/tOEH+sJP1QTvq8m3NtPKDkZBcdxGI1HmLqFrgl0Xcf3fUzTRFE6jIYj7FEftf8KbzlgTcAvCnxZWvNdNeXb8poHlZQviinFDeFwNER9pdI0y5zLGcPhmKOjQ6bTKfPFHKfvUlaKNCbPqAb7dOMX/PQSPtpb89VByk4pY6eU8vFeyp6VUfA8D0PTMVOT1csTwuGI+snJdm5BEHB2phLMgm3LrUnGIzOj6Kbs9pcUHfjNzOjNNxV6HkIXrJwQNJX5+Yh6s/k/wjNmweySLnstlD/3aAS7V9+k+ZlXKAyduGOjzDJGiyWNWo1gPs+FGAwGqKqK70/zh+t0TXql91ROOZ4V/7MLOaGqaaTJBW0fxrOQ42oFsRFICDrtNpoQWJaVixVFEUmS5L4QOobazTsYDodIKS8JNU1DxjL/IQxDKpUKhq7n2BBuFD89PeXxo8d4kY3oq5z+9XdO1G63883YjMZ1XQq2bdNqtWg06tSbJzSaTWq1GpVyeQtFUTAMA6WjcB6OsVwTfVOdYSCEoNfrMR6PmUwm/ANtzp+cozrmLAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;비동기로직&quot;
        title=&quot;&quot;
        src=&quot;/static/9060ff03638b21ebada26e9d108f9854/984b6/async.png&quot;
        srcset=&quot;/static/9060ff03638b21ebada26e9d108f9854/4d6f2/async.png 158w,
/static/9060ff03638b21ebada26e9d108f9854/3c1ae/async.png 315w,
/static/9060ff03638b21ebada26e9d108f9854/984b6/async.png 630w,
/static/9060ff03638b21ebada26e9d108f9854/3e3fe/async.png 860w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;태스크 큐(Task Queue)와 마이크로태스크 큐(Microtask Queue)는 자바스크립트의 비동기 처리 매커니즘에서 중요한 개념입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;태스크 큐&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;태스크 큐는 자바스크립트 엔진이 비동기 작업의 콜백 함수들을 기다리는 대기열입니다.&lt;/li&gt;
&lt;li&gt;비동기 작업의 콜백 함수나 이벤트 핸들러가 실행되어야 할 때, 해당 작업은 태스크 큐에 추가됩니다.&lt;/li&gt;
&lt;li&gt;이벤트 루프는 메인 스레드의 작업이 끝날 때마다 태스크 큐에서 콜백 함수를 꺼내와 실행시킵니다.&lt;/li&gt;
&lt;li&gt;대표적으로 &lt;strong&gt;setTimeout&lt;/strong&gt;, &lt;strong&gt;이벤트 핸들러&lt;/strong&gt;, &lt;strong&gt;AJAX 요청&lt;/strong&gt; 등이 태스크 큐에 추가됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;마이크로태스크 큐&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;마이크로태스크 큐는 태스크 큐와 유사하지만, 태스크 큐보다 우선순위가 높은 작업을 처리하는 대기열입니다.&lt;/li&gt;
&lt;li&gt;Promise의 &lt;strong&gt;then, catch, finally, await&lt;/strong&gt; 등과 같이 비동기 작업이 끝나면 가장 먼저 실행되어야 하는 작업들이 여기에 추가됩니다.&lt;/li&gt;
&lt;li&gt;마이크로태스크 큐의 작업이 모두 실행된 후에야 태스크 큐의 작업이 실행됩니다.&lt;/li&gt;
&lt;li&gt;이는 이벤트 루프에서 마이크로태스크 큐의 작업을 우선적으로 처리하는 원리입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;requestAnimationFrame에 대해 설명해주세요.&lt;/h4&gt;
&lt;p&gt;requestAnimationFrame은 브라우저 환경에서 사용되는 비동기적 웹 애니메이션을 실행하기 위한 메서드입니다.
이를 사용하면 브라우저의 리플로우와 리페인트 사이클에 맞게 애니메이션을 실행할 수 있어 부드럽고 성능 좋은 애니메이션을 구현할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;map, forEach, reduce에 대해 설명해주세요.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt; 메서드는 배열의 각 요소를 변환하여 새로운 배열을 반환합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reduce&lt;/strong&gt; 메서드는 배열의 각 요소를 순회하면서 주어진 함수를 적용하여 하나의 결과값을 반환합니다. 초기값을 설정하여 특정 인덱스부터 실행할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;forEach&lt;/strong&gt; 메서드는 배열의 각 요소에 주어진 함수를 실행하고 반환값은 없습니다. 주로 반복문을 대체하는 용도로 사용되며, 배열을 순회하면서 각 요소에 대한 작업을 수행할 때 유용합니다.&lt;/p&gt;
&lt;h3&gt;자바스크립트의 메모리 관리에 대해 아는 대로 설명해주세요.&lt;/h3&gt;
&lt;p&gt;자바스크립트는 &lt;strong&gt;가비지 컬렉션&lt;/strong&gt;이라는 메모리 관리 방법을 사용합니다.
대표적인 가비지 컬렉션 알고리즘으로 Mark and sweep 알고리즘이 있으며, 현재 모든 최신 엔진은 이 알고리즘을 사용한 가비지 컬렉션을 제공합니다.&lt;/p&gt;
&lt;p&gt;이 알고리즘은 더 이상 필요 없는 오브젝트를 닿을 수 없는 오브젝트로 정의합니다.&lt;/p&gt;
&lt;p&gt;이 알고리즘은 &lt;code&gt;roots&lt;/code&gt;라는 오브젝트의 집합을 가지고 있으며, 주기적으로 가비지 컬렉터는 &lt;strong&gt;roots&lt;/strong&gt;부터 시작하여, &lt;strong&gt;roots&lt;/strong&gt;가 참조하는 오브젝트들, &lt;strong&gt;roots&lt;/strong&gt;가 참조하는 오브젝트가 참조하는 오브젝트들을 찾습니다.&lt;/p&gt;
&lt;p&gt;이를 통해 모든 닿을 수 있는 오브젝트를 찾고 닿을 수 없는 모든 오브젝트들의 메모리를 해제합니다.&lt;/p&gt;
&lt;p&gt;이 가비지 컬렉션은 수동으로 조작할 수 없습니다.&lt;/p&gt;
&lt;h3&gt;클래스에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 클래스는 함수의 한 종류입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class는 new 연산자 없이 호출이 불가능 합니다.&lt;/li&gt;
&lt;li&gt;class는 extends와 super 키워드를 제공하여 상속이 가능합니다.
extends는 상속과 관련된 키워드이고, super는 수퍼클래스의 constructor 호출과 수퍼클래스의 메서드 호출을 가능하게 하는 키워드입니다.&lt;/li&gt;
&lt;li&gt;class에 정의된 메서드는 열거할 수 없으며, 항상 strict mode로 실행됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;즉시 실행 함수(IIFE)에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;즉시 실행함수는 정의되자마자 즉시 실행되는 함수를 말하며, 소괄호로 함수를 감싸서 실행하는 문법을 말합니다.
이를 통해 필요없는 전역 변수의 생성을 줄일 수 있고, 자체적인 스코프를 가지게 되기 때문에 private한 변수를 만들 수 있습니다.&lt;/p&gt;
&lt;h3&gt;엄격 모드에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;엄격 모드는 &apos;use strict&apos;를 스크립트 최상단에 작성하여 사용합니다.
이는 ES5에서 기존 스펙을 변경하며 하위 호환성 문제가 발생했기 때문에 도입된 문법으로, 엄격 모드를 활성화 했을 때에만 변경사항이 활성화되도록 해두었습니다.
또한 코드를 클래스와 모듈을 사용해 구성한다면 use strict를 사용하지 않아도 자동으로 엄격모드가 활성화됩니다.&lt;/p&gt;
&lt;h3&gt;콜 스택(Call Stack)과 힙(Heap)에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;콜 스택은 코드가 실행되면서 생성되는 실행 컨텍스트를 저장하는 자료구조입니다 이를 통해 변수 식별자, 스코프 체인 및 this 관리, 코드 실행 순서 관리 등을 수행하게 됩니다.
또한 콜 스택은 원시 타입의 값과 참조 타입의 메모리 힙 주소값이 저장되는 공간입니다.
메모리 힙은 원시 타입이 아닌 타입의 데이터가 저장되는 공간으로, 메모리 할당이 일어나게 됩니다.&lt;/p&gt;
&lt;h3&gt;Rest 연산자와 Spread 연산자에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;Spread 연산자를 사용하면 객체 혹은 배열을 개별 요소로 분리할 수 있습니다. 이를 통해 객체의 프로퍼티들을 기존 객체를 건드리지 않으면서 객체 혹은 배열을 복사할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Rest 연산자는 객체, 배열, 그리고 함수의 파라미터에서 사용이 가능합니다.
객체나 배열에서 Rest 연산자를 사용하면 디스트럭처링 된 값들을 다시 객체나 배열로 묶을 수 있습니다.
함수의 파라미터에서는 파라미터가 몇개가 될지 모르는 상황에서 이 파라미터들을 배열로 묶어주는 역할을 수행합니다.&lt;/p&gt;
&lt;h3&gt;제너레이터에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;제너레이터는 &lt;code&gt;function*&lt;/code&gt;로 만들어지는 제너레이터 함수를 통해 만들 수 있으며, 해당 함수는 본문을 실행하지 않고 제너레이터 객체를 반환합니다.&lt;/p&gt;
&lt;p&gt;그 후, &lt;code&gt;next()&lt;/code&gt;를 수행할 때마다, 함수에서 &lt;code&gt;yield&lt;/code&gt;한 값들을 하나씩 반환합니다.
&lt;code&gt;next()&lt;/code&gt;를 사용할 수 있는 것으로 짐작할 수 있듯, 제너레이터 객체는 이터레이터이자 이터러블입니다.&lt;/p&gt;
&lt;p&gt;따라서 제너레이터에서도 &lt;code&gt;for ... of&lt;/code&gt;이나 Spread 문법, 배열 디스트럭쳐링과 같은 기능을 사용할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;이터러블과 이터레이터 프로토콜에 대해 설명해 주세요.&lt;/h3&gt;
&lt;p&gt;이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위해 ES6에서 도입된 규칙입니다.
이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 &lt;code&gt;Symbol.iterator&lt;/code&gt; 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환합니다.&lt;/p&gt;
&lt;p&gt;이러한 규약을 이터러블 프로토콜이라 하며, 이터러블 프로토콜을 준수한 객체를 이터러블이라 합니다.&lt;/p&gt;
&lt;p&gt;이터러블의 &lt;code&gt;Symbol.iterator&lt;/code&gt; 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환합니다. 이터레이터는 &lt;code&gt;next&lt;/code&gt; 메서드를 소유하며 &lt;code&gt;next&lt;/code&gt; 메서드를 호출하면 이터러블을 순회하며
&lt;code&gt;value&lt;/code&gt;와 &lt;code&gt;done&lt;/code&gt; 프로퍼티를 갖는 이터레이터 리절트 객체를 반환합니다.&lt;/p&gt;
&lt;p&gt;이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Typescript - type과 interface 차이]]></title><description><![CDATA[typescript를 공부해보셨다면 type과 interface의 차이점에 대해 궁금증을 가져보셨을 텐데요!
이번 기회에 확실히 정리해 봅시다! 🙌 📌 상속 받는 법 interface는 extends를 type…]]></description><link>https://kirahaa.github.io/ts-type-interface/</link><guid isPermaLink="false">https://kirahaa.github.io/ts-type-interface/</guid><pubDate>Sat, 22 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;typescript&lt;/strong&gt;를 공부해보셨다면 &lt;code&gt;type&lt;/code&gt;과 &lt;code&gt;interface&lt;/code&gt;의 차이점에 대해 궁금증을 가져보셨을 텐데요!&lt;br/&gt;
이번 기회에 확실히 정리해 봅시다! 🙌&lt;/p&gt;
&lt;h3&gt;📌 상속 받는 법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;interface&lt;/strong&gt;는 &lt;code&gt;extends&lt;/code&gt;를 &lt;strong&gt;type&lt;/strong&gt;은 &lt;code&gt;&amp;#x26;&lt;/code&gt;를 이용해 상속을 통한 확장을 진행합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ✅ interface
interface IString1 {
  a: string;
}

interface IString2 extends IString2 {
  b: string;
}

const interfaceConst: interface2 = {
  a: &amp;#39;a&amp;#39;,
  b: &amp;#39;b&amp;#39;
}

// ✅ type
type type1 = {
  a: string;
}

type type2 = type1 &amp;amp; {
  b: string;
}

const typeConst: type2 = {
  a: &amp;#39;a&amp;#39;,
  b: &amp;#39;b&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;📌 선언적 확장 / 자동 확장&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;interface&lt;/strong&gt;는 같은 이름의 객체를 다시 한번 선언하면 자동으로 확장이 됩니다. 하지만 &lt;strong&gt;type&lt;/strong&gt;은 불가능 합니다.&lt;br/&gt;
따라서 외부에 공개되어야 하는 library 같은 경우에는 타입 객체의 확장성을 위해 &lt;strong&gt;interface&lt;/strong&gt;를 사용하는 것을 추천한다고 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ✅
interface interface1 {
  a: string;
}

interface interface1 {
  b: string;
}

const interfaceConst: interface1 = {
  a: &amp;#39;a&amp;#39;,
  b: &amp;#39;b&amp;#39;
}


// ❌ Duplicate identifier &amp;#39;type1&amp;#39;.
type type1 = {
  a: string;
}

type type1 = {
  b: string;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;📌 computed property name&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;computed property name은 &lt;strong&gt;표현식(변수, 함수 등)을 이용해 객체의 key 값을 지정하는 문법&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;의 경우, computed property name을 사용한 타입 선언이 가능하지만, &lt;strong&gt;interface&lt;/strong&gt;의 경우는 불가능합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type keyType = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39;

type type1 = {
  [key in keyType]: string
}

const typeA: type1 = { a: &amp;#39;a&amp;#39;, b: &amp;#39;b&amp;#39; }

interface interface1 {
  // ❌ error
  [key in keyType]: string
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;📌 원시 타입이나 튜플, 유니온 타입의 타입 선언의 경우에는 type 사용, interface는 객체의 타입 정의에 사용&lt;/h3&gt;
&lt;h4&gt;원시 타입(Primitive Types)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type CustomType = string;
const str: CustomType = &amp;#39;&amp;#39;;

// ❌ 
interface CustomInterface = string;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;유니온 타입(Union Types)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;유니온 타입이란 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Fruit = &amp;#39;apple&amp;#39; | &amp;#39;lemon&amp;#39;
type Vegetable = &amp;#39;patato&amp;#39; | &amp;#39;tomato&amp;#39;

type Food = Fruit | Vegetable

const apple: Food = &amp;#39;apple&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;튜플 타입(Tuple Types)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;tuple은 자바스크립트에서는 지원하지 않는 데이터 타입이지만, 타입스크립트에서는 &lt;strong&gt;배열 타입을 보다 특수한 형태로 사용할 수 있는 타입&lt;/strong&gt;입니다.
tuple에 명시적으로 지정된 형식에 따라 아이템 순서를 설정해야 되고, 추가되는 아이템 또한 tuple에 명시된 타입만 사용 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Animal = [name: string, age: number];

const cat: Animal = [&amp;#39;kitty&amp;#39;, 1];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;hr&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;공식문서에서는 특별한 경우를 제외하고는 &lt;strong&gt;type보단 interface를 사용하는 것이 더 좋다&lt;/strong&gt;고 하네요!&lt;br/&gt;
프로젝트를 설계하기 전에 type을 쓸지 interface를 쓸지 통일을 하면 좋을 것 같습니다!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론적으로는 팀 내 컨벤션이 있다면 그에 따르고, type과 interface의 쓰임새에 맞게 사용해주는게 좋다고 생각합니다. 😉&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NestJS를 배워보자]]></title><description><![CDATA[NestJS란? NestJS는 Node.js를 기반으로 한 서버 어플리케이션을 개발하기 위한 프레임워크 입니다. Node.js의 표준 웹서버 프레임워크로 불리는 Express 대신 왜 NestJS를 선택해야 할까요? 최근 몇 년 동안 Node.js…]]></description><link>https://kirahaa.github.io/starting-nest-js/</link><guid isPermaLink="false">https://kirahaa.github.io/starting-nest-js/</guid><pubDate>Thu, 20 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;h2&gt;NestJS란?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://nestjs.com/&quot;&gt;NestJS&lt;/a&gt;는 Node.js를 기반으로 한 서버 어플리케이션을 개발하기 위한 프레임워크 입니다.&lt;/p&gt;
&lt;p&gt;Node.js의 표준 웹서버 프레임워크로 불리는 Express 대신 왜 NestJS를 선택해야 할까요?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최근 몇 년 동안 Node.js 덕분에 자바스크립트는 백엔드, 프론트엔드 애플리케이션 모두의 웹 공통 언어가 되었습니다.&lt;br/&gt;
이로 인해 Angular, React, Vue가 나오게 되었으며, 해당 프로젝트를 통해 생산성을 향상하고 빠르게 만들 수 있으며, 테스트 가능하고 확장성이 있는 프론트엔드 애플리케이션을 만들 수 있게 되었습니다.
그러나 서버 측 Node.js에서는 뛰어난 라이브러리, 툴이 존재하지만 아키텍처, 즉 프로젝트 구조에 있어서 주요 문제를 효과적으로 해결하는 것은 없었습니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Nest는 개발자와 팀이 테스트 가능하고 확장이 가능하며, 느슨한 결합과 유지보수성이 뛰어난 애플리케이션을 만들 수 있도록 아키텍처를 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, &lt;strong&gt;NestJS는 서버 측 애플리케이션 개발에 있어 아키텍처의 문제를 해결하기 위해 등장&lt;/strong&gt;한 것입니다.&lt;/p&gt;
&lt;p&gt;기존의 Express는 사용하기도 쉽고 성능도 뛰어나지만 아키텍처에 관한 정의나 기능을 제공해주고 있진 않습니다.&lt;br/&gt;
실제로 팀 또는 사람마다 아키텍처가 다르면 이를 이해하기 위한 비용 또는 개발 전에 아키텍처를 선정하는 커뮤니케이션 비용이 증가합니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;NestJS는 아키텍처에 대한 정의를 제공하기 때문에 동일한 아키텍처에서 다른 개발자가 작성한 코드를 쉽게 이해할 수 있다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;그럼 NestJS를 설치해보면서 같이 시작해 봅시다! 🤗&lt;/p&gt;
&lt;h2&gt;NestJS CLI 설치&lt;/h2&gt;
&lt;p&gt;NestJS는 개발자가 좀 더 편리하게 NestJS 프로젝트를 개발하고 설정할 수 있도록 강력한 CLI(명령줄 인터페이스) 도구를 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;터미널을 열고 다음 명령어를 실행하여 NestJS CLI 도구를 전역(global)에 설치해 봅시다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm i -g @nestjs/cli
added 251 packages, and audited 252 packages in 11s

41 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 터미널에서 &lt;code&gt;nest&lt;/code&gt;라는 명령어를 사용할 수 있습니다.
단순히 &lt;code&gt;nest&lt;/code&gt; 명령어를 실행해보면 간단한 설명서를 확인할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ nest
nest
Usage: nest &amp;lt;command&amp;gt; [options]

Options:
  -v, --version                                   Output the current version.
  -h, --help                                      Output usage information.

Commands:
  new|n [options] [name]                          Generate Nest application.
  build [options] [app]                           Build Nest application.
  start [options] [app]                           Run Nest application.
  info|i                                          Display Nest project details.
  add [options] &amp;lt;library&amp;gt;                         Adds support for an external library to your project.
  generate|g [options] &amp;lt;schematic&amp;gt; [name] [path]  Generate a Nest element.
    Schematics available on @nestjs/schematics collection:
      ┌───────────────┬─────────────┬──────────────────────────────────────────────┐
      │ name          │ alias       │ description                                  │
      │ application   │ application │ Generate a new application workspace         │
      │ class         │ cl          │ Generate a new class                         │
      │ configuration │ config      │ Generate a CLI configuration file            │
      │ controller    │ co          │ Generate a controller declaration            │
      │ decorator     │ d           │ Generate a custom decorator                  │
      │ filter        │ f           │ Generate a filter declaration                │
      │ gateway       │ ga          │ Generate a gateway declaration               │
      │ guard         │ gu          │ Generate a guard declaration                 │
      │ interceptor   │ itc         │ Generate an interceptor declaration          │
      │ interface     │ itf         │ Generate an interface                        │
      │ middleware    │ mi          │ Generate a middleware declaration            │
      │ module        │ mo          │ Generate a module declaration                │
      │ pipe          │ pi          │ Generate a pipe declaration                  │
      │ provider      │ pr          │ Generate a provider declaration              │
      │ resolver      │ r           │ Generate a GraphQL resolver declaration      │
      │ service       │ s           │ Generate a service declaration               │
      │ library       │ lib         │ Generate a new library within a monorepo     │
      │ sub-app       │ app         │ Generate a new application within a monorepo │
      │ resource      │ res         │ Generate a new CRUD resource                 │
      └───────────────┴─────────────┴──────────────────────────────────────────────┘&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;NestJS 프로젝트 구성&lt;/h2&gt;
&lt;p&gt;다음으로 NestJS CLI를 이용해서 새로운 NestJS 프로젝트를 구성해 봅시다!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nest new&lt;/code&gt; 명령어 뒤에 프로젝트 명을 작성하면 해당 이름의 디렉토리가 생기고 그 안에 NestJS 프로젝트가 자동으로 구성이 될 것입니다.&lt;br/&gt;
저는 &lt;code&gt;nest-app&lt;/code&gt;을 프로젝트 이름으로 사용하였습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ nest new nest-app
⚡  We will scaffold your app in a few seconds..

✔ Installation in progress... ☕

🚀  Successfully created project our-nestjs
👉  Get started with the following commands:

$ cd nest-app
$ npm run start&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;npm run start&lt;/code&gt;로 NestJS 애플리케이션을 구동한 후, &lt;code&gt;http://localhost:3000&lt;/code&gt;에 접속해보면 Hello World!가 응답되는 것을 확인할 수 있을 것입니다.&lt;/p&gt;
&lt;h2&gt;main.ts&lt;/h2&gt;
&lt;p&gt;자동으로 생성된 파일 중에서 제일 먼저 살펴볼 파일은 &lt;code&gt;src&lt;/code&gt; 디렉토리 안에 있는 &lt;code&gt;main.ts&lt;/code&gt; 파일입니다.&lt;br/&gt;
이 파일은 NestJS 애플리케이션이 시작되는 진입 지점(entry point)이 되는데요. 파일을 열어보면 매우 짧은 코드가 들어있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { NestFactory } from &amp;quot;@nestjs/core&amp;quot;;
import { AppModule } from &amp;quot;./app.module&amp;quot;;

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;코드의 마지막 줄에는 &lt;code&gt;bootstrap()&lt;/code&gt;이라는 함수를 호출하고 있는데요.
&lt;code&gt;bootstrap()&lt;/code&gt; 함수 안에서는 &lt;code&gt;app.module&lt;/code&gt; 파일로부터 &lt;code&gt;AppModule&lt;/code&gt;을 불러와서 &lt;code&gt;NestFactory&lt;/code&gt;가 애플리케이션 객체를 생성하고 3000 포트로 HTTP 요청을 받고 있습니다.&lt;/p&gt;
&lt;h2&gt;모듈(Module)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;main.ts&lt;/code&gt; 파일에서 불러오고 있는 &lt;code&gt;app.module.ts&lt;/code&gt; 파일을 열어보면 &lt;code&gt;AppModule&lt;/code&gt; 클래스를 찾을 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { Module } from &amp;quot;@nestjs/common&amp;quot;;
import { AppController } from &amp;quot;./app.controller&amp;quot;;
import { AppService } from &amp;quot;./app.service&amp;quot;;

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 클래스 위에는 &lt;code&gt;@Module()&lt;/code&gt;이라는 데코리이터(decorator)가 호출되고 있습니다.&lt;/p&gt;
&lt;p&gt;NestJS에서 데코레이터는 일반적으로 클래스나 메서드에 어떤 정보를 추가해줄 때 활용이 됩니다.&lt;br/&gt;
&lt;code&gt;@Module()&lt;/code&gt; 데코레이터는 &lt;code&gt;imports&lt;/code&gt;, &lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;providers&lt;/code&gt; 속성으로 이루어진 객체를 인자로 받는데요.
&lt;code&gt;controllers&lt;/code&gt; 속성에는 HTTP 요청을 받아서 응답을 보내는 컨트롤러 클래스를 나열해줄 수 있고, &lt;code&gt;providers&lt;/code&gt; 속성에는 컨트롤러가 사용하는
다양한 일반 클래스(주로 서비스 클래스)를 나열해줄 수 있습니다. 여기서 비어있는 &lt;code&gt;imports&lt;/code&gt; 속성에는 해당 모듈이 의존하고 있는 다른 모듈을 나열해줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;모듈(module)은 NestJS에 매우 중요한 개념이라서 잘 이해하고 있어야 하는데요. 하나의 NestJS 애플리케이션은 보통 여러 개의 모듈로 이루어지는데
기능 단위로 애플리케이션을 쪼개 놓은 단위라고 생각할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여기서 중요한 것은 모듈은 서로 의존할 수 있다는 것인데요. 바로 &lt;code&gt;Module()&lt;/code&gt; 데코리에터에 인자로 넘기는 객체의 &lt;code&gt;imports&lt;/code&gt; 속성을 통해서 이 의존 관계를 명시하도록 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nestjs new&lt;/code&gt; 명령어로 NestJS 프로젝트를 생성하면 기본적으로 최상위 모듈인 &lt;code&gt;AppModule&lt;/code&gt; 하나 밖에 없지만, 프로젝트 규모가 점점 커지게 되면
다른 모듈을 작성한 후 &lt;code&gt;AppModule&lt;/code&gt;이 불러올 수 있도록 &lt;code&gt;@Module()&lt;/code&gt; 데코레이터를 호출할 때 &lt;code&gt;imports&lt;/code&gt; 속성을 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;정리하면 NestJS는 일종의 IoC(Inversion of Control) 컨테이너의 역할을 하면서 여러 모듈을 DI(의존성 주입)을 통해서 엮어준다고 보시면 됩니다.
어떻게 엮어야 하는지는 개발자가 각 모듈에 &lt;code&gt;@Module()&lt;/code&gt; 데코레이터의 &lt;code&gt;imports&lt;/code&gt; 속성으로 NestJS에 알려줘야 하고요.&lt;/p&gt;
&lt;h2&gt;컨트롤러(Controller)&lt;/h2&gt;
&lt;p&gt;다음으로 NestJS에서 하나의 축을 담당하고 있는 컨트롤러에 대해서 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;컨트롤러는 HTTP 요청을 받아서 처리하고 응답을 해주는 역할을 담당하고 있는 클래스입니다.&lt;br/&gt;
&lt;code&gt;src&lt;/code&gt; 디렉토리 안에 있는 &lt;code&gt;app.controller.ts&lt;/code&gt; 파일을 열어서 컨트롤러가 어떻게 생겼는지 확인해 보겠습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// src/app.controller.ts

import {Controller, Get} from &amp;quot;@nestjs/common&amp;quot;;
import {AppServie} from &amp;quot;./app.service&amp;quot;;

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
  
  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같이 클래스 위에다가 &lt;code&gt;@Controller()&lt;/code&gt; 데코레이터를 호출해주면 NestJS가 해당 클래스는 컨트롤러로 인식을 하게 되는데요.
클래스 내의 각 메서드에는 &lt;code&gt;@Get()&lt;/code&gt;, &lt;code&gt;@Post()&lt;/code&gt;, &lt;code&gt;@Delete()&lt;/code&gt;와 같은 HTTP 방식(method)에 해당하는 데코레이터를 붙여주게 됩니다.&lt;/p&gt;
&lt;p&gt;또한 이러한 데코레이터들은 URL 경로를 나타내는 문자열을 인자로 받는데요. NestJS는 데코레이터로 명시된 HTTP 방식과 URL 경로를 기준으로 부합하는 클래스의 메서드를 호출해줍니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;@Controller(&quot;aaa&quot;)&lt;/code&gt;가 붙어있는 클래스의 &lt;code&gt;@Post(&quot;bbb&quot;)&lt;/code&gt;가 붙어있는 메서드가 있었다면, POST 방식으로 &lt;code&gt;http://localhost:3000/aaa/bbb&lt;/code&gt; 에 요청했을 때 해당 메서드가 호출되었을 것입니다.&lt;/p&gt;
&lt;p&gt;이를 통해 아까 전에 위에서 &lt;code&gt;http://localhost:3000&lt;/code&gt;에 요청했을 때, &lt;code&gt;AppController&lt;/code&gt; 클래스의 &lt;code&gt;getHello()&lt;/code&gt; 함수가 이를 받아서 &lt;code&gt;Hello World!&lt;/code&gt;라는 응답을 해줬다는 것을 알 수 있습니다.&lt;/p&gt;
&lt;h2&gt;서비스(Service)&lt;/h2&gt;
&lt;p&gt;마지막으로 살펴볼 서비스 클래스는 일반적으로 비즈니스 로직을 수행하는 역할을 담당합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt; 디렉토리 안에 있는 &lt;code&gt;app.service.ts&lt;/code&gt;를 열어보면 &lt;code&gt;AppController&lt;/code&gt; 클래스가 사용하고 있던 &lt;code&gt;AppService&lt;/code&gt; 클래스를 확인할 수 있는데요.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// src/app.service.ts

import { Injectable } from &amp;quot;@nestjs/common&amp;quot;;

@Injectable()
export class AppService {
  getHello(): string {
    return &amp;quot;Hello World!&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 클래스 위에는 &lt;code&gt;@Injectable()&lt;/code&gt; 데코레이터가 사용되고 있죠? &lt;code&gt;@Injectable()&lt;/code&gt; 데코레이터가 붙어있는 클래스는 NestJS가 인스턴스를 생성하여 다른 클래스에 생성자를 통해서 주입을 해줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AppModule&lt;/code&gt;에서 &lt;code&gt;@Module()&lt;/code&gt; 데코레이터를 호출할 때 &lt;code&gt;providers&lt;/code&gt; 속성에 &lt;code&gt;AppService&lt;/code&gt; 클래스를 명시해줬었죠? 그렇기 때문에 &lt;code&gt;AppController&lt;/code&gt; 클래스의 생성자의 인자로 &lt;code&gt;AppService&lt;/code&gt; 클래스의 인스턴스가 주입이 되었고, &lt;code&gt;AppController&lt;/code&gt; 클래스의 &lt;code&gt;getHello&lt;/code&gt; 메서드 내에서 &lt;code&gt;AppService&lt;/code&gt; 클래스의 &lt;code&gt;getHello&lt;/code&gt; 메서드를 호출할 수 있었던 것입니다.&lt;/p&gt;
&lt;p&gt;이렇게 컨트롤러의 역할과 서비스의 역할을 분리함으로써 좀 더 유지보수가 용이한 애플리케이션을 개발할 수가 있는 것입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS 프리티어 EC2와 Github 연동하기]]></title><description><![CDATA[AWS는 Amazon Web Service의 약어로 대표적인 클라우드 플랫폼입니다.
AWS는 계정 생성 후 1년 동안 일정 무료 사용량을 제공하는 프리티어 서비스를 제공합니다. 시작하기 1) AWS 계정 생성, region…]]></description><link>https://kirahaa.github.io/aws-ec2-hosting/</link><guid isPermaLink="false">https://kirahaa.github.io/aws-ec2-hosting/</guid><pubDate>Sat, 15 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 310px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b518440d99795355f7c39bb20e35c2bc/56e1b/aws_0.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 52.53164556962025%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABT0lEQVR42oWS7UsCQRDG/Vv7WF8krD4kQYkRYkUkVGgkimUmHWqYb2glpiRhlGVRaF5iih1Cp0nt7EycpRTc1cMyMMNvmdl9Rkc/hIgMgDEGAJxzxpQISgUYACLSb+lIQzgQaUs3RIlIljseX2DHHzxK58oVMRxLirV66iQrhKLuXUHuvg1Jlcuvspw+zZssqwvLa06P32Cc3/Ls2ewuo2kxkjgGAPXOAJyIIvGUZWV9xrwUOIjpp+Y23b6R0cnC5XX9uTE+bc7k8kTEOVfvXK01nd6gEAw/VsVwNHn/UBZCUUmSQodxl3e/9SKpj03UL7Wv6L32lQxOn4UeVbaptKHx230Guw0sWHlmAm8cXExg84w/JfHOjflZXrTjrWtIaliFSK1zurBSRk/pMcoaqGijdolYjz46f/uMhFzDd/79tP+WBIkzQlCmUCJoLcknZU5hkc74J8IAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws&quot;
        title=&quot;&quot;
        src=&quot;/static/b518440d99795355f7c39bb20e35c2bc/56e1b/aws_0.png&quot;
        srcset=&quot;/static/b518440d99795355f7c39bb20e35c2bc/4d6f2/aws_0.png 158w,
/static/b518440d99795355f7c39bb20e35c2bc/56e1b/aws_0.png 310w&quot;
        sizes=&quot;(max-width: 310px) 100vw, 310px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AWS&lt;/strong&gt;는 &lt;strong&gt;Amazon Web Service&lt;/strong&gt;의 약어로 대표적인 클라우드 플랫폼입니다.&lt;br/&gt;
AWS는 계정 생성 후 1년 동안 일정 무료 사용량을 제공하는 프리티어 서비스를 제공합니다.&lt;/p&gt;
&lt;h2&gt;시작하기&lt;/h2&gt;
&lt;h3&gt;1) AWS 계정 생성, region 설정&lt;/h3&gt;
&lt;p&gt;개인정보와 결제 카드 등을 등록해서 AWS 가입을 해줍니다.
상단 메뉴에서 지역은 &lt;strong&gt;아시아 태평양 (서울) ap-northeast-2&lt;/strong&gt;로 설정해 줍니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 337px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b7c4232f19be0eb7e91a3fee082c4828/f5074/aws_region.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 137.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAECAwUE/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAcwlGp7i0HOSSaggf//EABwQAAAGAwAAAAAAAAAAAAAAAAACAwQQMhEzQf/aAAgBAQABBQKEUynKOtqQ2pmG2v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARAAcSJB4f/aAAgBAQAGPwJZDc6jbNs3P//EABsQAAIDAQEBAAAAAAAAAAAAAAABEWHwMSFB/9oACAEBAAE/IUkN+j65GodE3Az0y0hTHT70y0hVJNNI/9oADAMBAAIAAwAAABDMGU3/xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EK1D/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EFYr/8QAIRAAAgEDBAMBAAAAAAAAAAAAAREAITFxQVFhoZGx0fD/2gAIAQEAAT8QSBdciWIJ1dBrDXDAEGKIbZiiotsELuLOHud9q4bslz8lWbfsTuoEASeT9jgkq/JhMvKH/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws region&quot;
        title=&quot;&quot;
        src=&quot;/static/b7c4232f19be0eb7e91a3fee082c4828/f5074/aws_region.jpg&quot;
        srcset=&quot;/static/b7c4232f19be0eb7e91a3fee082c4828/ab180/aws_region.jpg 158w,
/static/b7c4232f19be0eb7e91a3fee082c4828/ba98e/aws_region.jpg 315w,
/static/b7c4232f19be0eb7e91a3fee082c4828/f5074/aws_region.jpg 337w&quot;
        sizes=&quot;(max-width: 337px) 100vw, 337px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2) 인스턴스 시작&lt;/h3&gt;
&lt;p&gt;메인 화면에서 EC2 서비스를 클릭하거나, 상단 검색 메뉴에서 EC2를 검색하면 다음과 같은 대시보드를 확인 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5f6f4d81571d4b7416443adc95fcc368/bbbf7/aws_1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABsUlEQVR42m1Sy24bMQzc/7/WiWOndlyn6D/02ENv7a23okARBAG8Xe1KIvVaSTuFaMNIHwQGlAiRHHLUrfcfsH77HqvtAbf3D7jZHrDZP+Jud8Rqsxesd0esd4+4vT/+gdXmgDd3D+Ibbrbv0NUcUaJDs5QSYozIOeO1LcuC/1l713Kan+cZpRZ0zAzvnSRpo6GNxUlNMMaCiEDEGCcDSw61FJQLQpqR5nyN1VrhQ0DnfEApVTpaa6HJg0JptC7MFmhO8CmjLhWlnqE5/hNzIaIjS4jeXQsa9pilwaXgsiDN5dr0Om6pqH+too3fMTtYSxIgslA24FkxThNjsB69ZvQTQVknd4FxAnU5/9IM7RJcTOjazqZRvWIYcDIBvfaYOGGkiImjeMHlrK4IQmLkBOsCurZ078OZIRNO/YCnpxewZTATmmgNTf0QAvq+h1JKlGViTNpgUArDoETErgVzTmeGHGC+fcb46QHmy0cMwyiP226azTnLerQxcm/fxLgJHC0oGoQU0DWp2TkRwRLDvvwEff8K+/wDxA7OOfkWi4gzw3sv7Fosl4w5J5SSpXib4jdmmvKyOGE+TAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws instance&quot;
        title=&quot;&quot;
        src=&quot;/static/5f6f4d81571d4b7416443adc95fcc368/984b6/aws_1.png&quot;
        srcset=&quot;/static/5f6f4d81571d4b7416443adc95fcc368/4d6f2/aws_1.png 158w,
/static/5f6f4d81571d4b7416443adc95fcc368/3c1ae/aws_1.png 315w,
/static/5f6f4d81571d4b7416443adc95fcc368/984b6/aws_1.png 630w,
/static/5f6f4d81571d4b7416443adc95fcc368/e7d8e/aws_1.png 945w,
/static/5f6f4d81571d4b7416443adc95fcc368/58c38/aws_1.png 1260w,
/static/5f6f4d81571d4b7416443adc95fcc368/bbbf7/aws_1.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;인스턴스 시작 버튼을 누르면 클라우드 서버 구축을 시작하는 것입니다.&lt;/p&gt;
&lt;h3&gt;3) AMI 선택(어떤 종류의 서버 컴퓨터를 돌릴 것인지)&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/918190bc8ed757b9100da25a0247f348/90377/aws_ami.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 69.62025316455697%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACLklEQVR42m2TXXKcMBCEuf8tcoTcIM95TVXih8Re73ptAwsI/UsIvtRof1MVqroYDainZ9RqBjXTjYp+nOhPJ5TWGGv/A3OLtbEoNRNTJKV0g/ee5qNt+f3nmZfdjv3xg0Epxmm6QDFc4umSH8bpTKoNzkeWpdwQY6IZxpG26+j6nrbvb2RCMD2QP66tc2QhyIWlrKzrGaKykUpt2zIqTcqZnO8tSFyR7pC8dZ7PceatG5m0JabMukFeMo3In2dd5T7Kv6IUwVqVFNkFuBCYjMfGjE+Fsp3zOWcaa12tWBUtyxmidFmq4qtaExIupqrC+sBoPCEXHp9KKAr3+wPPzy/sDwd2u1de9/saHw5vdKcR5xzOWay159h7OmWZXfyHUAQ08lHmKCc6qfn2Fhhjsd4TQsSHUFuNMWJ95Dh5jsNMN3s67Tm5hA6JRrwTxUMh4H2os5QiEstphhBYrqO4jENa/9SBp92Rp9d3fv555X2c0SHThBjrhhQjgwkYn4CNbbvj/GyX/IoNiTEUWh3oBGFl2kCLbYRwsJEPdTarMaaqksMSpaJSOoh5QVnPum34GAl5IZeNvELcf8P8+ILvn4Qw0SrD+6DqHITAao3zmmAMqu/R0npaqlWWdeXa1bqW2oE/fmf89ZU4vdDI7MScXb3LQ/35Nq+USTFVH4pi8etSSi2qjbkjFkwG7YIoDPWyn4ax4nr55YR9iNUKZS2kC7mshXDW+k6oFXoe0XrmLxHqOGaemtRAAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws ami&quot;
        title=&quot;&quot;
        src=&quot;/static/918190bc8ed757b9100da25a0247f348/984b6/aws_ami.png&quot;
        srcset=&quot;/static/918190bc8ed757b9100da25a0247f348/4d6f2/aws_ami.png 158w,
/static/918190bc8ed757b9100da25a0247f348/3c1ae/aws_ami.png 315w,
/static/918190bc8ed757b9100da25a0247f348/984b6/aws_ami.png 630w,
/static/918190bc8ed757b9100da25a0247f348/e7d8e/aws_ami.png 945w,
/static/918190bc8ed757b9100da25a0247f348/90377/aws_ami.png 1231w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저는 &lt;strong&gt;Amazon Linux&lt;/strong&gt;를 선택하였습니다. 이 중 프리티어 사용가능이 아닌 OS도 있으니 잘 보고 선택해야 합니다.&lt;/p&gt;
&lt;h3&gt;4) 인스턴스 유형 선택&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5b5f8928b88db5e65f6566f1014e3575/912c7/aws_instance.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 70.25316455696203%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACA0lEQVR42o1T2YoUQRDs//8Hv8JP8FlQcfEAhZWd2ZnZ7q47s67ukMyZbh0FsSCog6rIjMisIRGhlIrWGmqtirLNpWJZFvw5Ykow1iLnjFLKDmLGQEwIISLGhFwKUkr6gDOjt46zP+LrywNqL0q2YkVihvcekRit9R1COggr5wxmRu/Xw5QIkjlW4GB/4MPhLaiSbNGXRe+X2pFrR+uLqhCIsiHECOe9SnAhatob1I5c0et62yc9EwXn2ePpMmN2AVwa+gq1bVA/jME0TSDOGkkyFWxruaj727mQ2kgIXEG1oy+r2rETzsaojNrqzeCqnoifAjkPMekdGRLYBAKVdlcsJRTJxjoY5zHNRtfjbGCdV0hA8SblCs9VPRPiFxvhIt8R1o1wHEccn58xG7d7dIf4a06yJsbREg6Tw8URzjZhjFkDDiJpnCZcLi+wPighEWnVt+JIC+nMjMyMyBnnkPHl8YjPj0c8fHvE02jhc716KNgLooW4h3gjUktfsa4rKBfMLD3KigstMAvgt7bZGvuaRf4L0pcxEVy89qfeqw1Fgq0AP71BeP8KdP54zXAcJ5xOZ/iY9u/3O1q7fs1Ssv4QIWy9YelNM+bTO8yfXiPP3zGIX14ypKw99j9DMvYh3ODhc0NogKeMQSRMxsJYr6ZLD0rUfxIS6e/aSb2FdzO8d/gJ8d4/EP+3o9sAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws instance&quot;
        title=&quot;&quot;
        src=&quot;/static/5b5f8928b88db5e65f6566f1014e3575/984b6/aws_instance.png&quot;
        srcset=&quot;/static/5b5f8928b88db5e65f6566f1014e3575/4d6f2/aws_instance.png 158w,
/static/5b5f8928b88db5e65f6566f1014e3575/3c1ae/aws_instance.png 315w,
/static/5b5f8928b88db5e65f6566f1014e3575/984b6/aws_instance.png 630w,
/static/5b5f8928b88db5e65f6566f1014e3575/e7d8e/aws_instance.png 945w,
/static/5b5f8928b88db5e65f6566f1014e3575/912c7/aws_instance.png 1228w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;프리티어를 마음 편하게 사용하려면 메모리 1GB의 &lt;strong&gt;t2.micro&lt;/strong&gt; 밖에 선택사항이 없습니다.. 😂&lt;/p&gt;
&lt;h3&gt;5) 인스턴스 세부 정보 변경&lt;/h3&gt;
&lt;p&gt;바로 [검토 및 시작] 버튼을 눌러도 잘 생성되지만, [인스턴스 세부 정보 변경] 버튼을 눌러 세부사항을 입맛에 맞게 변경할 수 있습니다.&lt;br/&gt;
저는 따로 변경하지 않고 진행하였습니다.&lt;/p&gt;
&lt;h3&gt;6) 키 페어 설정&lt;/h3&gt;
&lt;p&gt;새 키 페어 생성 버튼을 누르면 키 페어 이름을 입력해주고, 다운로드 된 키페어 파일을 로컬 컴퓨터에 잘 저장해 놓아야 합니다. 이름은 뭐든 괜찮습니다.&lt;br/&gt;
키 페어 다운로드 버튼을 누르면 &lt;code&gt;.pem&lt;/code&gt; 파일이 다운로드 됩니다.&lt;/p&gt;
&lt;h3&gt;7) 보안 그룹 설정&lt;/h3&gt;
&lt;p&gt;보안 그룹은 EC2 인스턴스에 접근할 수 있는 그룹입니다.&lt;br/&gt;
보안이 중요하다면 접근 가능한 포트와 IP를 지정하는 것이 좋습니다.&lt;br/&gt;
저는 일단 기본으로 진행했습니다.&lt;/p&gt;
&lt;p&gt;이제 인스턴스 시작 버튼을 누르면 EC2 인스턴스 생성이 완료됩니다.&lt;br/&gt;
터미널에서 인스턴스에 접근해서 서버 코드를 올리고 서버를 구동할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/026b03f3f90df2fca59187a83075175f/a2afc/aws_connect.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.835443037974684%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABpklEQVR42k2R227TQBCG/ea8BeIZuOGCCwSt2oQ2JyA8AkpLc3DsOI7jPc3u+kO7JFV/6deMZ8b/HLYYTX7yMF3w7faOz19uuLl/YDT+zuNkxnzxi+mF88WS2WLJ/MdvHqczRvcfGI1vGU+WTEZfmX58x92n9xQ+BIYYqTtFfTa02tJpi/EeI4ITn2m94LzPlBAIMWJF8CHmfBwC3bmjMFrhvWe9r3kpK9b7A6tdzfNuz2qz5WlTZv/PZsNqvWW1Lvm7q9gdWl7Kmk3VsK4O7Nue521JoZVCRGhPJ45tS9M01FWF6nu8OJxYvBe8CCIuW+8ckpjyzmYmvyxLCqU14j1N23JoT/RaY4zFZQGPtS7bdJoY4yvTVskOw5BtQlVVFNZaYoh0XZd/9j7koitO/QllDD6+hrL4oWlz49TMOUccoDm2FL3qc6Dv+0uB5O80QYIxBq01qXHKkSYahvwYyU/Nh8uEaaiiTzf0Hm1MvmESHS6FCUpptPv/mtdYWvGkDMoKEgZceCOolMoFkm8mr/e4wjjhbAPmzc4xDhyVzYIhXqaFvNk/TYCwBNoz580AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws connect&quot;
        title=&quot;&quot;
        src=&quot;/static/026b03f3f90df2fca59187a83075175f/984b6/aws_connect.png&quot;
        srcset=&quot;/static/026b03f3f90df2fca59187a83075175f/4d6f2/aws_connect.png 158w,
/static/026b03f3f90df2fca59187a83075175f/3c1ae/aws_connect.png 315w,
/static/026b03f3f90df2fca59187a83075175f/984b6/aws_connect.png 630w,
/static/026b03f3f90df2fca59187a83075175f/e7d8e/aws_connect.png 945w,
/static/026b03f3f90df2fca59187a83075175f/58c38/aws_connect.png 1260w,
/static/026b03f3f90df2fca59187a83075175f/a2afc/aws_connect.png 1914w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제 인스턴스가 잘 생성되었습니다. 연결 버튼을 눌러 터미널을 열어줍니다.&lt;/p&gt;
&lt;p&gt;이제 하단 명령어를 통해 제가 만든 서비스를 설치해 줍니다.
저는 git을 설치해서 해당 레포지토리를 클론한 뒤 서버를 실행시키는 방법을 사용하였습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ pwd
/home/ec2-user 뜨면 잘 연결된 겁니다🎉

$ sudo yum update y   // yum update를 해줍니다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;git을 설치해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ sudo yum install git -y

$ git --version
git version 2.34.1.windows.1  // git 버전이 잘 뜨면 성공🎉&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 git 레포지토리를 클론하여 가져옵니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;git clone https://github.com/본인깃허브아이디/레포지토리.git&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그럼 다음과 같이, username과 password를 입력합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;Username for &amp;#39;https://github.com&amp;#39;: 깃허브아이디
Password for &amp;#39;https://kirahaa@gmail.com&amp;#39;: &lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;패스워드는 &lt;strong&gt;github 로그인 &gt; Settings &gt; Developer settings &gt; Personal access tokens &gt; Generate New Token &gt; 필요항목 입력(repository만 체크) 후 Generate Token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;생성된 토큰을 &lt;strong&gt;Ctrl + shift + v&lt;/strong&gt; 해서 붙여넣기 해줍니다.&lt;/p&gt;
&lt;p&gt;이제 생성된 디렉토리를 확인해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ ls 
// 생성된 레포 뜸 ex) auth-with-jwt&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 디렉토리로 들어갑니다.&lt;/p&gt;
&lt;p&gt;자 이제, &lt;code&gt;npm install&lt;/code&gt;을 해서 패키지들을 설치해 주어야 하는데,&lt;br/&gt;
npm을 입력하면 &lt;code&gt;-bash: npm: command not found&lt;/code&gt;라고 뜰 것입니다.&lt;br/&gt;
그럼 다음 명령어들을 순서대로 쳐줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash

$ . ~/.nvm/nvm.sh

$ nvm install node&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 node를 설치해야 하는데, &lt;code&gt;nvm install node&lt;/code&gt;하면 에러가 뜰 것입니다.&lt;br/&gt;
버전 문제 때문에 다음과 같이 16버전을 다운받아 주어야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;nvm install 16&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;node가 잘 설치되었나 버전 확인을 해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;node -v&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 &lt;code&gt;package.json&lt;/code&gt; 내 패키지들을 설치해 줍니다.&lt;/p&gt;
&lt;p&gt;여기서 잠깐! git에는 mongodb 정보가 담겨있는 &lt;code&gt;config.js&lt;/code&gt;파일이 제외되어 있어서, 새로 만들어줘야 했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ cat &amp;gt; config.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 명령어를 통해 파일 생성이 되면 내용을 바로 입력할 수 있습니다.
(참고: &lt;a href=&quot;https://heytech.tistory.com/33&quot;&gt;https://heytech.tistory.com/33&lt;/a&gt;)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  &amp;#39;secret&amp;#39;: &amp;#39;SeCrEtKeYfOrHaShInG&amp;#39;,
  &amp;#39;mongodbUri&amp;#39;: &amp;#39;mongodb+srv://&amp;lt;본인 아이디&amp;gt;:&amp;lt;패스워드&amp;gt;@mycluster.likcia7.mongodb.net/?retryWrites=true&amp;amp;w=majority&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 저장 및 종료
키보드 control과 z 버튼 동시에 눌러주기.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;괄호가 잘 안닫혔는지, &lt;code&gt;node app.js&lt;/code&gt; 명령어를 실행해 주었더니, 오류가 떴습니다.😥&lt;br/&gt;
그래서 다시 &lt;code&gt;config.js&lt;/code&gt; 파일 수정해주기!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 편집 및 저장
// 편집 명령어
$ vi 파일명.확장자명&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;명령어 입력 후 엔터를 눌러주면 기존에 저장한 내용이 나옵니다.&lt;br/&gt;
확인해보니 역시 닫는 괄호가 잘 안 닫혀있어, 파일을 수정해 줍니다.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;편집을 모두 마쳤다면, 키보드 &lt;code&gt;ESC&lt;/code&gt;를 눌러 편집 기능을 비 활성화 해줍니다.&lt;br/&gt;
이제 마지막으로 &lt;code&gt;:wq&lt;/code&gt;를 입력하고 &lt;code&gt;Enter&lt;/code&gt;를 눌러주면 파일이 저장되고 터미널로 화면이 전환됩니다.&lt;br/&gt;
이제 다시 &lt;code&gt;node app.js&lt;/code&gt; 명령어를 통해 서버를 실행해 줍니다!🎉&lt;/p&gt;
&lt;h2&gt;8) 인바운드 규칙 추가&lt;/h2&gt;
&lt;p&gt;이제 마지막 단계입니다!&lt;/p&gt;
&lt;p&gt;퍼블릭 IPv4 주소인 &lt;strong&gt;13.209.42.233&lt;/strong&gt;으로 접속했더니 잘 되지 않습니다.&lt;br/&gt;
그건 저희가 포트 3000번에 열었기 때문인데요, 그래서 &lt;strong&gt;13.209.42.233:3000&lt;/strong&gt;으로 접속해 줍니다.
그래도 아마 접속이 안될 것입니다ㅠㅠ&lt;/p&gt;
&lt;p&gt;자 이제 다시 aws 인스턴스 페이지로 돌아가서 왼쪽 메뉴에서 &lt;strong&gt;네트워크 및 보안 &gt; 보안 그룹&lt;/strong&gt;에 들어갑니다.&lt;/p&gt;
&lt;p&gt;해당 인스턴스 이름을 클릭한 뒤, 하단에 보이는 &lt;strong&gt;인바운드 규칙 &gt; 인바운드 규칙 편집&lt;/strong&gt;을 눌러 포트를 새로 추가해 줍니다.&lt;/p&gt;
&lt;p&gt;현재 제 인바운드 리스트에는 세가지가 있는데요.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;유형&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;프로토콜&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;포트 범위&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;소스&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;SSH&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;22&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0.0.0.0/0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;HTTP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;80&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0.0.0.0/0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;사용자 지정 TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;TCP&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3000&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;0.0.0.0/0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;이렇게 추가해 주시면 됩니다.&lt;/p&gt;
&lt;p&gt;그럼 이제 주소창에 &lt;strong&gt;13.209.42.233:3000&lt;/strong&gt;을 입력하면&lt;/p&gt;
&lt;p&gt;aws 서버 만들기 완료입니다!!🎉🎉🎉&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a7fe00ef919ef6004ae0107993311ff7/f6862/aws_complete.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.46835443037975%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAWklEQVR42uWQOw6AMAxDc/8zZupCp5aFKJ/BqFQdEVDYGN5mP1kmVcXAzODuU4S3roKWnMHMSCmhlDIt7ARIZEOtK0TkpaxDx9yI00C7YVxyW3iJPVz4JT8U7hDDwWrRLt6/AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;aws complete&quot;
        title=&quot;&quot;
        src=&quot;/static/a7fe00ef919ef6004ae0107993311ff7/984b6/aws_complete.png&quot;
        srcset=&quot;/static/a7fe00ef919ef6004ae0107993311ff7/4d6f2/aws_complete.png 158w,
/static/a7fe00ef919ef6004ae0107993311ff7/3c1ae/aws_complete.png 315w,
/static/a7fe00ef919ef6004ae0107993311ff7/984b6/aws_complete.png 630w,
/static/a7fe00ef919ef6004ae0107993311ff7/e7d8e/aws_complete.png 945w,
/static/a7fe00ef919ef6004ae0107993311ff7/58c38/aws_complete.png 1260w,
/static/a7fe00ef919ef6004ae0107993311ff7/f6862/aws_complete.png 1917w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;➕ 이후 찾은 문제점&lt;br/&gt;&lt;/h3&gt;
&lt;p&gt;위 과정으로 aws 인스턴스가 잘 만들어졌다고 생각했는데, 서버가 자꾸 끊기는 문제가 발생했습니다.&lt;br/&gt;
아직 정확한 문제를 찾지는 못했으나, ec2의 t2.micro의 작은 메모리이다 보니, 끊기는 것은 어쩔 수 없는 문제인가 봅니다..&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;에필로그&lt;/h3&gt;
&lt;p&gt;여기까지 node.js의 express를 활용한 jwt 인증 구현을 해보았는데요, 사실 이번에는 튜토리얼 영상을 보며 코드를 따라친 느낌이라 그냥 찍먹한 느낌입니다..ㅎㅎ&lt;/p&gt;
&lt;p&gt;그래도 데이터베이스도 직접 만져보고, aws 인스턴스도 만들어보고 찍먹러로써는 정말 좋은 경험이었습니다! &lt;br/&gt;
하나의 프로젝트의 처음부터 끝까지 경험해보고 싶다면 추천합니다! 👍&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;참고 자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=_bu6etIS_bo&quot;&gt;https://www.youtube.com/watch?v=_bu6etIS_bo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://makethree.tistory.com/4&quot;&gt;https://makethree.tistory.com/4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Node.js + Express + JWT 인증 시스템 구현하기(feat. MongoDB)]]></title><description><![CDATA[Node.js와 Express, Mongodb를 이용한 JWT 토큰 기반 인증 시스템을 구현 한 뒤, AWS ec2를 통해 배포한 내용을 정리하였습니다. 1. 프로젝트 생성 및 설정하기 새로운 디렉토리를 만든 후, package.json…]]></description><link>https://kirahaa.github.io/node-express-jwt-auth/</link><guid isPermaLink="false">https://kirahaa.github.io/node-express-jwt-auth/</guid><pubDate>Fri, 14 Jul 2023 13:57:56 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Node.js와 Express, Mongodb를 이용한 JWT 토큰 기반 인증 시스템을 구현 한 뒤, AWS ec2를 통해 배포한 내용을 정리하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;1. 프로젝트 생성 및 설정하기&lt;/h2&gt;
&lt;p&gt;새로운 디렉토리를 만든 후, package.json 파일을 다음과 같이 설정해주고, &lt;code&gt;npm install&lt;/code&gt; 명령어를 통해 프로젝트에 필요한 모듈을 설치해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  &amp;quot;name&amp;quot;: &amp;quot;express-jwt-auth&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;auth with express jwt&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;bcrypt&amp;quot;: &amp;quot;^5.0.0&amp;quot;,
    &amp;quot;cookie-parser&amp;quot;: &amp;quot;^1.4.5&amp;quot;,
    &amp;quot;ejs&amp;quot;: &amp;quot;^3.1.3&amp;quot;,
    &amp;quot;express&amp;quot;: &amp;quot;^4.17.1&amp;quot;,
    &amp;quot;jsonwebtoken&amp;quot;: &amp;quot;^8.5.1&amp;quot;,
    &amp;quot;mongoose&amp;quot;: &amp;quot;^5.9.23&amp;quot;,
    &amp;quot;validator&amp;quot;: &amp;quot;^13.1.1&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node app.js&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;auth&amp;quot;,
    &amp;quot;express&amp;quot;,
    &amp;quot;jwt&amp;quot;
  ],
  &amp;quot;author&amp;quot;: &amp;quot;hayeong&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;디렉토리 구조&lt;/h3&gt;
&lt;p&gt;프로젝트에서 사용할 디렉토리 구조는 다음과 같습니다.
페이지 템플릿은 &lt;code&gt;ejs&lt;/code&gt;를 사용하였습니다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;├─ .gitignore
├─ README.md
├─ app.js
├─ config.example.js
├─ controllers
│  └─ authController.js
├─ middleware
│  └─ authMiddleware.js
├─ models
│  └─ User.js
├─ package.json
├─ public
│  └─ style.css
├─ routes
│  └─ authRoutes.js
└─ views
   ├─ detail.ejs
   ├─ home.ejs
   ├─ login.ejs
   ├─ partials
   │  ├─ footer.ejs
   │  └─ header.ejs
   └─ signup.ejs&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;©generated by &lt;a href=&quot;https://woochanleee.github.io/project-tree-generator&quot;&gt;Project Tree Generator&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;app.js 세팅하기&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js
const express = require(&amp;#39;express&amp;#39;);
const mongoose = require(&amp;#39;mongoose&amp;#39;);

const config = require(&amp;#39;./config&amp;#39;)

const app = express();

// middleware
app.use(express.static(&amp;#39;public&amp;#39;));

// view engine
app.set(&amp;#39;view engine&amp;#39;, &amp;#39;ejs&amp;#39;);

mongoose.connect(config.mongodbUri)
const db = mongoose.connection
db.on(&amp;#39;error&amp;#39;, console.error)
db.once(&amp;#39;open&amp;#39;, ()=&amp;gt;{
    console.log(&amp;#39;connected to mongodb server&amp;#39;)
    app.listen(3000)
})

// routes
app.get(&amp;#39;/&amp;#39;, (req, res) =&amp;gt; res.render(&amp;#39;home&amp;#39;));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;config.js&lt;/code&gt; 파일은 프로젝트에서 사용할 MongoDB 서버의 정보와, JWT 토큰을 만들 때 사용될 &lt;code&gt;secret&lt;/code&gt; 키의 정보를 지니고 있습니다.&lt;/p&gt;
&lt;p&gt;보안에 관련된 정보는 따로 파일에 분리하여 관리하는 것이 좋습니다.
github 저장소에도 &lt;code&gt;config.js&lt;/code&gt; 파일은 &lt;code&gt;.gitignore&lt;/code&gt;에 추가해서 커밋이 되지 않도록 설정합니다.
예제 정보가 적혀있는 &lt;code&gt;config.example.js&lt;/code&gt; 파일의 이름을 &lt;code&gt;config.js&lt;/code&gt;로 수정하고 사용합니다.
설정 파일을 작성하기 전에, MongoDB 서버를 만들어 봅시다.&lt;/p&gt;
&lt;h2&gt;2. MongoDB 준비&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB 홈페이지&lt;/a&gt;에 들어가서 회원가입을 해 줍니다.&lt;br/&gt;
새로운 프로젝트를 만들고 새로운 클러스터를 만듭니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f2c905606f20f08dad165fad974c1fa9/9caaa/mongodb_1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.202531645569614%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABTklEQVR42oWS3W4VIRSF5/2fxBfwAbzyRi+MNyYmtqYxaU87TGf42xvYfAZOzrGapi6yMgOEzbeAZYuemDJpuAheEiqClkKzRv9P01rIRUkiiCrL/e54OnZa7/zcPD/czmlPBMlkVXrvbxvOto41Y/m+3nPrHatEnD9w3vPod9wgL8JbGgWHbtcH3n36wMebbyynzXHkSLVGbUapDVWdkYdHjOFa65XqgjWohn49r7z/+pkvdzcsj84RUqJZRWsnqhEl4WO8+jzf/qZ70QyjtI4ZLA/bOgn/XfBSpVZ8zPiQiClhZvRX4lvvI/JGzGlGfk3NDCmVI1V8UkSU1ux6fn+Iz0WXk3Nsxz4pQjpHjHncsHCEMPuicnbRSXh4jw+BmIUjpvkd64eXp23jOQZqq/MtjfMahUJO+BTn/9jgstEYv4xFUXxWguh8j7U1fgN2Yb6VbYCypwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;make new cluster in mongodb&quot;
        title=&quot;&quot;
        src=&quot;/static/f2c905606f20f08dad165fad974c1fa9/984b6/mongodb_1.png&quot;
        srcset=&quot;/static/f2c905606f20f08dad165fad974c1fa9/4d6f2/mongodb_1.png 158w,
/static/f2c905606f20f08dad165fad974c1fa9/3c1ae/mongodb_1.png 315w,
/static/f2c905606f20f08dad165fad974c1fa9/984b6/mongodb_1.png 630w,
/static/f2c905606f20f08dad165fad974c1fa9/e7d8e/mongodb_1.png 945w,
/static/f2c905606f20f08dad165fad974c1fa9/58c38/mongodb_1.png 1260w,
/static/f2c905606f20f08dad165fad974c1fa9/9caaa/mongodb_1.png 2874w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저는 &lt;code&gt;Project 0&lt;/code&gt;의 &lt;code&gt;myCluster&lt;/code&gt;란 이름의 클러스터를 만들어 주었습니다.&lt;/p&gt;
&lt;h3&gt;데이터 베이스 만들기&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Browse Collections &gt; add my own data&lt;/strong&gt;에서 새로운 데이터 베이스를 생성합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0fce7eaf88640a4114d10bcb5b96e403/f621c/mongodb_2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 48.10126582278481%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACAUlEQVR42n2SS2sTURiG8y8FE5smk3vakHYyk7lP0napuFaKUSuohbSQpRsX7rSCWkttWkQkVVDT2NDQC9M88p20RUU8cJgzw5z3e28xzfTQDI9s3UfOGdMnVw/IWyEFu/HfLf9kzYBsPSBj+JS9RWJp3aVgNZg2fOK6S9oISNcCNMMnL8B2qC7KkH8NKl48s6bPjAAmdBvN9NWe0h1Shk9yzuH28gPe7+zy6u0mr99tsfmhS/fjJ27eaZHSHYpOU7ETZqJQq3mU3UViSd1RYDJdZBecBlNVi0drHUZHI/r9A06Oj4mic2S1VteIVwxKTvOKtex0zVXfYpmaR74eKu9S8w5azeVGxWRlrcPXwYjewZDh2ZgfRyecKcB1pqp1Sm7zSnbG8EhWLYp2c+LhBFDCcZVHcuFhu0OvP2Tvy3f6o1MOTyMiYPlJm+szNXLK1/CCaaiIzHhLxLQLhmnTI2cHlL0FJXml3eFwOORzb5+DwYAoipTke0/bJGYNFUbODIhXTRJzFtNzNiVngVh63lUTLtMruQuKoXgo63w8hjF8+zng5f4u91fXiSvAJnkz4NqsTqJqkTXDScoCKAwv/RAJkqKkvNXd483WNpvbO7zY2ODx82fcuttSbC57WLKbE7b1YCJZaMvL36WVskodpBZSj4IVUvGWlJo/yv1byYXhLw/sDdyHZaEEAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;make database in mongodb&quot;
        title=&quot;&quot;
        src=&quot;/static/0fce7eaf88640a4114d10bcb5b96e403/984b6/mongodb_2.png&quot;
        srcset=&quot;/static/0fce7eaf88640a4114d10bcb5b96e403/4d6f2/mongodb_2.png 158w,
/static/0fce7eaf88640a4114d10bcb5b96e403/3c1ae/mongodb_2.png 315w,
/static/0fce7eaf88640a4114d10bcb5b96e403/984b6/mongodb_2.png 630w,
/static/0fce7eaf88640a4114d10bcb5b96e403/e7d8e/mongodb_2.png 945w,
/static/0fce7eaf88640a4114d10bcb5b96e403/58c38/mongodb_2.png 1260w,
/static/0fce7eaf88640a4114d10bcb5b96e403/f621c/mongodb_2.png 2878w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;저는 데이터 베이스 이름을 &lt;code&gt;node-auth&lt;/code&gt;로 설정하고, collection 이름을 &lt;code&gt;users&lt;/code&gt;로 설정하였습니다.&lt;br/&gt;
설정이 끝나면 &lt;strong&gt;Connect &gt; Connect to your application &gt; Drivers&lt;/strong&gt; 해당 데이터 베이스에 연결하면 하단에 &lt;strong&gt;application code&lt;/strong&gt;가 나옵니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a76ab49290854c5fad78ba9fdfb20274/a58ca/mongodb_3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.89873417721519%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGUlEQVR42mWSyW4TQRRF+/tYsWCD2KCwQMSZbHe7J/fk+HdYAd6Q4HbyIYgkKHFit93ueTyoKyRE4klPqnoqnbr36Uq6YWCYJrZtM5CHfJ3NuH9YcXV1za+ra5bLe7abDZtgQ7Bei16vVkRRxGw2Q1U1LNvGMAwc10EaqCMUXcPxPD70DjnzF3R1F2+Iy5y2bYnrgrDMxLy7Z2UpzovFAk3TmEwmTFyP6ekU6WikcKJraLbFwfERc98nTBJ+3txwfXtHsA3Jq5K0yKmbhqZpSPNcAH3fxzQMjpQhr/fe8bF/iKSoKrpp4noesqww9xckaS5s3y0fiKKYsiyFsqfqoE8KDV1nZOq8P9xnoKlII1UTO3Rdl+PBkPP5gqZtyfOcXZxQlBV1U1PV9TPoJVBVVRzXZWw5nHaWZXX0qND12O/1+H52xnYX8fv2ll0cU1YVnbjO7pPKl0BZlrEsG8uy8CYekjzqLI/xPI9Xb9/w+dsX8XgbJ2RFSdm0VE0rVFed0qamqMrnHWqajuN6jC0bbzJBGsgKqhi6fDrocT73SUtYBhHrMGEdpgRhQpbl/+3wx9znpC9jjC3M8ViAJU3XheUOOBgMWVxckBUF62BDGEXESUKapsRpSl4UwnpVV3+Bc2RFETnsLE+nU6Qu2KY1xnYc+v0+F5eXFG3Dchuw3e2Is4wwT0iyTHT3WZT9y6GuP+ZQ0w329g/4A2A1hlEen3jlAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Connect to cluster in mongodb&quot;
        title=&quot;&quot;
        src=&quot;/static/a76ab49290854c5fad78ba9fdfb20274/984b6/mongodb_3.png&quot;
        srcset=&quot;/static/a76ab49290854c5fad78ba9fdfb20274/4d6f2/mongodb_3.png 158w,
/static/a76ab49290854c5fad78ba9fdfb20274/3c1ae/mongodb_3.png 315w,
/static/a76ab49290854c5fad78ba9fdfb20274/984b6/mongodb_3.png 630w,
/static/a76ab49290854c5fad78ba9fdfb20274/e7d8e/mongodb_3.png 945w,
/static/a76ab49290854c5fad78ba9fdfb20274/58c38/mongodb_3.png 1260w,
/static/a76ab49290854c5fad78ba9fdfb20274/a58ca/mongodb_3.png 2876w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;application code 예시&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mongodb+srv://&amp;#x3C;본인 아이디&gt;:&amp;#x3C;패스워드&gt;@mycluster.likcia7.mongodb.net/?retryWrites=true&amp;#x26;w=majority&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3. MongoDB 연결하기&lt;/h2&gt;
&lt;h3&gt;config.js 세팅하기&lt;/h3&gt;
&lt;p&gt;위에서 생성한 &lt;strong&gt;application code&lt;/strong&gt;를 복사 붙여넣기 해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  &amp;#39;secret&amp;#39;: &amp;#39;SeCrEtKeYfOrHaShInG&amp;#39;,
  &amp;#39;mongodbUri&amp;#39;: &amp;#39;mongodb+srv://&amp;lt;본인 아이디&amp;gt;:&amp;lt;패스워드&amp;gt;@mycluster.likcia7.mongodb.net/?retryWrites=true&amp;amp;w=majority&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;secret&lt;/code&gt; 키는 이후에 JWT 토큰을 검증하는 서명 부분에 사용할 비밀 키입니다. 보안에 연관된 정보들은 config.js 파일에 보관해 줍니다.&lt;/p&gt;
&lt;p&gt;여기까지 코드작성이 완료되었다면, 터미널에서 &lt;code&gt;node app.js&lt;/code&gt;를 입력하여 서버를 실행할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;gt; node app.js

connected to mongodb server // 이렇게 뜨면 성공! 🎉&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;4. 본격 API 만들기&lt;/h2&gt;
&lt;h3&gt;Auth Routes&lt;/h3&gt;
&lt;p&gt;인증에 관련된 라우터를 구성해 줍니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;route&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;request&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/signup&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;sign up page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/login&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;login page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/signup&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;POST&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;create a new user in db&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/login&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;POST&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;authenticate a current user&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;/logout&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;GET&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;logout page&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;authRoutes.js&lt;/code&gt; 파일을 생성한 후, 다음과 같이 라우터를 설정해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// routes/authRoutes.js
const { Router } = require(&amp;#39;express&amp;#39;);

const router = Router();

router.get(&amp;#39;/signup&amp;#39;, () =&amp;gt; {});
router.post(&amp;#39;/signup&amp;#39;, () =&amp;gt; {});
router.get(&amp;#39;/login&amp;#39;, () =&amp;gt; {});
router.post(&amp;#39;/login&amp;#39;, () =&amp;gt; {});
router.get(&amp;#39;/logout&amp;#39;, () =&amp;gt; {})

module.exports = router;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;컨트롤러&lt;/h3&gt;
&lt;p&gt;이제 각각의 기능을 구현할 컨트롤러를 만들어 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// controllers/authController.js

module.exports.signup_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;signup&amp;#39;)
}

module.exports.login_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;login&amp;#39;)
}

module.exports.signup_post = (req, res) =&amp;gt; {
	res.send(&amp;#39;new signup&amp;#39;)
}

module.exports.login_post = (req, res) =&amp;gt; {
	res.send(&amp;#39;user login&amp;#39;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;구성한 컨트롤러를 router에 연결합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// routes/authRoutes.js

const {Router} = require(&amp;#39;express&amp;#39;);
const authController = require(&amp;#39;../controllers/authController&amp;#39;);

const router = Router();

router.get(&amp;#39;/signup&amp;#39;, authController.signup_get);
router.post(&amp;#39;/signup&amp;#39;, authController.signup_post);
router.get(&amp;#39;/login&amp;#39;, () =&amp;gt; authController.login_get);
router.post(&amp;#39;/login&amp;#39;, () =&amp;gt; authController.login_post);


module.exports = router;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;에도 이 라우터들을 연결해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...
const authRoutes = require(&amp;#39;./routes/authRoutes&amp;#39;);
...

app.use(authRoutes);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;5. Postman을 이용한 API 테스트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.postman.com/&quot;&gt;Postman&lt;/a&gt;은 프론트엔드가 구현되기 전에 서버에 대한 요청을 시뮬레이션할 수 있는 플랫폼입니다.&lt;br/&gt;
이를 통해 개발한 API를 테스트하고, 테스트 결과를 공유하여 API 개발의 생산성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f6d933c1ad2dcad32db2f3e6bacb358e/f9c26/postman.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.26582278481012%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABf0lEQVR42pVSy47UMBDMT3BjFL8dP5I4yTjZeIEs3JA48zH8fKF2dqJBggOHkl3q7nJ1t5uUEuZpgrUW3ntM0wTnHJRSEFJCKgVjDKYxYh4itJLgQoC3N7D0BjkWpGgRNENnDRrvA3xM6Pu+ClXhECofhqFyEpdSQGtV7yc0JLvBGQkTZ4hPPyHDjCbnjLTcsb1s2LYN5DgNA8K76DiO9YGu6y6QY601lLbVsYwZH3/8AusLmnleEKJDKTuO4w3DOMIaDWsN2rYFY6yijkCIi9OdRBnjYO0N+vYBirdoKNE4i7yu2PcdMUZwzmsBnQ/8jVPtyQWEpAclGrLfeYdlWTDPc22Jkh5OCM9CFYzwHmP8yqezClpncc+5OiTR4B1c19WFUPxcirwEafNSK0ianz5/AsXJdaOVge80XtYVpZTqNHhfN26svURpXs/tPsDFyS9BFz1CirjvGeX1Feu61qLnhfyz9Sc8FtXcvxWs3z+jPzK+fD1wHMcfbv4HJPgbj0Mjf3elS8EAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Postman&quot;
        title=&quot;&quot;
        src=&quot;/static/f6d933c1ad2dcad32db2f3e6bacb358e/984b6/postman.png&quot;
        srcset=&quot;/static/f6d933c1ad2dcad32db2f3e6bacb358e/4d6f2/postman.png 158w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/3c1ae/postman.png 315w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/984b6/postman.png 630w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/e7d8e/postman.png 945w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/58c38/postman.png 1260w,
/static/f6d933c1ad2dcad32db2f3e6bacb358e/f9c26/postman.png 2880w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Postman을 통해 생성한 api 주소로 각 요청을 보내 연결이 잘 되는지 확인할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;6. model&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mongoose&lt;/code&gt;를 통해 유저 정보를 MongoDB에 넣을때, 스키마를 만들어야 합니다.&lt;br/&gt;
스키마란 기본적으로 데이터베이스에서 사용자 데이터나 기록이 어떻게 표시되어야 하는지를 정의합니다.&lt;br/&gt;
해당 파트에서 유효성 문구 등을 직접 설정할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// models/User.js

const mongoose = require(&amp;#39;mongoose&amp;#39;);
const { isEmail } = require(&amp;#39;validator&amp;#39;);

const userSchema = new mongoose.Schema({
	email: {
		type: String,
		required: [true, &amp;#39;Please enter an email&amp;#39;],
		unique: true,
		lowercase: true,
		validate: [isEmail, &amp;#39;Please enter a valid email&amp;#39;]
	},
	password: {
		type: String,
		required: [true, &amp;#39;Please enter a password&amp;#39;],
		minlength: [6, &amp;#39;Minimum password length is 6 characters&amp;#39;]
	},
});

const User = mongoose.model(&amp;#39;user&amp;#39;, userSchema);

module.exports = User;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다시 컨트롤러로 돌아가서 유저 모델을 연결해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// controllers/authController.js
const User = require(&amp;#39;../models/User&amp;#39;);

// handle errors
const handleErrors = (err) =&amp;gt; {
	console.log(err.message, err.code);
	let error = { email: &amp;#39;&amp;#39;, password: &amp;#39;&amp;#39;};

	// duplicate error code
	if (err.code === 11000) {
		errors.email = &amp;#39;that email is aleady registered&amp;#39;;
		return errors;
	}

	// validation errors
	if (err.message.includes(&amp;#39;user validation failed&amp;#39;)) {
		Object.values(err.errors).forEach(({properties}) =&amp;gt; {
			error[properties.path] = properties.message;
		})
	}

	return errors;
}

module.exports.signup_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;signup&amp;#39;)
}

module.exports.login_get = (req, res) =&amp;gt; {
	res.render(&amp;#39;login&amp;#39;)
}

module.exports.signup_post = async (req, res) =&amp;gt; {
	const {email, password} = req.body;

	try {
		const user = await User.create({ email, password }); // 유저 생성
		res.status(201).json(user);
	}
	catch (err) {
		const errors = handleErrors(err);
		res.status(400).json({errors})
	}
}

module.exports.login_post = async (req, res) =&amp;gt; {
	const {email, password} = req.body;

	console.log(email, password);
	res.send(&amp;#39;user login&amp;#39;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;비밀번호 해시처리&lt;/h3&gt;
&lt;p&gt;현재 유저정보가 DB에 잘 쌓이고 있는데, 비밀번호가 그대로 드러나고 있습니다.&lt;br/&gt;
이를 방지하기 위해, &lt;code&gt;bcrypt&lt;/code&gt; 라이브러리를 사용하여 비밀번호를 암호화 시켜줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// User.js

const mongoose = require(&amp;#39;mongoose&amp;#39;);
const { isEmail } = require(&amp;#39;validator&amp;#39;);
const bcrypt = require(&amp;#39;bcrypt&amp;#39;);

const userSchema = new mongoose.Schema({
	email: {
		type: String,
		required: [true, &amp;#39;Please enter an email&amp;#39;],
		unique: true,
		lowercase: true,
		validate: [isEmail, &amp;#39;Please enter a valid email&amp;#39;]
	},
	password: {
		type: String,
		required: [true, &amp;#39;Please enter a password&amp;#39;],
		minlength: [6, &amp;#39;Minimum password length is 6 characters&amp;#39;]
	},
});

// fire a function before doc saved to db
userSchema.pre(&amp;#39;save&amp;#39;, async function (next) {
	const salt = await bcrypt.genSalt();
	this.password = await bcrypt.hash(this.password, salt);
	
	next();
})

const User = mongoose.model(&amp;#39;user&amp;#39;, userSchema);

module.exports = User;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;데이터가 저장되기 전에(&lt;code&gt;pre&lt;/code&gt;) 비밀번호를 해시 처리해서 암호화 시켜줍니다.&lt;/p&gt;
&lt;h3&gt;Cookies&lt;/h3&gt;
&lt;p&gt;쿠키는 클라이언트 개개인의 상태 정보를 담고 있는 데이터입니다.&lt;br/&gt;
다음과 같은 방법으로 브라우저에 쿠키를 생성할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js

// cookies
app.get(&amp;#39;/set-cookies&amp;#39;, (req, res) =&amp;gt; {
	res.setHeader(&amp;#39;Set-Cookie&amp;#39;, &amp;#39;newUser=true&amp;#39;);
	// 또는
	res.cookie(&amp;#39;newUser&amp;#39;, false);
	
	res.send(&amp;#39;you got the cookies!&amp;#39;);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 여기서 주의할 점!&lt;/p&gt;
&lt;p&gt;쿠키는 javascript의 document.cookie를 통해 접근할 수 있기 때문에, 해킹 당할 위험이 있다.
이를 보호하기 위해 HttOnly나 Secure 속성을 설정할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;res.cookie(&amp;#39;test&amp;#39;, true, { httpOnly: true })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 httpOnly 옵션을 추가하면, 클라이언트의 환경(웹 브라우저)에서 스크립트(javascript 등)로 쿠키에 접근하는 것을 차단할 수 있다. 이 설정을 함으로써 XSS(Cross Site Script) 공격에 대응이 가능하다.&lt;/p&gt;
&lt;p&gt;추가로, 쿠키의 만료날짜를 설정할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const maxAge = 60 * 60 * 24 * 2;  // 60초 * 60분 * 24시간 * 2일

res.cookie(&amp;#39;jwt&amp;#39;, token, { httpOnly: true, maxAge: maxAge * 1000 })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;7. JSON Web Tokens&lt;/h2&gt;
&lt;p&gt;JWT(JSON Web Token)란 &lt;strong&gt;인증에 필요한 정보들을 암호화시킨 JSON 토큰&lt;/strong&gt;을 의미합니다.&lt;br/&gt;
그리고 JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식입니다.&lt;br/&gt;
JWT는 .을 구분자로 나누어지는 세 가지 문자열의 조합입니다.&lt;br/&gt;
.을 기준으로 &lt;code&gt;Header&lt;/code&gt;, &lt;code&gt;Payload&lt;/code&gt;, &lt;code&gt;Signature&lt;/code&gt;로 구성되어 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a688b3536a0be435f268132ae32083a2/7e08f/jsonwebtoken.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB7ElEQVR42mWS204bMRBA+RhYjz2+7C3XTUIpIoQgQi5tIpUi9f9/4lTetISqD2dn5ZGPPeO5KsTxlxtxXIv9FM9c8vlfKaynsHrm0/7MVf6YP4KRSfwsOnZmzFsxZS1jHsKOlT+c0T3taku7OzE8vNFujkhquCnkX+H5RlmsrM2Qb2bC1owZ2Mg0PLAOJ+7Dhqne4b8uqQ+/KDcn0tOeQgPXxlyEWWZFiaJ4sSSjVOJJ4vHGEiUxkI5GRpSmxZuKpBOitERpiFITpMaI58ZYrnKppSRe3TObnnXPzr2wtU/Mxs9MZyduZ2/cdj/ouiOL6Yl5ZrRnMT3SDXdYCX2Pzz3UQOUbWh1QaoMLFdaXJD+mSh0xjZBYUsRA4T2mTEg7PFM3mOAR9eeSjVV8LJlpw522jLQiphrrPcM440taMYm3eF8SywoNJWEwo75/JU3v8NUAmx2hJLt6ofORoSQ6qZhIiQuR4GpGuqDVjrkuGegcq0pcrKhf3ilXR8L8kbBYYasRLlYXodXAoIjMTEljAoXmB6p58Fse/Z5teKeyY4wV3HBBevxOXB5IywNh8YQJNdaFi1B9xKjnRn0fNaS+xHyQ04TT2Pcol5Vvktetj30UI1iXq0yXOcwTb/7D9RR/+FgX95E74z9yeWx+AxitWTHNxlT2AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;jsonwebtoken&quot;
        title=&quot;&quot;
        src=&quot;/static/a688b3536a0be435f268132ae32083a2/984b6/jsonwebtoken.png&quot;
        srcset=&quot;/static/a688b3536a0be435f268132ae32083a2/4d6f2/jsonwebtoken.png 158w,
/static/a688b3536a0be435f268132ae32083a2/3c1ae/jsonwebtoken.png 315w,
/static/a688b3536a0be435f268132ae32083a2/984b6/jsonwebtoken.png 630w,
/static/a688b3536a0be435f268132ae32083a2/e7d8e/jsonwebtoken.png 945w,
/static/a688b3536a0be435f268132ae32083a2/7e08f/jsonwebtoken.png 1186w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Header&lt;/code&gt; 에는 JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있으며, &lt;code&gt;Payload&lt;/code&gt; 는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있습니다. &lt;code&gt;Signature&lt;/code&gt;에는 Header, Payload 를 Base64 URL-safe Encode를 한 이후 Header에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// controllers/authController.js
...
const jwt = require(&amp;#39;jsonwebtoken&amp;#39;);
...

const maxAge = 3 * 24 * 60 * 60;  // three days
const createToken = (id) =&amp;gt; {
	return jwt.sign({ id }, config.secret, {
		expiresIn: maxAge
	});
} 

...

module.exports.signup_post = async (req, res) =&amp;gt; {
	const {email, password} = req.body;

	try {
		const user = await User.create({ email, password });
		const token = createToken(user._id);
		res.cookie(&amp;#39;jwt&amp;#39;, token, { httpOnly: true, maxAge: maxAge * 1000 })
		res.status(201).json({ user: user._id });
	}
	catch (err) {
		const errors = handleErrors(err);
		res.status(400).json({errors})
	}
}
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;JWT를 이용한 인증 과정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.&lt;/li&gt;
&lt;li&gt;서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다.Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장할 수도 있음)API를 서버에 요청할때 &lt;strong&gt;Authorization header에 Access Token을 담아&lt;/strong&gt;서 보낸다.&lt;/li&gt;
&lt;li&gt;서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.&lt;/li&gt;
&lt;li&gt;클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용해서&lt;/li&gt;
&lt;li&gt;서버로부터 새로운 엑세스 토큰을 발급 받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;라우트 보호하기&lt;/h3&gt;
&lt;p&gt;요청에 jwt가 있는지 확인하고, jwt가 문제가 없는지 확인하는 과정입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// middleware/authMiddleware.js

const jwt = require(&amp;#39;jsonwebtoken&amp;#39;);

const config = require(&amp;#39;../config.js&amp;#39;);

const requireAuth = (req, res, next) =&amp;gt; {
	const token = req.cookies.jwt;
	
	// check json web token exists &amp;amp; is verified
	if (token) {
		jwt.verify(token, config.secret, (err, decodedToken) =&amp;gt; {
			if (err) {
				console.log(err.message);
				res.redirect(&amp;#39;/login&amp;#39;);
			} else {
				console.log(decodedToken);
				next();
			}
		})
	} else {
		res.redirect(&amp;#39;/login&amp;#39;);
	}
}

module.exports = { requireAuth }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;jwt 토큰이 없거나, 유효하지 않은 경우 login 페이지로 넘어가도록 리다이렉트 해 줍니다.&lt;/p&gt;
&lt;p&gt;유효한 토큰이 있는 경우에만 접근할 수 있는 페이지에 해당 middleware를 추가합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js

app.get(&amp;#39;/home&amp;#39;, requireAuth, (req, res) =&amp;gt; res.render(&amp;#39;home&amp;#39;));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;8. 로그아웃&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// AuthController.js

module.exports.logout_get = (req, res) =&amp;gt; {
	res.cookie(&amp;#39;jwt&amp;#39;, &amp;#39;&amp;#39;, { maxAge: 1 });
	res.redirect(&amp;#39;/&amp;#39;);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;로그아웃은 controller에서 jwt라는 키를 가진 쿠키를 지워줍니다.&lt;/p&gt;
&lt;h3&gt;현재 유저 확인&lt;/h3&gt;
&lt;p&gt;ejs는 서버로부터 받은 데이터를 가공하여 클라이언트에서 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이를 위해 변수를 초기화하는 미들웨어를 작성합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// authMiddleware.js

...

//check current user
const checkUser = (req, res, next) =&amp;gt; {
	const token = req.cookies.jwt;
	
	if (token) {
		jwt.verify(token, config.secret, async (err, decodedToken) =&amp;gt; {
			if (err) {
				console.log(err.message);
				res.locals.user = null;
				next();
			} else {
				console.log(decodedToken);
				let user = await User.findById(decodedToken.id);
				res.locals.user = user;
				next();
			}
		})
	} else {
		res.locals.user = null;
		next();
	}
}

module.exports = {requireAuth, checkUser};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;res.locals.[variable]&lt;/code&gt; 을 통해 클라이언트에 변수를 전달할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// app.js
const { requireAuth, checkUser } = require(&amp;#39;./middleware/authMiddleware&amp;#39;);

...
app.get(&amp;#39;*&amp;#39;, checkUser); // every single get request
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;app.js에 checkUser를 가져와 모든(&lt;code&gt;*&lt;/code&gt;) get request에서 현재 유저를 확인하는 코드를 추가합니다.&lt;/p&gt;
&lt;p&gt;여기서 생긴 궁금증!&lt;/p&gt;
&lt;h3&gt;middleware란 무엇인가?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;middleware의 사전적 정의&lt;/p&gt;
&lt;p&gt;미들웨어는 양 쪽을 연결하여 데이터를 주고 받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어, 네트워크를 통해서 연결된 여러 개의 컴퓨터에 있는 많은 프로세스들에게 어떤 서비스를 사용할 수 있도록 연결해 주는 소프트웨어를 말한다. 3계층 클라이언트/서버 구조에서 미들웨어가 존재한다. 웹 브라우저에서 데이터베이스로부터 데이터를 저장하거나 읽어올 수 있게 중간에 미들웨어가 존재하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;광범위한 설명이지만 다음 2개의 키워드가 미들웨어의 역할이라고 생각합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;양쪽을 연결&lt;/li&gt;
&lt;li&gt;중간에서의 매개 역할&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;큰 범위로 보면 매개체 간 연결해주는 레이어로써, 매개체는 클라이언트(사용자) - 서버, 서버 - 서버 간의 통신이 될 수도 있습니다.&lt;br/&gt;
통상적으로 기업에서 말하는 미들웨어 환경은 웹/어플리케이션 서버를 의미합니다.&lt;/p&gt;
&lt;p&gt;ejs 템플릿을 사용한 프론트 단은 따로 내용에 작성하지 않았습니다.&lt;/p&gt;
&lt;p&gt;모든 코드는 &lt;a href=&quot;https://github.com/kirahaa/auth-with-jwt&quot;&gt;github 레포지토리&lt;/a&gt; 참고 부탁드립니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;여기까지, JWT 인증 시스템 구현이 끝났습니다!&lt;br/&gt;
JWT 인증은 해도 해도 어려운 것 같아요😥 다음에는 REACT 환경에서 JWT 인증을 구현해 보는 것도 도전해 보기로!&lt;/p&gt;
&lt;p&gt;다음 포스팅에서는 AWS 프리티어를 이용해서 웹 호스팅 서버를 만드는 과정을 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;가보자고~!💨&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;참고 자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=SnoAwLP1a-0&amp;#x26;list=PL4cUxeGkcC9iqqESP8335DA5cRFp8loyp&quot;&gt;https://www.youtube.com/watch?v=SnoAwLP1a-0&amp;#x26;list=PL4cUxeGkcC9iqqESP8335DA5cRFp8loyp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://velopert.com/2448&quot;&gt;https://velopert.com/2448&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC&quot;&gt;https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daleseo.com/js-jwt/&quot;&gt;https://www.daleseo.com/js-jwt/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Gatsby 블로그 꾸미기]]></title><description><![CDATA[…]]></description><link>https://kirahaa.github.io/custom-gatsby-blog/</link><guid isPermaLink="false">https://kirahaa.github.io/custom-gatsby-blog/</guid><pubDate>Sat, 01 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;자, 이제 본격적으로 나만의 블로그를 예쁘게 꾸며볼 시간입니다!😆&lt;/p&gt;
&lt;p&gt;개츠비에는 워낙 다양한 플러그인들이 많아서 잘 활용해서 사용하면 많은 것들을 할 수 있습니다!&lt;br/&gt;
여러 테크 블로그들을 돌아다니면서 블로그 구조, 폰트, 코드 블록 등 다양한 디자인들을 참고해서 나에게 맞는 기능들만 쏙쏙 골라서 꾸며봅시다!✨&lt;/p&gt;
&lt;h2&gt;1. 코드 블록&lt;/h2&gt;
&lt;p&gt;다양한 테마의 코드 블록들 중에서 저는 iOS UI의 vsCode를 고대로 옮겨놓은 듯한 코드 블록들이 눈길이 가더라구요!&lt;/p&gt;
&lt;h3&gt;설치하기&lt;/h3&gt;
&lt;p&gt;가장 간단한 방법은 &lt;a href=&quot;https://docs.deckdeckgo.com/?path=/docs/components-highlight-code--highlight-code&quot;&gt;해당 페이지&lt;/a&gt;를 참고하면 손쉽게 예쁜 코드 블록을 불러올 수 있습니다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install @deckdeckgo/highlight-code&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;적용하기&lt;/h3&gt;
&lt;p&gt;이제 &lt;code&gt;layout.js&lt;/code&gt;에서 해당 패키지를 불러오면 됩니다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { defineCustomElements as deckDeckGoHighlightElement } from &amp;quot;@deckdeckgo/highlight-code/dist/loader&amp;quot;

// ... 생략

deckDeckGoHighlightElement()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;2. 폰트&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/plugins/gatsby-omni-font-loader/&quot;&gt;gatsby-omni-font-loader&lt;/a&gt; 플러그인을 통해 웹폰트나 커스텀 폰트를 적용할 수 있습니다!&lt;/p&gt;
&lt;h3&gt;설치하기&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install gatsby-omni-font-loader react-helmet&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;적용하기&lt;/h3&gt;
&lt;p&gt;잘 설치가 되었다면, &lt;code&gt;gatsby-config.js&lt;/code&gt; 파일에 사용하고 싶은 폰트들을 가져오면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;plugins: [
    {
      resolve: `gatsby-omni-font-loader`,
      options:{
        enableListener: true,
        preconnect: [`https://fonts.googleapis.com`, `https://fonts.gstatic.com`],
        web: [
          {
            name: `Inter`,
            file: `https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800&amp;amp;display=swap`,
          },
          {
            name: `Pretendard`,
            file: `https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard-dynamic-subset.css`,
          },
        ]
      }
    },
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;저는 &lt;strong&gt;Inter&lt;/strong&gt;, &lt;strong&gt;Pretendard&lt;/strong&gt; 폰트를 불러왔는데요, 적용해본 결과 &lt;strong&gt;Pretendard&lt;/strong&gt; 폰트가 더 깔끔하니 마음에 들어서 해당 폰트를 추가해 주었습니다!&lt;/p&gt;
&lt;p&gt;이제 css 파일로 가서, 해당 폰트를 적용해 주면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;--fontFamily-pretendard: Pretendard, -apple-system, BlinkMacSystemFont, &amp;quot;Noto Sans&amp;quot;, ...;
--font-body: var(--fontFamily-pretendard);

body {
    font-family: var(--font-body);
    font-size: var(--fontSize-1);
    color: var(--color-text);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[Gatsby로 Github 블로그 만들기]]></title><description><![CDATA[안녕하세요! 드디어 저의 깃허브 블로그 첫 포스팅입니다✨ 개발을 하면서 가장 중요하게 해 나가야 할 것 중 하나가 기록이 아닐까 싶은데요!
저는 그동안 이런저런 블로그(velog, notion…]]></description><link>https://kirahaa.github.io/make-gatsby-blog/</link><guid isPermaLink="false">https://kirahaa.github.io/make-gatsby-blog/</guid><pubDate>Thu, 29 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;안녕하세요! 드디어 저의 깃허브 블로그 첫 포스팅입니다✨&lt;/p&gt;
&lt;p&gt;개발을 하면서 가장 중요하게 해 나가야 할 것 중 하나가 &lt;strong&gt;기록&lt;/strong&gt;이 아닐까 싶은데요!&lt;br/&gt;
저는 그동안 이런저런 블로그(velog, notion 등..)들을 전전하면서 항상 구조, 테마 등의 아쉬움이 있었습니다.&lt;/p&gt;
&lt;p&gt;그러다가 직접 나만의 블로그를 만들어보자! 해서 여기까지 왔습니다ㅎㅎㅎ&lt;br/&gt;
(심지어 깃허브를 통해 배포하는 거라, 제 잔디까지 심고 일석이조?😆)&lt;/p&gt;
&lt;h2&gt;What&apos;s Gatsby?&lt;/h2&gt;
&lt;p&gt;우선! Gatsby가 무엇일까요?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 Gatsby는 프론트엔드 라이브러리 React를 기반으로 하는 JAM Stack 기반의 정적 사이트 생성 프레임워크 입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;JAM Stack?&lt;/h2&gt;
&lt;p&gt;JAM Stack의 JAM은 &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Api&lt;/code&gt;, &lt;code&gt;Markup&lt;/code&gt;의 약자입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/07739e60560cbfb946628208f160ff99/451a4/jamstack.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.202531645569614%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHdi4LGB//EABgQAAIDAAAAAAAAAAAAAAAAAAEyAhAx/9oACAEBAAEFAgwyC3//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAAREgMf/aAAgBAQAGPwJjNmn/xAAZEAEAAwEBAAAAAAAAAAAAAAABABEhEEH/2gAIAQEAAT8hV6RVovuxjhUy3pP/2gAMAwEAAgADAAAAEDMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAAICAgMAAAAAAAAAAAAAAQARIUEQYTFx8f/aAAgBAQABPxAQCaxWhPsuLSXIY6IBLKpRV7rjU8H3P//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;JAM Stack&quot;
        title=&quot;&quot;
        src=&quot;/static/07739e60560cbfb946628208f160ff99/af1fa/jamstack.jpg&quot;
        srcset=&quot;/static/07739e60560cbfb946628208f160ff99/ab180/jamstack.jpg 158w,
/static/07739e60560cbfb946628208f160ff99/ba98e/jamstack.jpg 315w,
/static/07739e60560cbfb946628208f160ff99/af1fa/jamstack.jpg 630w,
/static/07739e60560cbfb946628208f160ff99/23301/jamstack.jpg 945w,
/static/07739e60560cbfb946628208f160ff99/78e18/jamstack.jpg 1260w,
/static/07739e60560cbfb946628208f160ff99/451a4/jamstack.jpg 2000w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;즉, Javascript &amp;#x26; Markup으로 정적 페이지를 표시하고, 필요 시에 API를 통해 데이터를 호출하는 것입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전통적 웹 사이트: 서버에 요청하면 SSR을 통해 HTML을 만들어 제공&lt;/li&gt;
&lt;li&gt;SPA: 처음 요청받은 페이지만 SSR로 제공하고 나머지는 CSR로 제공&lt;/li&gt;
&lt;li&gt;JAM Stack: 각 페이지를 HTML로 Pre-Render하여 캐싱 후 CDN에서 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h4&gt;Javascript&lt;/h4&gt;
&lt;p&gt;Client의 모든 처리는 Javascript에 맞긴다.&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;p&gt;모든 기능 및 비즈니스 로직은 재사용 가능한 API로 추상화한다.&lt;/p&gt;
&lt;h4&gt;Markup&lt;/h4&gt;
&lt;p&gt;SSG (Static Site Generator)나 Template Engine(Webpack 등)을 이용하여 Markup을 미리 생성한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 제일 중요한 부분이 &lt;code&gt;Markup&lt;/code&gt;입니다.&lt;/p&gt;
&lt;h3&gt;Markup&lt;/h3&gt;
&lt;p&gt;Markup을 만들 수 있는 방법은 매우 다양한데,&lt;/p&gt;
&lt;p&gt;HTML을 직접 작성하거나, &lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_web_template_engines&quot;&gt;Template Engine&lt;/a&gt; 같은 툴을 이용하거나,
&lt;code&gt;Jekyll (ruby)&lt;/code&gt;, &lt;code&gt;Hugo (go)&lt;/code&gt;, &lt;code&gt;Nuxt (vue)&lt;/code&gt;, &lt;code&gt;Next (react)&lt;/code&gt;, &lt;code&gt;Gatsby&lt;/code&gt; 같은 &lt;strong&gt;정적 사이트 생성기 (Static Site Generator, SSG)&lt;/strong&gt; 를 이용해서,
&lt;strong&gt;Static HTML&lt;/strong&gt;을 생성할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;그리고 미리 작성된 &lt;strong&gt;Static HTML&lt;/strong&gt;은 웹서버의 리소스를 쓸 필요 없이, 사용자에게 HTML만을 전달해주면 됩니다.&lt;/p&gt;
&lt;p&gt;이는 매우 큰 장점을 가져오게 되는데, Static HTML을 CDN을 통해 Cache하고 배포하여, 빠른 속도를 유지합니다.&lt;/p&gt;
&lt;p&gt;따로 동적으로 HTML을 생성하지 않기 때문에, 따로 웹서버가 필요 없어 서버 비용이 높지 않습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자 그럼, 마크업은 뭘로 하는게 좋을까? 고민하신다면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원페이지, 위키, 블로그 등 정적 콘텐츠가 대부분이고 볼륨이 가볍다 ? =&gt; &lt;code&gt;Gatsby&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;동적 데이터 활용도가 많고 컨텐츠 양이 점점 많아질 것으로 예상된다 ? =&gt; &lt;code&gt;Next.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;저는 이러한 이유로 개츠비를 선택하게 되었습니다. 🙌&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;다뤄보기&lt;/h2&gt;
&lt;h3&gt;프로젝트 생성&lt;/h3&gt;
&lt;p&gt;요구조건: &lt;code&gt;Node.js 18.0.0+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;node 버전은 18 이상이어야 합니다. 저는 회사에서 버전 16을 사용하고 있었기 때문에, 버전을 변경해주어야 했습니다.
&lt;code&gt;nvm&lt;/code&gt;을 이용하면 노드 버전을 스위칭하여 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nvm(node version manager): 여러개의 노드 버전을 사용할 수있는 도구&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ nvm list  # 사용가능한 node 버전 리스트 확인

    18.16.0
    18.15.0 
    16.18.1
  * 16.17.1 (Currently using 64-bit executable)
    14.16.0

# 원하는 버전이 없다면 설치
$ nvm install {원하는 버전}

# 원하는 버전으로 변경
$ nvm use {원하는 버전}

# 변경된 노드 버전 확인
$ node -v 
v18.15.0&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자 이제 노드 버전을 변경해 줬으니, 본격적으로 개츠비를 설치해봅시다!&lt;/p&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install -g gatsby-cli&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;테마 선택하기&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/starters/&quot;&gt;Gatsby Starter&lt;/a&gt; 사이트에 다양한 테마들이 있는데요!
저는 &lt;a href=&quot;https://www.gatsbyjs.com/starters/gatsbyjs/gatsby-starter-blog/&quot;&gt;gatsby-starter-blog&lt;/a&gt; 테마를 선택했습니다.&lt;br/&gt;
gatsby 명령어를 사용하여 blog라는 디렉토리에 블로그의 소스코드를 가져옵니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ gatsby new blog https://github.com/gatsbyjs/gatsby-starter-blog&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;설치가 완료되면 현재 위치에 blog라는 디렉토리가 생성되고, 이 안에 각종 파일이 생성됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ cd blog # 생성된 디렉토리로 들어가서,

$ npm develop # 로컬 서버를 띄워준다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 브라우저(chrome)을 열고 주소창에 localhost:8000으로 접속해보세요.&lt;br/&gt;
아래와 같은 화면이 뜨면 성공입니다! 🎉&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b1e503ec15caf002fdb3423f4a6a855a/efd2f/gatsby-starter-blog.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 114.55696202531647%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe3qU0CaAD//xAAXEAEAAwAAAAAAAAAAAAAAAAABABEw/9oACAEBAAEFAqgYf//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABcQAQADAAAAAAAAAAAAAAAAACAxQaH/2gAIAQEABj8CnRZ//8QAGxAAAQQDAAAAAAAAAAAAAAAAAQAQITERQYH/2gAIAQEAAT8hMiggNnpbbsTT/wD/2gAMAwEAAgADAAAAEDPIAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB4QAQACAgEFAAAAAAAAAAAAAAEAESFBEDFRcYGx/9oACAEBAAE/ELMwVwD+S1WWVlYXuN386uY7wdN+4ESC3fP/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;gatsby-starter-blog&quot;
        title=&quot;&quot;
        src=&quot;/static/b1e503ec15caf002fdb3423f4a6a855a/af1fa/gatsby-starter-blog.jpg&quot;
        srcset=&quot;/static/b1e503ec15caf002fdb3423f4a6a855a/ab180/gatsby-starter-blog.jpg 158w,
/static/b1e503ec15caf002fdb3423f4a6a855a/ba98e/gatsby-starter-blog.jpg 315w,
/static/b1e503ec15caf002fdb3423f4a6a855a/af1fa/gatsby-starter-blog.jpg 630w,
/static/b1e503ec15caf002fdb3423f4a6a855a/efd2f/gatsby-starter-blog.jpg 757w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Gatsby Blog 기본 세팅하기&lt;/h3&gt;
&lt;p&gt;이제 복사해온 사이트의 정보를 저의 정보로 수정해 봅시다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gatsby-config.js&lt;/code&gt; - 블로그와 관련된 설정을 하는 파일&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
    siteMetadata: {
        title: `Kirahaa`,
        author: {
            name: `Hayeong Kim`,
            summary: `I believe the importance of experience`,
        },
        description: `kirahaa blog`,
        siteUrl: `https://kirahaa.github.io/`,
    },
// ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; - 프로젝트 정보 수정&lt;/p&gt;
&lt;p&gt;package.json 파일 내에 기본 정보들을 수정해주고,
&quot;scripts&quot; 내에 &lt;strong&gt;deploy&lt;/strong&gt; 명령어를 추가해서 다음과 같이 적어주세요.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;kirahaa-blog&amp;quot;,
  &amp;quot;private&amp;quot;: false,
  &amp;quot;description&amp;quot;: &amp;quot;kirahaa blog&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;Hayeong Kim &amp;lt;khy4018@gmail.com&amp;gt;&amp;quot;,
  &amp;quot;bugs&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;https://github.com/kirahaa/kirahaa.github.io/issues&amp;quot;
  },
  // ...
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;deploy&amp;quot;: &amp;quot;gatsby build &amp;amp;&amp;amp; gh-pages -d public -b master&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;앞으로 포스팅 작성을 완료하고, 로컬에서 잘 확인했으면 &lt;code&gt;npm run deploy&lt;/code&gt; 명령어로 배포합니다.&lt;/p&gt;
&lt;p&gt;이때 소스코드 빌드 후의 public 폴더를 github master 브랜치에 push한다는 뜻이고, 이 소스 코드로 &lt;a href=&quot;https://kirahaa.github.io/&quot;&gt;https://kirahaa.github.io/&lt;/a&gt;에 배포됩니다.&lt;/p&gt;
&lt;h3&gt;github.io repo 만들기&lt;/h3&gt;
&lt;p&gt;이제 자신의 github에 소스코드를 올리면 됩니다!&lt;/p&gt;
&lt;p&gt;github에 접속해서 새로운 repository(이하 repo)를 만들어주세요. 그런데 repo 이름에 유의하셔야 합니다!&lt;br/&gt;
github의 &lt;strong&gt;usename&lt;/strong&gt; 뒤에 &lt;strong&gt;.github.io&lt;/strong&gt;을 붙여서 만들어주세요. 제 &lt;strong&gt;github username&lt;/strong&gt;은 kirahaa이기 때문에
&lt;code&gt;kirahaa.github.io&lt;/code&gt;로 만들었습니다. &lt;br/&gt;
공개범위는 &lt;strong&gt;Public&lt;/strong&gt;으로 만들어주세요😉&lt;/p&gt;
&lt;h3&gt;배포하기&lt;/h3&gt;
&lt;p&gt;먼저, 저희는 &lt;code&gt;gh-pages&lt;/code&gt;로 배포할 것이기 때문에 gh-pages package를 설치해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm install gh-pages --save-dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 로컬에 있는 블로그 소스코드를 github에 올려봅시다!&lt;/p&gt;
&lt;p&gt;블로그 root에서 git을 세팅합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git init
$ git remote add origin https://github.com/kirahaa/kirahaa.github.io.git&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음 명령어로 origin 주소가 잘 연결되었는지 확인해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git remote -v&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;푸시를 해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git add .
$ git commit -m &amp;quot;first commit&amp;quot;
$ git push origin master&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;github에서 소스코드가 잘 올라갔는지 확인해 주세요.&lt;/p&gt;
&lt;p&gt;잘 됐으면 배포 명령어를 실행합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ npm run deploy&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;정상적으로 배포가 되었다면, github 사이트의 블로그 repo에 가서 master에 올라온 소스코드를 확인해 주세요.&lt;br/&gt;
저희가 원래 받았던 소스코드와 구조가 완전히 다르죠?! 여기서 놀라지 마시구,, 😁&lt;/p&gt;
&lt;p&gt;해당 소스는 포스팅을 작성하고 커스터마이징 할 수 있는 개발 소스가 아니라 블로그 사이트에 배포될 수 있도록 .md 파일이 모두 html, js로 바뀐 빌드된 파일입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm run deploy&lt;/code&gt; 명령어가 알아서 build도 해주고, git의 master 브랜치에 push도 해주고 배포도 해준 것입니다.&lt;/p&gt;
&lt;p&gt;앞으로 항상 deploy만 해줘도 되지만, 다른 컴퓨터에서 포스팅을 작성할 경우를 대비하여 개발코드도 저장해주도록 합시다!&lt;br/&gt;
develop이라는 브랜치를 따로 만들어서 여기에다만 올리도록 하겠습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git branch develop  # develop 브랜치 생성

$ git checkout develop  # develop 브랜치로 체크아웃&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;동일하게 소스코드를 git에 push해 줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;$ git add .
$ git commit -m &amp;quot;blog posting~&amp;quot;
$ git push -u origin develop&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;내 github의 develop repo에 들어가서 소스코드가 모두 잘 올라갔는지 확인해 주세요.&lt;/p&gt;
&lt;p&gt;잘 올라갔다면 github default 브랜치를 develop으로 바꾸겠습니다.&lt;br/&gt;
어차피 빌드 결과물인 master 브랜치의 빌드 파일들을 파악할 필요도 없으니까요.&lt;br/&gt;
github의 해당 블로그 repo에 들어가서 &lt;strong&gt;Setting &gt; Branches&lt;/strong&gt; 메뉴에서 Default branch를 devleop으로 바꾸고 update 버튼을 눌러주세요!&lt;/p&gt;
&lt;p&gt;이제 각자의 &lt;strong&gt;username.github.io&lt;/strong&gt;에 들어가서 배포된 블로그를 확인해 보세요!&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;여기까지, 가장 기본적인 블로그 세팅이 끝났습니다!&lt;br/&gt;
다음 포스팅에서는 &lt;strong&gt;개츠비 플러그인을 사용해 블로그 커스텀하는 법&lt;/strong&gt;을 더 자세히 살펴보겠습니다!&lt;/p&gt;
&lt;p&gt;다음 포스팅도 기대해주세욧 😉✨&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h4&gt;참고 자료&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://anneslab.tistory.com/116&quot;&gt;https://anneslab.tistory.com/116&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yeri-kim.github.io/posts/how-to-install-gatsby/&quot;&gt;https://yeri-kim.github.io/posts/how-to-install-gatsby/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://uzzam.dev/6&quot;&gt;https://uzzam.dev/6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7&quot;&gt;https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>