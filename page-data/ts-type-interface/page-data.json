{"componentChunkName":"component---src-templates-blog-post-js","path":"/ts-type-interface/","result":{"data":{"site":{"siteMetadata":{"title":"Kirahaa"}},"markdownRemark":{"id":"7f9ede5f-bbe7-5e7b-8734-78676f88253e","excerpt":"typescript를 공부해보셨다면 type과 interface의 차이점에 대해 궁금증을 가져보셨을 텐데요!\r\n이번 기회에 확실히 정리해 봅시다! 🙌 📌 상속 받는 법 interface는 extends를 type…","html":"<p><strong>typescript</strong>를 공부해보셨다면 <code>type</code>과 <code>interface</code>의 차이점에 대해 궁금증을 가져보셨을 텐데요!<br/>\r\n이번 기회에 확실히 정리해 봅시다! 🙌</p>\n<h3>📌 상속 받는 법</h3>\n<p><strong>interface</strong>는 <code>extends</code>를 <strong>type</strong>은 <code>&#x26;</code>를 이용해 상속을 통한 확장을 진행합니다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// ✅ interface\r\ninterface IString1 {\r\n  a: string;\r\n}\r\n\r\ninterface IString2 extends IString2 {\r\n  b: string;\r\n}\r\n\r\nconst interfaceConst: interface2 = {\r\n  a: &#39;a&#39;,\r\n  b: &#39;b&#39;\r\n}\r\n\r\n// ✅ type\r\ntype type1 = {\r\n  a: string;\r\n}\r\n\r\ntype type2 = type1 &amp; {\r\n  b: string;\r\n}\r\n\r\nconst typeConst: type2 = {\r\n  a: &#39;a&#39;,\r\n  b: &#39;b&#39;\r\n}</code>\n        </deckgo-highlight-code>\n<h3>📌 선언적 확장 / 자동 확장</h3>\n<p><strong>interface</strong>는 같은 이름의 객체를 다시 한번 선언하면 자동으로 확장이 됩니다. 하지만 <strong>type</strong>은 불가능 합니다.<br/>\r\n따라서 외부에 공개되어야 하는 library 같은 경우에는 타입 객체의 확장성을 위해 <strong>interface</strong>를 사용하는 것을 추천한다고 합니다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// ✅\r\ninterface interface1 {\r\n  a: string;\r\n}\r\n\r\ninterface interface1 {\r\n  b: string;\r\n}\r\n\r\nconst interfaceConst: interface1 = {\r\n  a: &#39;a&#39;,\r\n  b: &#39;b&#39;\r\n}\r\n\r\n\r\n// ❌ Duplicate identifier &#39;type1&#39;.\r\ntype type1 = {\r\n  a: string;\r\n}\r\n\r\ntype type1 = {\r\n  b: string;\r\n}</code>\n        </deckgo-highlight-code>\n<h3>📌 computed property name</h3>\n<blockquote>\n<p>computed property name은 <strong>표현식(변수, 함수 등)을 이용해 객체의 key 값을 지정하는 문법</strong>입니다.</p>\n</blockquote>\n<p><strong>type</strong>의 경우, computed property name을 사용한 타입 선언이 가능하지만, <strong>interface</strong>의 경우는 불가능합니다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type keyType = &#39;a&#39; | &#39;b&#39;\r\n\r\ntype type1 = {\r\n  [key in keyType]: string\r\n}\r\n\r\nconst typeA: type1 = { a: &#39;a&#39;, b: &#39;b&#39; }\r\n\r\ninterface interface1 {\r\n  // ❌ error\r\n  [key in keyType]: string\r\n}</code>\n        </deckgo-highlight-code>\n<h3>📌 원시 타입이나 튜플, 유니온 타입의 타입 선언의 경우에는 type 사용, interface는 객체의 타입 정의에 사용</h3>\n<h4>원시 타입(Primitive Types)</h4>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type CustomType = string;\r\nconst str: CustomType = &#39;&#39;;\r\n\r\n// ❌ \r\ninterface CustomInterface = string;</code>\n        </deckgo-highlight-code>\n<h4>유니온 타입(Union Types)</h4>\n<blockquote>\n<p>유니온 타입이란 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입입니다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type Fruit = &#39;apple&#39; | &#39;lemon&#39;\r\ntype Vegetable = &#39;patato&#39; | &#39;tomato&#39;\r\n\r\ntype Food = Fruit | Vegetable\r\n\r\nconst apple: Food = &#39;apple&#39;</code>\n        </deckgo-highlight-code>\n<h4>튜플 타입(Tuple Types)</h4>\n<blockquote>\n<p>tuple은 자바스크립트에서는 지원하지 않는 데이터 타입이지만, 타입스크립트에서는 <strong>배열 타입을 보다 특수한 형태로 사용할 수 있는 타입</strong>입니다.\r\ntuple에 명시적으로 지정된 형식에 따라 아이템 순서를 설정해야 되고, 추가되는 아이템 또한 tuple에 명시된 타입만 사용 가능합니다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">type Animal = [name: string, age: number];\r\n\r\nconst cat: Animal = [&#39;kitty&#39;, 1];</code>\n        </deckgo-highlight-code>\n<hr>\n<h3>결론</h3>\n<p>공식문서에서는 특별한 경우를 제외하고는 <strong>type보단 interface를 사용하는 것이 더 좋다</strong>고 하네요!<br/>\r\n프로젝트를 설계하기 전에 type을 쓸지 interface를 쓸지 통일을 하면 좋을 것 같습니다!</p>\n<p><strong>결론적으로는 팀 내 컨벤션이 있다면 그에 따르고, type과 interface의 쓰임새에 맞게 사용해주는게 좋다고 생각합니다. 😉</strong></p>","frontmatter":{"title":"Typescript - type과 interface 차이","date":"July 22, 2023","description":"typescript의 type alias과 interface의 차이점에 대해 알아봅시다.","tags":["typescript","type","interface"]}},"previous":{"fields":{"slug":"/starting-nest-js/"},"frontmatter":{"title":"NestJS를 배워보자"}},"next":null},"pageContext":{"id":"7f9ede5f-bbe7-5e7b-8734-78676f88253e","previousPostId":"23e640cf-48be-5572-bc2c-91299defa17a","nextPostId":null}},"staticQueryHashes":["2837417301","2841359383"],"slicesMap":{}}