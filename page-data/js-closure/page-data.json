{"componentChunkName":"component---src-templates-blog-post-js","path":"/js-closure/","result":{"data":{"site":{"siteMetadata":{"title":"Kirahaa"}},"markdownRemark":{"id":"fe081a1b-5356-5819-a549-68b8fc0f509a","excerpt":"closure와 closer해져봅시다 ㅋ.ㅋ 클로저를 알기 전에, 자바스크립트의 렉시컬 스코핑에 대해 먼저 알아보도록 합시다! 스코프(Scope…","html":"<p>closure와 closer해져봅시다 ㅋ.ㅋ</p>\n<h3>클로저를 알기 전에,</h3>\n<p>자바스크립트의 렉시컬 스코핑에 대해 먼저 알아보도록 합시다!</p>\n<h3>스코프(Scope)란?</h3>\n<p>스코프란 참조 대상 식별자(변수와 함수같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙입니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// 전역 스코프\r\nconst var1 = &#39;global&#39;;\r\n\r\nconst func = () =&gt; {\r\n  // 함수 레벨 스코프\r\n  const var2 = &#39;function&#39;;\r\n  \r\n  console.log(global);  // 접근 가능\r\n};\r\n\r\nfunc();\r\nconsole.log(local);  // 접근 불가능</code>\n        </deckgo-highlight-code>\n<p>전역 스코프를 가진 변수는 어디서든 참조할 수 있지만, 함수 레벨 스코프를 가진 변수는 함수 외부에서 참조하려고 할 경우 참조에러가 발생하게 됩니다.\r\n이러한 개념을 스코프라고 합니다.</p>\n<h3>렉시컬 스코프(Lexical scope)란?</h3>\n<p>렉시컬 스코프는 함수를 어디에 선언하였는지에 따라 상위 스코프가 결정되는 것을 말합니다.\r\n자바스크립트를 포함한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따르며, 이를 정적 스코프(Static Scope)라고 부르기도 합니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const func = () =&gt; {\r\n  const var1 = &#39;function1&#39;;\r\n  \r\n  const func2 = () =&gt; {\r\n    console.log(var1); // function2\r\n  };\r\n  \r\n  func2();\r\n};\r\nfunc();</code>\n        </deckgo-highlight-code>\n<p>내부 함수에서 외부 함수의 변수에 접근이 가능한데, 이것은 함수가 중첩될 때 구문 분석기가 변수 이름을 확인하는 방법을 설명하는 정적 스코프의 예시입니다.\r\n'정적'이란, 정적 번위 지정 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미합니다.\r\n즉, 호출 스택과 관계없이 선언 시점에 스코프를 결정합니다. 함수를 호출할 때가 아니라 선언할 때 스코프가 정해지기 때문에 외부에서는 내부 변수에 접근할 수 없게 됩니다.</p>\n<p>반대로 동적 스코프의 선언은 런타임 도중에 실행 콘텍스트나 호출 콘텍스트에 의해 결정됩니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const scope = &#39;정적 스코프&#39;;\r\n\r\nconst init = () =&gt; {\r\n  const scope = &#39;동적 스코프&#39;;\r\n  func();\r\n};\r\n\r\nconst func = () =&gt; {\r\n  console.log(scope);  // 정적 스코프\r\n};\r\n\r\ninit();</code>\n        </deckgo-highlight-code>\n<p>자바스크립트는 정적 스코프를 따르기 때문에 <strong>정적 스코프</strong>가 출력될 것이지만, 만약 동적 스코프를 따른다면 <strong>동적 스코프</strong>가 출력될 것입니다.</p>\n<h3>ES6</h3>\n<p>ES6 이전에는 함수 스코프와 전역 스코프 두 가지만 존재했고, ES6 이후부터 블록 스코프가 등장하게 되었습니다.\r\nvar로 선언한 변수는 함수 내부 또는 외부에서 선언되었는지에 따라 함수 스코프 또는 전역 스코프를 가지게 되는데, 이때, 중괄호로 표시된 블록이 스코프를 생성하지 않는다는 점에서 혼란을 일으킬 수 있습니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">var x = 1;\r\nif (true) {\r\n  var x = 2;\r\n  var y = 3;\r\n}\r\nconsole.log(x);  // 2\r\nconsole.log(y);  // 3</code>\n        </deckgo-highlight-code>\n<p>console.log에서 x가 어떤 블록 스코프에도 포함되지 않기 때문에 에러가 발생해야 할 것 같지만, 블록은 var로 선언한 변수에 대해 스코프를 생성하지 않기 때문에 var는 전역 변수를 생성합니다.\r\nlet/const를 사용하면 이런 혼란에서 벗어날 수 있습니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const x = 1;\r\nif (true) {\r\n  const x = 2;\r\n  const y = 3;\r\n}\r\nconsole.log(x); // 1\r\nconsole.log(y); // Uncaught ReferenceError: y is not defined</code>\n        </deckgo-highlight-code>\n<p>그러니, 엉망진창인 var를 버리고 let과 const를 사용하도록 하자!</p>\n<p>이제 본격적으로 클로저에 대해 이야기해 봅시다!</p>\n<h3>클로저란?</h3>\n<p>클로저(closure)는 함수와 그 함수가 선언된 렉시컬 환경(lexical environment) 사이의 특별한 관계입니다.\r\n함수 내부에서  정의한 변수와 그 함수의 외부 변수 사이의 관계를 나타낸다고 볼 수 있습니다. 보통은 함수가 실행을 마치고 렉시컬 환경이 소멸될 때, 해당 함수 내에서 선언된 변수들도 사라집니다.\r\n하지만 클로저에서는 외부 변수에 대한 참조가 남아 있어 내부 변수들에 계속해서 접근이 가능합니다.\r\n함수가 속한 문맥적 번위를 기억하여 함수의 범위 밖에서도 내부에 접근할 수 있게 해주는 기능이라고 볼 수 있습니다.\r\n클로저는 함수가 다른 함수 내부에서 정의되고, 내부 함수가 외부 함수의 변수를 참조할 때 생성됩니다.\r\n내부 함수가 외부 함수로부터 반환되거나 다른 코드 블록 내에서 참조될 때 클로저가 형성되는 것입니다.</p>\n<p>코드를 한번 살펴봅시다!</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const outerFunction = () =&gt; {\r\n  const outerVar = 10;\r\n  \r\n  const innerFunction = () =&gt; {\r\n    console.log(outerVar);  // outerVar에 접근 가능\r\n  };\r\n  \r\n  return innerFunction;\r\n};\r\n\r\nconst closureExample = outerFunction();\r\nclosureExample(); // 10</code>\n        </deckgo-highlight-code>\n<p>위 코드에서 <code>innerFunction</code>은 <code>outerFunction</code> 내부에서 정의되고, <code>closureExample</code>에 할당된 다음 외부에서 호출됩니다.\r\n이때 <code>innerFunction</code>은 외부 함수 <code>outerFunction</code>의 <code>outerVal</code> 변수에 접근할 수 있으며, 클로저가 형성됩니다.</p>\n<h4>잠깐!</h4>\n<p>var를 사용할 경우, 클로저와 함께 사용했을 때도 당연히 버그가 발생할 가능성이 큽니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">function createCounter() {\r\n  var count = 0;\r\n  \r\n  var increment = function () {\r\n    count++;\r\n    console.log(count);\r\n  };\r\n  \r\n  var decrement = function () {\r\n    count--;\r\n    console.log(count);\r\n  };\r\n  \r\n  return {\r\n    increment: increment,\r\n    decrement: decrement\r\n  };\r\n}\r\n\r\nvar counter = createCounter();\r\n\r\ncounter.increment(); // 1\r\ncounter.increment(); // 2\r\n\r\n// 버그 원인\r\nvar count = 10; // 외부에서 count 변수 재정의\r\n\r\ncounter.decrement();  // 11 (예상치 못한 결과)</code>\n        </deckgo-highlight-code>\n<h3>클로저를 어떻게 활용할 수 있을까?</h3>\n<h4>1. 리액트 훅</h4>\n<p>숨쉬듯 사용하는 <code>useState</code>가 이러한 클로저를 이용해서 상태를 기억합니다. <code>useState</code>는 <code>state</code>와 <code>setState</code>의 두 함수를 내부적으로 가지는데,\r\n실제로 <code>state</code>와 <code>setState</code>를 사용하는 시점은 <code>useState</code>의 호출이 끝난 후이지만, 클로저가 내부 변수 값을 기억하고 있기 때문에 이후에도 접근이 가능합니다.\r\n<code>useState</code> 뿐만 아니라 커스텀 훅에서도 클로저를 이용해서 상태를 기억할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const useBoolean = (defaultValue = false): [boolean, () =&gt; void, () =&gt; void] =&gt; {\r\n  const [value, setValue] = useState(defaultValue);\r\n  \r\n  return [value, () =&gt; setValue(true), () =&gt; setValue(false)];\r\n};\r\n\r\nconst [showModal, onOpenModal, onCloseModal] = useBoolean();</code>\n        </deckgo-highlight-code>\n<h4>2. 비동기 작업 관리</h4>\n<p>클로저는 비동기 작업을 관리하고 상태를 유지하는 데 유용합니다.\r\n예를 들어, 타이머 콜백 함수 내에서 외부 변수를 사용하여 특정 조건에 따라 작업을 중단하거나 다시 시작할 수 있습니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const createTimer = () =&gt; {\r\n  let count = 0;\r\n  const timer = setInterval(() =&gt; {\r\n    console.log(count++);\r\n  }, 1000);\r\n  \r\n  return function stopTimer() {\r\n    clearInterval(timer);\r\n  };\r\n};\r\n\r\nconst stopFunc = createTimer();\r\n\r\nsetTimer(() =&gt; {\r\n  stopFunc(); // 타이머 중지\r\n}, 5000);</code>\n        </deckgo-highlight-code>\n<h4>3. 모듈 패턴</h4>\n<p>이러한 클로저를 이용해서 프라이빗 변수를 흉내내는 모듈 패턴을 구현할 수도 있습니다. 모듈 패턴을 사용하면 전역 스코프에서 변수 노출을 최소화하고 코드를 모듈화할 수 있습니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const counterModule = (() =&gt; {\r\n  let count = 0;\r\n  \r\n  const increment = () =&gt; {\r\n    count++;\r\n  }\r\n  \r\n  const decrement = () =&gt; {\r\n    count--;\r\n  }\r\n  \r\n  const getCount = () =&gt; {\r\n    return count;\r\n  }\r\n  \r\n  return {\r\n    increment,\r\n    decrement,\r\n    getCount,\r\n  }\r\n})();\r\n\r\ncounterModule.increment();\r\nconsole.log(counterModule.getCount()); // 1</code>\n        </deckgo-highlight-code>\n<p>꽤나 많은 개념이 들어간 글이었는데, 결론적으로 클로저는 자바스크립트에서 매우 강력한 개념 중 하나이며, 함수의 스코프와 변수 관리를 효율적으로 처리할 수 있도록 해줍니다.\r\n클로저를 올바르게 활용하면 코드를 더 효과적으로 작성하고 유지 관리할 수 있습니다.</p>","frontmatter":{"title":"클로저와 더 가까워지기","date":"October 31, 2023","description":"closure와 좀 더 closer해져보자 ㅋ.ㅋ","tags":["javascript","closure","scope"]}},"previous":{"fields":{"slug":"/ts-generic/"},"frontmatter":{"title":"타입스크립트의 꽃, 제네릭"}},"next":null},"pageContext":{"id":"fe081a1b-5356-5819-a549-68b8fc0f509a","previousPostId":"6ee40786-847f-5959-a7eb-885a7fa35c8e","nextPostId":null}},"staticQueryHashes":["1085474499","2837417301"],"slicesMap":{}}