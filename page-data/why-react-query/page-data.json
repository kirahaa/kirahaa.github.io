{"componentChunkName":"component---src-templates-blog-post-js","path":"/why-react-query/","result":{"data":{"site":{"siteMetadata":{"title":"Kirahaa"}},"markdownRemark":{"id":"2c44be0b-f238-50bf-8f75-f6a3af5ef241","excerpt":"세줄 요약 React Query는 React Application에서 서버 상태를 불러오고, 캐싱하며, 지속적으로 동기화하고 업데이트하는 작업을 도와주는 라이브러리입니다. 복잡하고 장황한 코드가 필요한 다른 데이터 불러오기 방식과 달리 React Component…","html":"<blockquote>\n<p>세줄 요약</p>\n<ol>\n<li>React Query는 React Application에서 서버 상태를 불러오고, 캐싱하며, 지속적으로 동기화하고 업데이트하는 작업을 도와주는 라이브러리입니다.</li>\n<li>복잡하고 장황한 코드가 필요한 다른 데이터 불러오기 방식과 달리 React Component 내부에서 간단하고 직관적으로 API를 사용할 수 있습니다.</li>\n<li>더 나아가 React Query에서 제공하는 캐싱, Window Focus Refetching 등 다양한 기능을 활용하여 API 요청과 관련된 번잡한 작업 없이 \"핵심 로직\"에 집중할 수 있습니다.</li>\n</ol>\n</blockquote>\n<h3>React Query란?</h3>\n<p>React Query는 React Application에서 서버의 상태를 불러오고, 캐싱하며, <strong>지속적으로 동기화</strong>하고 업데이트 하는 작업을 도와주는 라이브러리입니다.\r\nReact Query는 우리에게 친숙한 Hook을 사용하여 React Component 내부에서 자연스럽게 서버(또는 비동기적인 요청이 필요한 Source)의 데이터를 사용할 수 있는 방법을 제안합니다.</p>\n<p>다음은 리액트 쿼리를 적용하기 전과 후의 API 통신 방법입니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// React query 사용 전\r\nimport {useEffect, useState} from &quot;react&quot;;\r\n\r\nconst [coins, setCoins] = useState&lt;ICoin[]&gt;([])\r\nconst [loading, setLoading] = useState(true);\r\n\r\nuseEffect(() =&gt; {\r\n  (async() =&gt; {\r\n    const response = await fetch(&quot;https://api.coinpaprika.com/v1/coins&quot;)\r\n    const json = await response.json()\r\n    setCoins(json)\r\n    setLoading(false)\r\n  })()\r\n}, [])</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// React query 사용 후\r\n// api.ts\r\nexport const fetchCoins = async () =&gt; {\r\n  const response = await fetch(&quot;https://api.coinpaprika.com/v1/coins&quot;)\r\n  return await response.json()\r\n}\r\n\r\n// Coins.ts\r\nconst {isLoading, data} = useQuery&lt;ICoin[]&gt;({ queryKey: [&#39;allCoins&#39;], queryFn: fetchCoins })\r\n</code>\n        </deckgo-highlight-code>\n<p>길고 거창한 설명 없이도 해당 코드를 보면 React Query를 사용한 API 요청과 상태 관리가 얼마나 쉽고 자연스러운지 알 수 있습니다.</p>\n<h3>React Query의 Query 요청</h3>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// 가장 기본적인 형태의 React Query useQuery Hook 사용 예시\r\nconst { data } = useQuery(\r\n  queryKey,  // 이 Query 요청에 대한 응답 데이터를 캐시할 때 사용할 Unique Key (required)\r\n  fetchFn,   // 이 Query 요청을 수행하기 위한 Promise를 Return하는 함수 (required)\r\n  options,   // useQuery에서 사용되는 Option 객체 (optional)\r\n) </code>\n        </deckgo-highlight-code>\n<p><code>useQuery</code> Hook으로 수행되는 Query 요청은 HTTP METHOD <strong>GET</strong> 요청과 같이 서버에 저장되어 있는 \"상태\"를 불러와 사용할 때 사용합니다.</p>\n<blockquote>\n<p>React Query는 다양한 UI에 유연하게 적용할 수 있도록 <code>useQueries</code>, <code>useInfiniteQuery</code> 같은 Hook들도 제공합니다.</p>\n</blockquote>\n<p>React Query의 <code>useQuery</code> Hook은 요청마다(API마다) 구분되는 **Unique Key (aka. Query Key)**를 필요로 합니다.\r\nReact Query는 이 Unique Key로 서버 상태 (aka. API Response)를 로컬에 캐시하고 관리합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const Coins = () =&gt; {\r\n  const {isLoading, data} = useQuery&lt;ICoin[]&gt;({ queryKey : [&#39;allCoins&#39;], queryFn: fetchCoins })\r\n  // &#39;allCoins&#39;를 Key로 사용하여 데이터 캐싱\r\n  // 다른 컴포넌트에서 &#39;allCoins&#39;를 QueryKey로 사용한 useQuery Hook이 있다면 캐시된 데이터를 우선 사용합니다.\r\n\r\n  // FYI, `data === undefined`를 평가하여 로딩 상태를 처리하는 것이 더 좋습니다.\r\n  // React Query는 내부적으로 stale-while-revalidate 캐싱 전략을 사용하고 있기 때문입니다.\r\n  return (\r\n    &lt;Container&gt;\r\n      &lt;Header&gt;\r\n        &lt;Title&gt;Coins&lt;/Title&gt;\r\n      &lt;/Header&gt;\r\n      {isLoading ? &lt;Loader&gt;Loading&lt;/Loader&gt; : (\r\n        &lt;CoinsList&gt;\r\n          {data?.slice(0, 100).map(coin =&gt; &lt;Coin key={coin.id}&gt;\r\n          &lt;Link to={coin.id} state={coin}&gt;\r\n          &lt;Img src={`https://coinicons-api.vercel.app/api/icon/${coin.symbol.toLowerCase()}`} alt={coin.name}/&gt;\r\n            {coin.name} &amp;rarr;\r\n          &lt;/Link&gt;\r\n        &lt;/Coin&gt;)}\r\n      &lt;/CoinsList&gt;)} \r\n    &lt;/Container&gt;\r\n  )\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p><strong>stale-while-revalidate</strong>란?<br/><br/>\r\n<code>stale-while-revalidate</code>는 개발자가 캐싱된 콘텐츠를 즉시 로드하는 즉시성과 객싱된 최신 콘텐츠가 향후에 사용되도록 보장하는 최신성 간의 균형을 유지하는데 도움을 주는 HTTP Cache-Control 확장 디렉티브입니다.</p>\n<p>브라우저는 Cache-Control의 max-age를 기준으로 캐싱된 컨텐츠의 최신 상태 여부를 판단하게 되는데, swr은 캐싱된 낡은 컨텐츠에 대한 확장된 지시를 표현합니다.\r\nreact-query를 사용함으로써 swr은 낡은 캐시로부터 빠르게 컨텐츠를 반환하고, 백그라운드에서 요청을 통해 캐싱된 컨텐츠의 재검증을 진행하여 캐싱 레이어에서 최신화된 대이터를 보장할 수 있도록 swr 캐싱 전략을 취하고 있습니다.</p>\n</blockquote>\n<h3>React Query를 쓰면 이런 게 편해진다</h3>\n<h4>- Boilerplate 코드의 감소</h4>\n<p>Redux를 사용할 경우 Redux의 기본 원칙 준수를 위한 다양한 Boilerplate 코드들이 필요합니다.\r\n더 나아가 다음 예시 코드를 보면 API 상태 관리를 위해 하나의 API 요청을 3가지 Action을 사용해 처리하고 있고,\r\n후에 기능이 추가되어 API 개수가 많아진다면 이런 상용구적인 코드도 함께 늘어나게 됩니다.</p>\n<blockquote>\n<p>API 상태를 Redux를 사용하여 관리하는 부분의 코드</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// features/todos/todos.slice.ts\r\n// API 상태를 관리하기 위한 Redux State\r\nimport { createSlice, PayloadAction } from &#39;@reduxjs/toolkit&#39;;\r\nimport { TodoItem } from &#39;types/todo&#39;;\r\n\r\nexport interface TodoListState {\r\n  data?: TodoItem[];\r\n  isLoading: boolean;\r\n  error?: Error;\r\n}\r\n\r\nconst initialState: TodoListState = {\r\n  data: undefined,\r\n  isLoading: false,\r\n  error: undefined,\r\n}\r\n\r\nexport const todoListSlice = createSlice({\r\n  name: &#39;todoList&#39;,\r\n  initialState,\r\n  reducers: {\r\n    requestFetchTodos: (state) =&gt; {\r\n      state.isLoading = true;\r\n    },\r\n    successFetchTodos: (state, action: PayloadAction&lt;TodoItem[]&gt;) =&gt; {\r\n      state.data = action.payload;\r\n      state.isLoading = false;\r\n      state.error = undefined;\r\n    },\r\n    errorFetchTodos: (state, action: PayloadAction&lt;string&gt;) =&gt; {\r\n      state.data = undefined;\r\n      state.isLoading = false;\r\n      state.error = action.payload;\r\n    }\r\n  }\r\n});\r\n\r\nexport const { requestFetchTodos, successFetchTodos, errorFetchTodos } = todoListSlice.actions;\r\n\r\nexport default todoListSlice.reducer;</code>\n        </deckgo-highlight-code>\n<hr>\n<blockquote>\n<p>React Query로 API 상태를 관리하는 부분의 코드</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// quries/useTodosQuery.ts\r\n// API 상태를 불러오기 위한 React Query Custom Hook\r\nimport axios from &#39;axios&#39;;\r\nimport { useQuery } from &#39;react-query&#39;;\r\nimport { TodoItem } from &#39;types/todo&#39;;\r\n\r\n// useQuery에서 사용할 UniqueKey를 상수로 선언하고 export로 외부에 노출합니다.\r\n// 상수로 UniqueKey를 관리할 경우 다른 Component (or Custom Hook)에서 쉽게 참조가 가능합니다.\r\nexport const QUERY_KEY = &#39;/todos&#39;;\r\n\r\n// useQuery에서 사용할 `서버의 상태를 불러오는데 사용할 Promise를 반환하는 함수`\r\nconst fetcher = () =&gt; axios.get&lt;TodoItem[]&gt;(&#39;/todos&#39;).then(({ data }) =&gt; data);\r\n\r\nconst useTodosQuery = () =&gt; {\r\n  return useQuery(QUERY_KEY, fetcher);\r\n};\r\n\r\nexport default useTodosQuery;</code>\n        </deckgo-highlight-code>\n<p>단순히 비교해봐도 <strong>Redux를 사용한 비동기 데이터 관리</strong> 코드와 <strong>React Query를 사용한 비동기 데이터 관리</strong> 코드의 분량이 크게 차이남을 알 수 있습니다.\r\n코드의 분량이 적어졌다는 것은 개발자에게 불필요한 작업이 필요 없어짐을 뜻하기도 하지만, 소스코드의 복잡도를 낮추어 유지보수의 용이성을 높이고 작업 간에 발생할 수 있는 사이드 이펙트나 휴먼 에러를 사전에 더\r\n잘 막을 수 있다는 의미도 갖게 될 것입니다.</p>\n<h4>- API 요청 수행을 위한 규격화된 방식 제공</h4>\n<p>React Query는 <code>React에서 비동기 데이터를 관리하기 위해 만들어진 라이브러리</code>입니다. React Query는 API 요청 및 상태 관리를\r\n위해 (상당히 잘 만들어진!) 규격화된 방식을 제공합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface ApiState {\r\n  data?: Data;\r\n  isLoading: boolean;\r\n  error?: Error;\r\n}\r\n\r\ninterface ApiState {\r\n  data?: Data;\r\n  status: &#39;IDLE&#39; | &#39;LOADING&#39; | &#39;SUCCESS&#39; | &#39;ERROR&#39;;\r\n  error?: Error;\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>Redux로 API 상태를 관리하는 경우 프로젝트 환경에 따른 설계와 구현이 요구되었습니다.</p>\n</blockquote>\n<p>React Query는 API 상태와 관련된 다양한 데이터를 제공하여 복잡한 구현과 설계 없이도 개발자가 효율적으로 화면을 구성할 수 있게끔 도와줍니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const {\r\n  data,\r\n  dataUpdatedAt,\r\n  error,\r\n  errorUpdatedAt,\r\n  failureCount,\r\n  isError,\r\n  isFetched,\r\n  isFetchedAfterMount,\r\n  isFetching,\r\n  isIdle,\r\n  isLoading,\r\n  isLoadingError,\r\n  isPlaceholderData,\r\n  isPreviousData,\r\n  isRefetchError,\r\n  isRefetching,\r\n  isStale,\r\n  isSuccess,\r\n  refetch,\r\n  remove,\r\n  status,\r\n} = useQuery(queryKey, queryFn);</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>React Query는 다양한 형태의 데이터를 제공하여 복잡한 작업 없이도 효율적으로 화면을 구성할 수 있다. (참고: <a href=\"https://react-query.tanstack.com/reference/useQuery\">React Query 공식 홈페이지</a>)</p>\n</blockquote>\n<h4>- 사용자 경험 향상을 위한 기능 제공</h4>\n<p>이전에는 비동기 데이터 관리를 위해 직접 구현하고 사용했던 기능들을, React Query는 자체적으로 제공하는 다양한 기능이 있어 이를 사용자 경험 향상에 손쉽게 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// ex)\r\n// quires/useTodosQuery.ts\r\n// API 상태를 불러오기 위한 React Query Custom Hook\r\n\r\nconst useTodosQuery = () =&gt; {\r\n  return uesQuery(QUERY_KEY, fetcher, { refetchOnWindowFoucs: true });\r\n}\r\n\r\nexport default useTodosQuery;</code>\n        </deckgo-highlight-code>\n<p>React Query를 사용할 경우 단순한 옵션 부여만으로 <strong>Window Focus 이벤트 발생 시 서버 상태 동기화</strong> 시나리오를 달성할 수 있습니다.\r\n다루는 API가 많아지고 컴포넌트 구조가 복잡해질수록 이전의 <strong>직접 Event Binding</strong>하는 방식보다 유지보수하기 좋은 코드가 될 것입니다.</p>\n<p>React Query와 함께라면 <a href=\"https://tanstack.com/query/latest/docs/react/guides/window-focus-refetching?from=reactQueryV3&#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Fwindow-focus-refetching\">Refetch on window focus</a>외에\r\n<a href=\"https://tanstack.com/query/latest/docs/react/guides/caching?from=reactQueryV3&#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Fcaching\">API Caching</a>, <a href=\"https://tanstack.com/query/latest/docs/react/guides/query-retries?from=reactQueryV3&#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Fquery-retries\">API Retry</a>, <a href=\"https://tanstack.com/query/latest/docs/react/guides/optimistic-updates?from=reactQueryV3&#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fguides%2Foptimistic-updates\">Optimistic Update</a>, <a href=\"https://tanstack.com/query/latest/docs/react/plugins/persistQueryClient?from=reactQueryV3&#x26;original=https%3A%2F%2Ftanstack.com%2Fquery%2Fv3%2Fdocs%2Fplugins%2FpersistQueryClient\">Persist Caching</a> 등 사용자 경험 향상을 위한 다양한 기법들을 손쉽게 프로젝트에 포함시킬 수 있습니다.</p>\n<p>React Query에서 제공하는 이러한 기능들은 우리 개발자들로 하여금 제품과 직접적으로 연관되지 않는 작업에 투입해야 하는 리소스를 경감시켜 더 중요한 비즈니스 로직에 집중할 수 있게끔 도와줍니다.\r\n이러한 환경은 우리가 더 견고한 제품을 만들 수 있는 바탕이 되어주고 있습니다.</p>\n<h3>마치며</h3>\n<p>React Query를 사용하면, <strong>'불필요한 코드의 감소', '업무와 협업의 효율성을 위한 규격화된 방식 제공', '사용자 경험 향상을 위한 다양한 Built-in 기능'</strong> 이라는 장점들을 정리해 볼 수 있겠네요~<br/>\r\n저도 React Query를 사용하면서 큰 매력을 느끼고 있었는데요!<br/>\r\n이렇게 정리해 보니 더더욱 쓸 이유가 확실해 보입니다!👍</p>\n<p>그럼 다음 포스팅에서 또 만나요!~😉</p>\n<hr>\n<h4>참고 링크</h4>\n<ul>\n<li><a href=\"https://tech.kakaopay.com/post/react-query-1/\">https://tech.kakaopay.com/post/react-query-1/</a></li>\n<li><a href=\"https://youthfulhps.dev/web/stale-while-ravalidate/\">https://youthfulhps.dev/web/stale-while-ravalidate/</a></li>\n</ul>","frontmatter":{"title":"리액트 쿼리(React Query)를 사용하는 이유","date":"November 20, 2023","description":"API 통신 및 비동기 상태 관리를 위한 라이브러리 React-query에 대해 알아봅시다","tags":["react","react-query","library","frontend"]}},"previous":{"fields":{"slug":"/img-lazy-loading/"},"frontmatter":{"title":"웹 성능 최적화를 위한 Lazy Loading 기법"}},"next":{"fields":{"slug":"/clean-code-01/"},"frontmatter":{"title":"노개북 - 클린코드 Assignment 01"}}},"pageContext":{"id":"2c44be0b-f238-50bf-8f75-f6a3af5ef241","previousPostId":"a75e5a09-d397-5031-9e21-632b67123f1e","nextPostId":"2d0b44a3-14c7-59c3-b379-e6c8b310d61b"}},"staticQueryHashes":["1085474499","2837417301"],"slicesMap":{}}