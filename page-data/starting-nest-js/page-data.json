{"componentChunkName":"component---src-templates-blog-post-js","path":"/starting-nest-js/","result":{"data":{"site":{"siteMetadata":{"title":"Kirahaa"}},"markdownRemark":{"id":"23e640cf-48be-5572-bc2c-91299defa17a","excerpt":"NestJS란? NestJS는 Node.js를 기반으로 한 서버 어플리케이션을 개발하기 위한 프레임워크 입니다. Node.js의 표준 웹서버 프레임워크로 불리는 Express 대신 왜 NestJS를 선택해야 할까요? 최근 몇 년 동안 Node.js…","html":"<h2>NestJS란?</h2>\n<p><a href=\"https://nestjs.com/\">NestJS</a>는 Node.js를 기반으로 한 서버 어플리케이션을 개발하기 위한 프레임워크 입니다.</p>\n<p>Node.js의 표준 웹서버 프레임워크로 불리는 Express 대신 왜 NestJS를 선택해야 할까요?</p>\n<blockquote>\n<p>최근 몇 년 동안 Node.js 덕분에 자바스크립트는 백엔드, 프론트엔드 애플리케이션 모두의 웹 공통 언어가 되었습니다.<br/>\r\n이로 인해 Angular, React, Vue가 나오게 되었으며, 해당 프로젝트를 통해 생산성을 향상하고 빠르게 만들 수 있으며, 테스트 가능하고 확장성이 있는 프론트엔드 애플리케이션을 만들 수 있게 되었습니다.\r\n그러나 서버 측 Node.js에서는 뛰어난 라이브러리, 툴이 존재하지만 아키텍처, 즉 프로젝트 구조에 있어서 주요 문제를 효과적으로 해결하는 것은 없었습니다.<br/></p>\n<p>Nest는 개발자와 팀이 테스트 가능하고 확장이 가능하며, 느슨한 결합과 유지보수성이 뛰어난 애플리케이션을 만들 수 있도록 아키텍처를 제공합니다.</p>\n</blockquote>\n<p>즉, <strong>NestJS는 서버 측 애플리케이션 개발에 있어 아키텍처의 문제를 해결하기 위해 등장</strong>한 것입니다.</p>\n<p>기존의 Express는 사용하기도 쉽고 성능도 뛰어나지만 아키텍처에 관한 정의나 기능을 제공해주고 있진 않습니다.<br/>\r\n실제로 팀 또는 사람마다 아키텍처가 다르면 이를 이해하기 위한 비용 또는 개발 전에 아키텍처를 선정하는 커뮤니케이션 비용이 증가합니다.<br/></p>\n<p>NestJS는 아키텍처에 대한 정의를 제공하기 때문에 동일한 아키텍처에서 다른 개발자가 작성한 코드를 쉽게 이해할 수 있다는 장점이 있습니다.</p>\n<p>그럼 NestJS를 설치해보면서 같이 시작해 봅시다! 🤗</p>\n<h2>NestJS CLI 설치</h2>\n<p>NestJS는 개발자가 좀 더 편리하게 NestJS 프로젝트를 개발하고 설정할 수 있도록 강력한 CLI(명령줄 인터페이스) 도구를 제공하고 있습니다.</p>\n<p>터미널을 열고 다음 명령어를 실행하여 NestJS CLI 도구를 전역(global)에 설치해 봅시다!</p>\n<deckgo-highlight-code language=\"shell\"  >\n          <code slot=\"code\">$ npm i -g @nestjs/cli\r\nadded 251 packages, and audited 252 packages in 11s\r\n\r\n41 packages are looking for funding\r\n  run `npm fund` for details\r\n\r\nfound 0 vulnerabilities</code>\n        </deckgo-highlight-code>\n<p>이제 터미널에서 <code>nest</code>라는 명령어를 사용할 수 있습니다.\r\n단순히 <code>nest</code> 명령어를 실행해보면 간단한 설명서를 확인할 수 있습니다.</p>\n<deckgo-highlight-code language=\"shell\"  >\n          <code slot=\"code\">$ nest\r\nnest\r\nUsage: nest &lt;command&gt; [options]\r\n\r\nOptions:\r\n  -v, --version                                   Output the current version.\r\n  -h, --help                                      Output usage information.\r\n\r\nCommands:\r\n  new|n [options] [name]                          Generate Nest application.\r\n  build [options] [app]                           Build Nest application.\r\n  start [options] [app]                           Run Nest application.\r\n  info|i                                          Display Nest project details.\r\n  add [options] &lt;library&gt;                         Adds support for an external library to your project.\r\n  generate|g [options] &lt;schematic&gt; [name] [path]  Generate a Nest element.\r\n    Schematics available on @nestjs/schematics collection:\r\n      ┌───────────────┬─────────────┬──────────────────────────────────────────────┐\r\n      │ name          │ alias       │ description                                  │\r\n      │ application   │ application │ Generate a new application workspace         │\r\n      │ class         │ cl          │ Generate a new class                         │\r\n      │ configuration │ config      │ Generate a CLI configuration file            │\r\n      │ controller    │ co          │ Generate a controller declaration            │\r\n      │ decorator     │ d           │ Generate a custom decorator                  │\r\n      │ filter        │ f           │ Generate a filter declaration                │\r\n      │ gateway       │ ga          │ Generate a gateway declaration               │\r\n      │ guard         │ gu          │ Generate a guard declaration                 │\r\n      │ interceptor   │ itc         │ Generate an interceptor declaration          │\r\n      │ interface     │ itf         │ Generate an interface                        │\r\n      │ middleware    │ mi          │ Generate a middleware declaration            │\r\n      │ module        │ mo          │ Generate a module declaration                │\r\n      │ pipe          │ pi          │ Generate a pipe declaration                  │\r\n      │ provider      │ pr          │ Generate a provider declaration              │\r\n      │ resolver      │ r           │ Generate a GraphQL resolver declaration      │\r\n      │ service       │ s           │ Generate a service declaration               │\r\n      │ library       │ lib         │ Generate a new library within a monorepo     │\r\n      │ sub-app       │ app         │ Generate a new application within a monorepo │\r\n      │ resource      │ res         │ Generate a new CRUD resource                 │\r\n      └───────────────┴─────────────┴──────────────────────────────────────────────┘</code>\n        </deckgo-highlight-code>\n<h2>NestJS 프로젝트 구성</h2>\n<p>다음으로 NestJS CLI를 이용해서 새로운 NestJS 프로젝트를 구성해 봅시다!</p>\n<p><code>nest new</code> 명령어 뒤에 프로젝트 명을 작성하면 해당 이름의 디렉토리가 생기고 그 안에 NestJS 프로젝트가 자동으로 구성이 될 것입니다.<br/>\r\n저는 <code>nest-app</code>을 프로젝트 이름으로 사용하였습니다.</p>\n<deckgo-highlight-code language=\"shell\"  >\n          <code slot=\"code\">$ nest new nest-app\r\n⚡  We will scaffold your app in a few seconds..\r\n\r\n✔ Installation in progress... ☕\r\n\r\n🚀  Successfully created project our-nestjs\r\n👉  Get started with the following commands:\r\n\r\n$ cd nest-app\r\n$ npm run start</code>\n        </deckgo-highlight-code>\n<p><code>npm run start</code>로 NestJS 애플리케이션을 구동한 후, <code>http://localhost:3000</code>에 접속해보면 Hello World!가 응답되는 것을 확인할 수 있을 것입니다.</p>\n<h2>main.ts</h2>\n<p>자동으로 생성된 파일 중에서 제일 먼저 살펴볼 파일은 <code>src</code> 디렉토리 안에 있는 <code>main.ts</code> 파일입니다.<br/>\r\n이 파일은 NestJS 애플리케이션이 시작되는 진입 지점(entry point)이 되는데요. 파일을 열어보면 매우 짧은 코드가 들어있습니다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">import { NestFactory } from &quot;@nestjs/core&quot;;\r\nimport { AppModule } from &quot;./app.module&quot;;\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n  await app.listen(3000);\r\n}\r\nbootstrap();</code>\n        </deckgo-highlight-code>\n<p>코드의 마지막 줄에는 <code>bootstrap()</code>이라는 함수를 호출하고 있는데요.\r\n<code>bootstrap()</code> 함수 안에서는 <code>app.module</code> 파일로부터 <code>AppModule</code>을 불러와서 <code>NestFactory</code>가 애플리케이션 객체를 생성하고 3000 포트로 HTTP 요청을 받고 있습니다.</p>\n<h2>모듈(Module)</h2>\n<p><code>main.ts</code> 파일에서 불러오고 있는 <code>app.module.ts</code> 파일을 열어보면 <code>AppModule</code> 클래스를 찾을 수 있습니다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">import { Module } from &quot;@nestjs/common&quot;;\r\nimport { AppController } from &quot;./app.controller&quot;;\r\nimport { AppService } from &quot;./app.service&quot;;\r\n\r\n@Module({\r\n  imports: [],\r\n  controllers: [AppController],\r\n  providers: [AppService],\r\n})\r\nexport class AppModule {}</code>\n        </deckgo-highlight-code>\n<p>이 클래스 위에는 <code>@Module()</code>이라는 데코리이터(decorator)가 호출되고 있습니다.</p>\n<p>NestJS에서 데코레이터는 일반적으로 클래스나 메서드에 어떤 정보를 추가해줄 때 활용이 됩니다.<br/>\r\n<code>@Module()</code> 데코레이터는 <code>imports</code>, <code>controllers</code>, <code>providers</code> 속성으로 이루어진 객체를 인자로 받는데요.\r\n<code>controllers</code> 속성에는 HTTP 요청을 받아서 응답을 보내는 컨트롤러 클래스를 나열해줄 수 있고, <code>providers</code> 속성에는 컨트롤러가 사용하는\r\n다양한 일반 클래스(주로 서비스 클래스)를 나열해줄 수 있습니다. 여기서 비어있는 <code>imports</code> 속성에는 해당 모듈이 의존하고 있는 다른 모듈을 나열해줄 수 있습니다.</p>\n<p>모듈(module)은 NestJS에 매우 중요한 개념이라서 잘 이해하고 있어야 하는데요. 하나의 NestJS 애플리케이션은 보통 여러 개의 모듈로 이루어지는데\r\n기능 단위로 애플리케이션을 쪼개 놓은 단위라고 생각할 수 있습니다.</p>\n<p>여기서 중요한 것은 모듈은 서로 의존할 수 있다는 것인데요. 바로 <code>Module()</code> 데코리에터에 인자로 넘기는 객체의 <code>imports</code> 속성을 통해서 이 의존 관계를 명시하도록 되었습니다.</p>\n<p><code>nestjs new</code> 명령어로 NestJS 프로젝트를 생성하면 기본적으로 최상위 모듈인 <code>AppModule</code> 하나 밖에 없지만, 프로젝트 규모가 점점 커지게 되면\r\n다른 모듈을 작성한 후 <code>AppModule</code>이 불러올 수 있도록 <code>@Module()</code> 데코레이터를 호출할 때 <code>imports</code> 속성을 사용하게 됩니다.</p>\n<p>정리하면 NestJS는 일종의 IoC(Inversion of Control) 컨테이너의 역할을 하면서 여러 모듈을 DI(의존성 주입)을 통해서 엮어준다고 보시면 됩니다.\r\n어떻게 엮어야 하는지는 개발자가 각 모듈에 <code>@Module()</code> 데코레이터의 <code>imports</code> 속성으로 NestJS에 알려줘야 하고요.</p>\n<h2>컨트롤러(Controller)</h2>\n<p>다음으로 NestJS에서 하나의 축을 담당하고 있는 컨트롤러에 대해서 알아보겠습니다.</p>\n<p>컨트롤러는 HTTP 요청을 받아서 처리하고 응답을 해주는 역할을 담당하고 있는 클래스입니다.<br/>\r\n<code>src</code> 디렉토리 안에 있는 <code>app.controller.ts</code> 파일을 열어서 컨트롤러가 어떻게 생겼는지 확인해 보겠습니다.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// src/app.controller.ts\r\n\r\nimport {Controller, Get} from &quot;@nestjs/common&quot;;\r\nimport {AppServie} from &quot;./app.service&quot;;\r\n\r\n@Controller()\r\nexport class AppController {\r\n  constructor(private readonly appService: AppService) {}\r\n  \r\n  @Get()\r\n  getHello(): string {\r\n    return this.appService.getHello();\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 클래스 위에다가 <code>@Controller()</code> 데코레이터를 호출해주면 NestJS가 해당 클래스는 컨트롤러로 인식을 하게 되는데요.\r\n클래스 내의 각 메서드에는 <code>@Get()</code>, <code>@Post()</code>, <code>@Delete()</code>와 같은 HTTP 방식(method)에 해당하는 데코레이터를 붙여주게 됩니다.</p>\n<p>또한 이러한 데코레이터들은 URL 경로를 나타내는 문자열을 인자로 받는데요. NestJS는 데코레이터로 명시된 HTTP 방식과 URL 경로를 기준으로 부합하는 클래스의 메서드를 호출해줍니다.</p>\n<p>예를 들어, <code>@Controller(\"aaa\")</code>가 붙어있는 클래스의 <code>@Post(\"bbb\")</code>가 붙어있는 메서드가 있었다면, POST 방식으로 <code>http://localhost:3000/aaa/bbb</code> 에 요청했을 때 해당 메서드가 호출되었을 것입니다.</p>\n<p>이를 통해 아까 전에 위에서 <code>http://localhost:3000</code>에 요청했을 때, <code>AppController</code> 클래스의 <code>getHello()</code> 함수가 이를 받아서 <code>Hello World!</code>라는 응답을 해줬다는 것을 알 수 있습니다.</p>\n<h2>서비스(Service)</h2>\n<p>마지막으로 살펴볼 서비스 클래스는 일반적으로 비즈니스 로직을 수행하는 역할을 담당합니다.</p>\n<p><code>src</code> 디렉토리 안에 있는 <code>app.service.ts</code>를 열어보면 <code>AppController</code> 클래스가 사용하고 있던 <code>AppService</code> 클래스를 확인할 수 있는데요.</p>\n<deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// src/app.service.ts\r\n\r\nimport { Injectable } from &quot;@nestjs/common&quot;;\r\n\r\n@Injectable()\r\nexport class AppService {\r\n  getHello(): string {\r\n    return &quot;Hello World!&quot;\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<p>이 클래스 위에는 <code>@Injectable()</code> 데코레이터가 사용되고 있죠? <code>@Injectable()</code> 데코레이터가 붙어있는 클래스는 NestJS가 인스턴스를 생성하여 다른 클래스에 생성자를 통해서 주입을 해줄 수 있습니다.</p>\n<p><code>AppModule</code>에서 <code>@Module()</code> 데코레이터를 호출할 때 <code>providers</code> 속성에 <code>AppService</code> 클래스를 명시해줬었죠? 그렇기 때문에 <code>AppController</code> 클래스의 생성자의 인자로 <code>AppService</code> 클래스의 인스턴스가 주입이 되었고, <code>AppController</code> 클래스의 <code>getHello</code> 메서드 내에서 <code>AppService</code> 클래스의 <code>getHello</code> 메서드를 호출할 수 있었던 것입니다.</p>\n<p>이렇게 컨트롤러의 역할과 서비스의 역할을 분리함으로써 좀 더 유지보수가 용이한 애플리케이션을 개발할 수가 있는 것입니다.</p>","frontmatter":{"title":"NestJS를 배워보자","date":"July 20, 2023","description":"NestJS는 자바스크립트나 타입스크립트로 서버 애플리케이션을 개발할 수 있는 백엔드 웹 프레임워크(Web framework)입니다.","tags":["NestJS","Express"]}},"previous":{"fields":{"slug":"/aws-ec2-hosting/"},"frontmatter":{"title":"AWS 프리티어 EC2와 Github 연동하기"}},"next":{"fields":{"slug":"/ts-type-interface/"},"frontmatter":{"title":"Typescript - type과 interface 차이"}}},"pageContext":{"id":"23e640cf-48be-5572-bc2c-91299defa17a","previousPostId":"1403beec-17fa-5740-bb74-db292102feab","nextPostId":"7f9ede5f-bbe7-5e7b-8734-78676f88253e"}},"staticQueryHashes":["2837417301","2841359383"],"slicesMap":{}}